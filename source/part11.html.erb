---
  title: Osa 11
  exercise_page: true
  quiz_page: true
  published: false
---

<% partial 'partials/hint', locals: { name: 'Yhdennentoista osan tavoitteet' } do %>

  <p>
    Tutustuu graafisten käyttöliittymien ohjelmointiin. Tuntee muutamia käyttöliittymäkomponentteja, käyttöliittymäkomponenttien asettelun mekanismeja, sekä osaa käsitellä käyttöliittymän tapahtumia. Osaa piirtää graafisen käyttöliittymän avulla.
  </p>

<% end %>





<% partial 'partials/material_heading' do %>
  Lisää rajapinnoista
<% end %>

<p>
  Rajapinta määrittelee yhden tai useamman metodin, jotka rajapinnan toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>. Rajapinta määrää, että <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>

<% partial 'partials/code_highlight' do %>
  package sovellus.domain;

  public interface Tunnistettava {
  String getTunnus();
  }
<% end %>

<p>
  Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Alla on esimerkkinä luokka <code>Henkilo</code>, joka toteuttaa rajapinnan tunnistettava. Rajapinnan Tunnistettava vaatima metodi <code>getTunnus</code> palauttaa aina henkilön henkilötunnuksen.
</p>

<% partial 'partials/code_highlight' do %>
  package sovellus.domain;

  public class Henkilo implements Tunnistettava {
  private String nimi;
  private String henkilotunnus;

  public Henkilo(String nimi, String henkilotunnus) {
  this.nimi = nimi;
  this.henkilotunnus = henkilotunnus;
  }

  public String getNimi() {
  return this.nimi;
  }

  public String getHenkilotunnus() {
  return this.henkilotunnus;
  }

  @Override
  public String getTunnus() {
  return getHenkilotunnus();
  }

  @Override
  public String toString() {
  return this.nimi + " hetu: " + this.henkilotunnus;
  }
  }
<% end %>


<p>
  Rajapintojen vahvuus on se, että rajapintaa voidaan käyttää muuttujan tyyppinä. Tämä mahdollistaa yleiskäyttöisempien luokkien tekemisen.
</p>

<p>
  Tehdään luokka <code>Rekisteri</code>, jota käytetään Tunnistettava-tyyppisten olioiden säilömiseen. Rekisteriin voidaan lisätä sekä henkilöitä että mitä tahansa muita olioita, jotka toteuttavat rajapinnan Tunnistettava. Yksittäisten henkilöiden hakemisen lisäksi <code>Rekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.
</p>

<% partial 'partials/code_highlight' do %>
  public class Rekisteri {
  private Map&lt;String, Tunnistettava&gt; rekisteroidyt;

  public Rekisteri() {
  this.rekisteroidyt = new HashMap&lt;&gt;();
  }

  public void lisaa(Tunnistettava lisattava) {
  this.rekisteroidyt.put(lisattava.getTunnus(), lisattava);
  }

  public Tunnistettava hae(String tunnus) {
  return this.rekisteroidyt.get(tunnus);
  }

  public List&lt;Tunnistettava&gt; haeKaikki() {
  return new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
  }
  }<% end %>

<p>
  Rekisterin käyttö onnistuu seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Rekisteri henkilokunta = new Rekisteri();
  henkilokunta.lisaa(new Henkilo("Pekka", "221078-123X"));
  henkilokunta.lisaa(new Henkilo("Jukka", "110956-326B"));

  System.out.println(henkilokunta.hae("280283-111A"));

  Henkilo loydetty = (Henkilo) henkilokunta.hae("110956-326B");
  System.out.println(loydetty.getNimi());
<% end %>

<p>
  Koska henkilöt on lisätty rekisteriin <code>Tunnistettava</code>-tyyppisinä, ne löytyvät sieltä myös Tunnistettava-tyyppisinä. Jos haluamme käsitellä henkilöitä sellaisten metodien kautta, joita rajapinnassa ei ole määritelty, joudumme muuntamaan ne takaisin Henkilo-olioiksi. Tämä tapahtuu eksplisiittisella tyyppimuunnoksella, jota demonstroidaan edellisen esimerkin kahdella viimeisellä rivillä.
</p>

<p>
  Entä jos haluaisimme rekisteriin lisäksi metodin, joka palauttaa rekisteriin talletetut henkilöt tunnisteen mukaan järjestettynä? Yksi vaihtoehto olisi käyttää aiemmin tutuksi tullutta virran järjestämistä. Tutustutaan kuitenkin myös Javan valmiiseen järjestämisessä käytettävään rajapintaan.
</p>


<% partial 'partials/material_sub_heading' do %>
  Järjestämisessä käytettävä rajapinta Comparable
<% end %>

<p>
  Javan valmis rajapinta <code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a></code> määrittelee metodin <code>compareTo</code>, jota käytetään olioiden vertailuun. Jos olio on vertailujärjestyksessä ennen parametrina saatavaa olioa, tulee metodin palauttaa negatiivinen luku. Jos taas olio on järjestyksessä parametrina saatavan olion jälkeen, tulee metodin palauttaa positiivinen luku. Muulloin palautetaan luku 0. Tätä <code>compareTo</code>-metodin avulla johdettua järjestystä kutsutaan <em>luonnolliseksi järjestykseksi</em> (natural ordering).
</p>

<p>
  Tarkastellaan tätä ensin kerhossa käyvää lasta tai nuorta kuvaavan luokan Kerholainen avulla. Jokaisella kerholaisella on nimi ja pituus. Kerholaisten tulee mennä syömään pituusjärjestyksessä, joten toteutetaan kerholaisille rajapinta <code>Comparable</code>. Comparable-rajapinta ottaa tyyppiparametrinaan luokan, johon vertaus tehdään. Käytetään tyyppiparametrina samaa luokkaa <code>Kerholainen</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kerholainen implements Comparable&lt;Kerholainen&gt; {
  private String nimi;
  private int pituus;

  public Kerholainen(String nimi, int pituus) {
  this.nimi = nimi;
  this.pituus = pituus;
  }

  public String getNimi() {
  return this.nimi;
  }

  public int getPituus() {
  return this.pituus;
  }

  @Override
  public String toString() {
  return this.getNimi() + " (" + this.getPituus() + ")";
  }

  @Override
  public int compareTo(Kerholainen kerholainen) {
  if (this.pituus == kerholainen.getPituus()) {
  return 0;
  } else if (this.pituus &gt; kerholainen.getPituus()) {
  return 1;
  } else {
  return -1;
  }
  }
  }<% end %>

<p>
  Rajapinnan vaatima metodi <code>compareTo</code> palauttaa kokonaisluvun, joka kertoo vertausjärjestyksestä. Koska <code>compareTo()</code>-metodista riittää palauttaa negatiivinen luku, jos <code>this</code>-olio on pienempi kuin parametrina annettu olio ja nolla, kun pituudet ovat samat, voidaan edellä esitelty metodi <code>compareTo</code> toteuttaa myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public int compareTo(Kerholainen kerholainen) {
  return this.pituus - kerholainen.getPituus();
  }
<% end %>

<p>
  Kerholaisten järjestäminen on nyt suoraviivaista.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
  kerholaiset.add(new Kerholainen("mikael", 182));
  kerholaiset.add(new Kerholainen("matti", 187));
  kerholaiset.add(new Kerholainen("ada", 184));

  kerholaiset.stream().forEach(k -&gt; System.out.println(k);
  System.out.println();
  kerholaiset.stream().sorted().forEach(k -&gt; System.out.println(k);
<% end %>

<% partial 'partials/sample_output' do %>
  mikael (182)
  matti (187)
  ada (184)

  mikael (182)
  ada (184)
  matti (187)
<% end %>

<p>
  Koska Kerholainen toteuttaa rajapinnan Comparable, ei virran <code>sorted</code>-metodille tarvitse enää antaa parametrina olioiden vertailuun liittyvää järjestystä. Toisin sanoen, minkä tahansa Comparable-rajapinnan toteuttavan luokan oliot voi järjestää virran sorted-metodilla. Huomaa kuitenkin, että virta ei järjestä alkuperäistä listaa, vaan <em>vain virrassa olevat alkiot ovat järjestyksessä</em> -- jos alkuperäisen listan haluaa järjestykseen, tulee lista korvata järjestetystä virrasta kerätyllä listalla.
</p>



<% partial 'partials/exercise', locals: { name: 'Palkkajärjestys' } do %>

  <p>
    Saat valmiin luokan Ihminen. Ihmisellä on nimi- ja palkkatiedot. Muokkaa Ihminen-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee ihmiset palkan mukaan järjestykseen isoimmasta palkasta pienimpään.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Opiskelijat nimijärjestykseen' } do %>

  <p>
    Saat valmiin luokan Opiskelija. Opiskelijalla on nimi. Muokkaa Opiskelija-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee opiskelijat nimen mukaan aakkosjärjestykseen.
  </p>

  <p>
    <strong>Vinkki:</strong> Opiskelijan nimi on String, ja String-luokka on itsessään <code>Comparable</code>. Voit hyödyntää String-luokan <code>compareTo</code>-metodia Opiskelija-luokan metodia toteuttaessasi. <code>String.compareTo</code> kohtelee kirjaimia eriarvoisesti kirjainkoon mukaan, ja tätä varten String-luokalla on myös metodi <code>compareToIgnoreCase</code> joka nimensä mukaisesti jättää kirjainkoon huomioimatta. Voit käyttää opiskelijoiden järjestämiseen kumpaa näistä haluat.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Useamman rajapinnan toteuttaminen
<% end %>

<p>
  Luokka voi toteuttaa useamman rajapinnan. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidän toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalle <code>Henkilo</code> rajapinta <code>Comparable</code>.
</p>

<% partial 'partials/code_highlight' do %>
  package sovellus.domain;

  public class Henkilo implements Tunnistettava, Comparable&lt;Henkilo&gt; {
  private String nimi;
  private String henkilotunnus;

  public Henkilo(String nimi, String henkilotunnus) {
  this.nimi = nimi;
  this.henkilotunnus = henkilotunnus;
  }

  public String getNimi() {
  return this.nimi;
  }

  public String getHenkilotunnus() {
  return this.henkilotunnus;
  }

  @Override
  public String getTunnus() {
  return getHenkilotunnus();
  }

  @Override
  public int compareTo(Henkilo toinen) {
  return this.getTunnus().compareTo(toinen.getTunnus());
  }
  }
<% end %>

<p>
  Kokeillaan lisätä aiemmin luomallemme Rekisteri-luokalle metodi haeKaikkiJarjestyksessa.
</p>

<% partial 'partials/code_highlight' do %>
  public List&lt;Tunnistettava&gt; haeKaikkiJarjestyksessa() {
  // ei toimi!
  return rekisteroidyt.values()
  .stream().sorted().collect(Collectors.toCollection(ArrayList::new));
  }
<% end %>

<p>
  Metodi ei kuitenkaan toimi. Koska henkilöt on talletettu rekisteriin <code>Tunnistettava</code>-tyyppisinä, on Henkilön toteutettava rajapinta <code>Comparable&lt;Tunnistettava&gt;</code>, jotta rekisteri osaisi järjestää henkilöt tunnistettavina. Joudumme joko muuttamaan henkilön toteuttamaa rajapintaa, tai lisäämään <code>sorted</code>-metodille järjestämiseen käytettävät tiedot. Muutetaan tässä henkilön toteuttamaa rajapintaa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo implements Tunnistettava, Comparable&lt;Tunnistettava&gt; {
  // ...

  @Override
  public int compareTo(Tunnistettava toinen) {
  return this.getTunnus().compareTo(toinen.getTunnus());
  }
  }<% end %>

<p>
  Nyt ratkaisu toimii!
</p>

<p>
  Rekisteri on täysin tietämätön sinne lisättyjen olioiden todellisesta tyypistä. Voimme käyttää luokkaa rekisteri myös muuntyyppisten olioiden kuin henkilöiden rekisteröintiin, kunhan olioiden luokka vaan toteuttaa rajapinnan <code>Tunnistettava</code>. Esim. seuraavassa käytetään rekisteriä kaupassa myytävien tuotteiden hallintaan:
</p>

<% partial 'partials/code_highlight' do %>
  public class Tuote implements Tunnistettava {

  private String nimi;
  private String viivakoodi;
  private int varastosaldo;
  private int hinta;

  public Tuote(String nimi, String viivakoodi) {
  this.nimi = nimi;
  this.viivakoodi = viivakoodi;
  }

  public String getTunnus() {
  return viivakoodi;
  }

  // ...
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  Rekisteri tuotteet = new Rekisteri();
  tuotteet.lisaa(new Tuote("maito", "11111111"));
  tuotteet.lisaa(new Tuote("piimä", "11111112"));
  tuotteet.lisaa(new Tuote("juusto", "11111113"));

  System.out.println(tuotteet.hae("99999999"));

  Tuote tuote = (Tuote) tuotteet.hae("11111112");
  tuote.kasvataSaldoa(100);
  tuote.muutaHinta(23);
<% end %>

<p>
  Teimme luokasta <code>Rekisteri</code> melko yleiskäyttöisen pitämällä sen riippumattomana konkreettisista luokista. Mikä tähänsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code>, on rekisterin kanssa käyttökelpoinen. Metodin <code>haeKaikkiJarjestyksessä</code> toimiminen tosin edellyttää luokalta myös vertailtavuuden eli Comparable&lt;Tunnistettava&gt;-rajapinnan toteuttamisen.
</p>


<% partial 'partials/hint', locals: { name: 'Muutama NetBeans-vihje' } do %>

  <ul>
    <li> <strong>Implement all abstract methods</strong>

      <p>
	Voit pyytää NetBeansia täydentämään metodirungot automaattisesti rajapinnan toteuttavalle luokalle. Kun olet määritellyt luokan toteuttavan rajapinnan, eli kirjoittanut
      </p>

      <% partial 'partials/code_highlight' do %>
	public class Luokka implements Rajapinta {
	}
      <% end %>

      <p>
	NetBeans värjää luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvät koodiin!
      </p>

    </li>

    <li> <strong>Clean and Build</strong>

      <p>
	Tietyissä tilanteissa NetBeans saattaa mennä sekaisin ja yrittää ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. Yleensä huomaat tilanteen siten, että jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio löytyy Run-valikosta ja sen voi suorittaa myös painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat käännetyt versiot ja tekee uuden käännöksen.
      </p>

    </li>

  </ul>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Oletusmetodit rajapinnoissa
<% end %>

<p>
  Rajapintoihin voi määritellä oletusmetodeja, joiden mukana annetaan myös toteutus. Oletusmetodien määrittely alkaa avainsanalla <code>default</code>, jota seuraa metodin määrittely. Kuten rajapintojen metodeissa yleensä, myös tässäkään näkyvyyttä ei tarvitse määritellä erikseen. Rajapinnoissa määriteltyjen metodien näkyvyys on aina <code>public</code>.
</p>

<p>
  Alla olevassa esimerkissä rajapintaan <code>Luettava</code> on lisätty oletusmetodi <code>lueTulostaen</code>, joka tulostaa <code>lue</code>-metodin palauttaman arvon.
</p>

<% partial 'partials/code_highlight' do %>
  public interface Luettava {
  String lue();

  default void lueTulostaen() {
  System.out.println(lue());
  }
  }
<% end %>

<p>
  Yksi oletusmetodien suurimmista hyödyistä ilmenee tilanteissa, missä rajapinta on määritelty aiemmin, ja useampi luokka toteuttaa sen jo valmiiksi. Jos rajapintaan lisätään uusi metodi, tulee sille ohjelmoida toteutus kaikkiin rajapinnan toteuttamiin luokkiin, jos uusi metodi ei tarjoa oletustoteutusta.
</p>

<p>
  Toisaalta, jos oletustoteutus lisätään uuden metodin lisäämisen yhteydessä, ei aiemmin rajapinnan toteuttaneille luokille tarvitse tehdä minkäänlaisia muutoksia. Edellisestä osasta tutut luokat Tekstiviesti ja Sahkoposti toimisivat nyt myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Tekstiviesti viesti = new Tekstiviesti("G. Hopper", "COBOL kicks ass");
  viesti.lueTulostaen();

  Sahkoposti posti = new Sahkoposti("D. Knuth", "If you optimize everything, you will always be unhappy.");
  posti.lueTulostaen();
<% end %>

<% partial 'partials/sample_output' do %>
  COBOL kicks ass
  If you optimize everything, you will always be unhappy.
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Järjestäminen ja hakeminen
<% end %>

<p>
  Tähän mennessä käyttämämme järjestäminen stream-metodin avulla ei muuta alkuperäisen listan järjestystä, vaan se luo aina uuden järjestetyn listan. Tutustutaan seuraavaksi luokkakirjastoon <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html" target="_blank" rel="noopener">Collections</a>, joka tarjoaa tähän liittyviä yleishyödyllisiä metodeja.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Järjestäminen
<% end %>

<p>
  Collections tarjoaa metodin <code>sort</code> listan järjestämiseen. Metodi olettaa, että listalla olevat oliot toteuttavat rajapinnan Comparable. Järjestäminen on suoraviivaista.
</p>


<% partial 'partials/code_highlight' do %>
  List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
  kerholaiset.add(new Kerholainen("mikael", 182));
  kerholaiset.add(new Kerholainen("matti", 187));
  kerholaiset.add(new Kerholainen("ada", 184));

  kerholaiset.stream().forEach(k -&gt; System.out.println(k));
  Collections.sort(kerholaiset);

  System.out.println();

  kerholaiset.stream().forEach(k -&gt; System.out.println(k));
<% end %>

<% partial 'partials/sample_output' do %>
  mikael (182)
  matti (187)
  ada (184)

  mikael (182)
  ada (184)
  matti (187)
<% end %>

<p>
  Järjestämisen lisäksi luokkakirjaston avulla voi etsiä esimerkiksi minimi- (<code>min</code>-metodi) tai maksimialkioita (<code>max</code>-metodi), vaikkapa kääntää listan (<code>reverse</code>-metodi).
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
  kerholaiset.add(new Kerholainen("mikael", 182));
  kerholaiset.add(new Kerholainen("matti", 187));
  kerholaiset.add(new Kerholainen("ada", 184));

  kerholaiset.stream().forEach(k -&gt; System.out.println(k));
  Collections.sort(kerholaiset);
  Collections.reverse(kerholaiset);

  System.out.println();

  kerholaiset.stream().forEach(k -&gt; System.out.println(k));

  System.out.println();
  System.out.println(Collections.max(kerholaiset));
<% end %>

<% partial 'partials/sample_output' do %>
  mikael (182)
  matti (187)
  ada (184)

  matti (187)
  ada (184)
  mikael (182)

  matti (187)
<% end %>

<%= partial 'partials/quiz', locals: { id: '59fdce547bced50004788107' } %>


<% partial 'partials/exercise', locals: { name: 'Kirjallisuutta (3 osaa)' } do %>
  
  <p>
    Tee ohjelma, joka lukee käyttäjältä kirjoja ja niiden minimikohdeikiä. Minimikohdeiällä tarkoitetaan pienintä ikää vuosina, jolle kyseistä kirjaa suositellaan.
  </p>

  <p>
    Ohjelma kysyy uusia kirjoja kunnes käyttäjä syöttää tyhjän merkkijonon kirjan nimen kohdalla (eli painaa rivinvaihtoa). Täämän jälkeen ohjelma tulostaa syötettyjen kirjojen lukumäärän sekä kirjat.
  </p>

  <h2>Kirjojen lukeminen ja tulostaminen</h2>

  <p>
    Toteuta ensin kirjojen lukeminen ja niiden listaaminen. Tässä vaiheessa kirjojen järjestyksellä ei ole vielä väliä.
  </p>

  <% partial 'partials/sample_output' do %> 
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Soiva tuutulaulukirja</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>

    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Kurkkaa kulkuneuvot</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Lunta tupaan</font>
    Syötä kirjan pienin kohdeikä: <font color="red">12</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Litmanen 10</font>
    Syötä kirjan pienin kohdeikä: <font color="red">10</font>
    
    Syötä kirjan nimi, tyhjä lopettaa:
    
    Yhteensä 4 kirjaa.
    
    Kirjat:
    Soiva tuutulaulukirja (0 vuotiaille ja vanhemmille)
    Kurkkaa kulkuneuvot (0 vuotiaille ja vanhemmille)
    Lunta tupaan (12 vuotiaille ja vanhemmille)
    Litmanen 10 (10 vuotiaille ja vanhemmille)
  <% end %>
  
  <h2>Kirjojen järjestäminen kohdeiän perusteella</h2>

  <p>
    Täydennä toteuttamaasi ohjelmaa siten, että kirjat järjestetään tulostuksen yhteydessä kohdeiän perusteella. Jos kahdella kirjalla on sama kohdeikä, näiden kahden kirjan keskinäinen järjestys saa olla mielivaltainen.
  </p>


  <% partial 'partials/sample_output' do %> 
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Soiva tuutulaulukirja</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>

    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Kurkkaa kulkuneuvot</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Lunta tupaan</font>
    Syötä kirjan pienin kohdeikä: <font color="red">12</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Litmanen 10</font>
    Syötä kirjan pienin kohdeikä: <font color="red">10</font>
    
    Syötä kirjan nimi, tyhjä lopettaa:
    
    Yhteensä 4 kirjaa.
    
    Kirjat:
    Soiva tuutulaulukirja (0 vuotiaille ja vanhemmille)
    Kurkkaa kulkuneuvot (0 vuotiaille ja vanhemmille)
    Litmanen 10 (10 vuotiaille ja vanhemmille)
    Lunta tupaan (12 vuotiaille ja vanhemmille)
  <% end %>

  
  <h2>Kirjojen järjestäminen kohdeiän ja nimen perusteella</h2>

  <p>
    Täydennä edellistä ohjelmaasi siten, että saman kohdeiän kirjat tulostetaan aakkosjärjestyksessä.
  </p>


  <% partial 'partials/sample_output' do %> 
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Soiva tuutulaulukirja</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>

    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Kurkkaa kulkuneuvot</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Lunta tupaan</font>
    Syötä kirjan pienin kohdeikä: <font color="red">12</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Litmanen 10</font>
    Syötä kirjan pienin kohdeikä: <font color="red">10</font>
    
    Syötä kirjan nimi, tyhjä lopettaa:
    
    Yhteensä 4 kirjaa.
    
    Kirjat:
    Kurkkaa kulkuneuvot (0 vuotiaille ja vanhemmille)
    Soiva tuutulaulukirja (0 vuotiaille ja vanhemmille)
    Litmanen 10 (10 vuotiaille ja vanhemmille)
    Lunta tupaan (12 vuotiaille ja vanhemmille)
  <% end %>

<% end %>




<% partial 'partials/exercise', locals: { name: 'Muuttaminen (4 osaa)' } do %>

  <p>
    Muuttokuormaa pakattaessa esineitä lisätään muuttolaatikoihin siten, että tarvittujen laatikoiden määrä on mahdollisimman pieni. Tässä tehtävässä simuloidaan esineiden pakkaamista muuttolaatikoihin. Jokaisella esineellä on tilavuus, ja muuttolaatikoilla on maksimitilavuus.
  </p>


  <h2>Tavara ja Esine</h2>

  <p>
    Muuttomiehet siirtävät tavarat myöhemmin rekka-autoon (ei toteuteta tässä), joten toteutetaan ensin kaikkia esineitä ja laatikoita kuvaava <code>Tavara</code>-rajapinta.
  </p>

  <p>
    Tavara-rajapinnan tulee määritellä metodi <code>int getTilavuus()</code>, jonka avulla tavaroita käsittelevät saavat selville kyseisen tavaran tilavuuden. Toteuta rajapinta <code>Tavara</code> pakkaukseen <code>muuttaminen.domain</code>.
  </p>

  <p>
    Toteuta seuraavaksi pakkaukseen <code>muuttaminen.domain</code> luokka <code>Esine</code>, joka saa konstruktorin parametrina esineen nimen (String) ja esineen tilavuuden (int). Luokan tulee toteuttaa rajapinta <code>Tavara</code>.
  </p>

  <p>
    Lisää luokalle <code>Esine</code> myös metodit <code>public String getNimi()</code> ja korvaa metodi <code>public String toString()</code> siten että se tuotta merkkijonoja muotoa "<code>nimi (tilavuus dm^3)</code>". Esineen tulee toimia seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    Tavara esine = new Esine("hammasharja", 2);
    System.out.println(esine);
  <% end %>

  <% partial 'partials/sample_output' do %>
    hammasharja (2 dm^3)
  <% end %>


  <h2>Esine vertailtavaksi</h2>

  <p>
    Pakatessamme esineitä muuttolaatikkoon haluamme aloittaa pakkaamisen järjestyksessä olevista esineistä. Toteuta <code>Esine</code>-luokalla rajapinta <code>Comparable</code> siten, että esineiden <em>luonnollinen järjestys</em> on tilavuuden mukaan nouseva. Kun olet toteuttanut esineellä rajapinnan <code>Comparable</code>, tulee niiden toimia <code>Collections</code>-luokan <code>sort</code>-metodin kanssa seuraavasti.
  </p>


  <% partial 'partials/code_highlight' do %>
    List&lt;Esine&gt; esineet = new ArrayList&lt;&gt;();
    esineet.add(new Esine("passi", 2));
    esineet.add(new Esine("hammasharja", 1));
    esineet.add(new Esine("sirkkeli", 100));

    Collections.sort(esineet);
    System.out.println(esineet);
  <% end %>

  <% partial 'partials/sample_output' do %>
    [hammasharja (1 dm^3), passi (2 dm^3), sirkkeli (100 dm^3)]
  <% end %>


  <h2>Muuttolaatikko</h2>

  <p>Toteuta tämän jälkeen pakkaukseen <code>muuttaminen.domain</code> luokka <code>Muuttolaatikko</code>. Tee aluksi muuttolaatikolle seuraavat:</p>


  <ul>
    <li><code>public Muuttolaatikko(int maksimitilavuus)</code></li>Muuttolaatikko-luokan konstruktori. Saa parametrina muuttolaatikon maksimitilavuuden.<br/>
    <li><code>public boolean lisaaTavara(Tavara tavara)</code></li> Lisää muuttolaatikkoon <code>Tavara</code>-rajapinnan toteuttaman esineen. Jos laatikkoon ei mahdu, metodi palauttaa arvon <code>false</code>. Jos tavara mahtuu laatikkoon, metodi palauttaa arvon <code>true</code>. Muuttolaatikon tulee tallettaa tavarat listaan.<br/>
  </ul>

  <p>
    Laita vielä <code>Muuttolaatikko</code> toteuttamaan rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code> tulee saada selville muuttolaatikossa olevien tavaroiden tämänhetkinen yhteistilavuus.
  </p>


  <h2>Esineiden pakkaaminen</h2>

  <p>
    Toteuta luokka <code>Pakkaaja</code> pakkaukseen <code>muuttaminen.logiikka</code>. Luokan <code>Pakkaaja</code> konstruktorille annetaan parametrina <code>int laatikoidenTilavuus</code>, joka määrittelee minkä kokoisia muuttolaatikoita pakkaaja käyttää.
  </p>

  <p>
    Toteuta tämän jälkeen luokalle metodi <code>public List&lt;Muuttolaatikko&gt; pakkaaTavarat(List&lt;Tavara&gt; tavarat)</code>, joka pakkaa tavarat muuttolaatikoihin.
  </p>

  <p>
    TODO: tulee heittää poikkeus mikäli tavarat eivät järjestyksessä.
  </p>

  <p>
    Tee metodista sellainen, että kaikki parametrina annetussa listassa olevat tavarat päätyvät muuttolaatikoihin. Muuttolaatikot tulee luoda metodissa. Sinun ei tarvitse varautua tilanteisiin, joissa tavarat ovat suurempia kuin pakkaajan käyttämä muuttolaatikon koko. Testit eivät välitä siitä kuinka täyteen pakkaaja täyttää muuttolaatikot.
  </p>

  <% partial 'partials/code_highlight' do %>
    // tavarat jotka haluamme pakata
    List&lt;Tavara&gt; tavarat = new ArrayList&lt;&gt;();
    tavarat.add(new Esine("passi", 2));
    tavarat.add(new Esine("hammasharja", 1));
    tavarat.add(new Esine("kirja", 4));
    tavarat.add(new Esine("sirkkeli", 8));

    // luodaan pakkaaja, joka käyttää tilavuudeltaan 10:n kokoisia muuttolaatikoita
    Pakkaaja pakkaaja = new Pakkaaja(10);

    // pyydetään pakkaajaa pakkaamaan tavarat laatikoihin
    List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaTavarat(tavarat);

    System.out.println("laatikoita: " + laatikot.size());

    laatikot.stream().forEach(laatikko -&gt; {
    System.out.println("  laatikossa tavaraa: " + laatikko.getTilavuus() + " dm^3");
    });
  <% end %>


  <% partial 'partials/sample_output' do %>
    laatikoita: 2
    laatikossa tavaraa: 7 dm^3
    laatikossa tavaraa: 8 dm^3
  <% end %>

  <p>
    Pakkaaja on siis pakannut tavarat kahteen laatikkoon, ensimmäiseen laatikkoon on mennyt 3 ensimmäistä tavaraa, yhteistilavuudeltaan 7, ja listan viimeinen tavara eli sirkkeli jonka tilavuus on 8 on mennyt toiseen laatikkoon. Testit eivät aseta rajoitusta pakkaajan käyttävien muuttolaatioiden määrälle, tavarat olisi siis voitu pakata vaikka jokainen eri laatikkoon, eli tuloste olisi ollut:
  </p>

  <% partial 'partials/sample_output' do %>
    laatikoita: 4
    laatikossa tavaraa: 2 dm^3
    laatikossa tavaraa: 1 dm^3
    laatikossa tavaraa: 7 dm^3
    laatikossa tavaraa: 8 dm^3
  <% end %>

  <p>
    <strong>Huom:</strong> tehtävän testaamista helpottamaan kannatanee tehdä luokalle <code>Muuttolaatikko</code> esim. toString-metodi, jonka avulla voi printata laatikon sisällön.
  </p>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Binäärihaku ja hakeminen
<% end %>

<p>
  Binäärihaku (tunnetaan myös nimellä puolitushaku) etsii annettua arvoa järjestyksessä olevasta listasta. Tutustutaan algoritmin ideaa seuraavan järjestyksessä olevan listan avulla.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   0   1   2   3    4   5    6   7   8   9  10
  // luvut     -7  -3   3   7   11  15   17  21  24  28  30
<% end %>

<p>
  Oletetaan että haluamme löytää luvun 17 indeksin. Hyödynnetään tietoa siitä että arvot ovat järjestyksessä. Sen sijaan, että kävisimme lukuja läpi alusta lähtien, tarkastelemme arvoa listan puolivälissä. Listan puolivälissä olevan alkion indeksi on isoin indeksi 10 jaettuna kahdella eli 5. Keskimmäinen alkio on merkattu seuraavaan tähdellä:
</p>

<% partial 'partials/sample_output' do %>
  *
  // indeksit   0   1   2   3    4   5    6   7   8   9  10
  // luvut     -7  -3   3   7   11  15   17  21  24  28  30
<% end %>

<p>
  Puolessa välissä on luku 15, joka ei ollut hakemamme luku (eli luku 17). Koska taulukko on järjestyksessä (tässä suuruusjärjestyksessä), ei etsitty luku voi missään tapauksessa olla luvun 15 vasemmalla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat pienempiä tai yhtäsuuria kuin 5, eivät missään nimessä sisällä hakemaamme arvoa.
</p>

<p>
  Alue, jolta etsimme haettavaa lukua voidaan nyt rajata lukuihin, jotka sijaitsevat indeksin 5 oikealla puolella, eli indekseihin välillä [6, 10] (6, 7, 8, 9, 10). Seuraavassa on merkitty harmaalla se osa taulukkoa jossa etsitty ei voi olla:
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7   8   9  10
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
<% end %>

<p>
  Tutkitaan seuraavaksi jäljellä olevan etsintäalueen, eli indeksien 6-10 keskimmäistä indeksiä. Keskimmäinen indeksi löytyy laskemalla etsintäalueen pienimmän ja suurimman indeksin summan ja jakamalla se kahdella, eli (6+10)/2 = 16/2 = 8. Indeksi 8 on merkitty alle tähdellä.
</p>

<% partial 'partials/sample_output' do %>
  *
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7   8   9  10
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
<% end %>

<p>
  Indeksissä 8 oleva luku on 24, joka ei ollut hakemamme luku. Koska luvut taulukossa ovat suuruusjärjestyksessä, ei etsittävä luku voi missään nimessä olla luvun 24 oikealla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat suurempia tai yhtäsuuria kuin 8, eivät missään nimessä sisällä hakemaamme arvoa. Etsintäalue rajautuu taas:
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Etsintä jatkuu. Tutkitaan jäljellä olevan etsintäalueen, eli indeksien 6-7, keskimmäistä indeksiä. Keskimmäinen indeksi löytyy taas ottamalla etsintäalueen pienimmän ja suurimman indeksin summa ja jakamalla se kahdella, eli (6+7)/2 = 6,5, joka pyöristyy alaspäin luvuksi 6. Kohta on merkitty alle tähdellä.
</p>

<% partial 'partials/sample_output' do %>
  *
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Indeksissä 6 on luku 17, joka on sama kuin hakemamme luku. Voimme lopettaa haun ja ilmoittaa että etsitty luku on taulukossa. Jos luku ei olisi ollut taulukossa -- esimerkiksi jos haettava luku olisi ollut 16, etsintäalue olisi jäänyt lopulta tyhjäksi.
</p>

<% partial 'partials/sample_output' do %>
  *
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    <font color="red">6</font>   7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   <font color="red">17</font>  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Simuloi kynällä ja paperilla miten binäärihaku toimii kun taulukkona on alla oleva taulukko ja haet ensin lukua 33, sitten lukua 1.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   0   1   2   3   4   5   6   7   8   9  10  11  12  13
  // luvut     -5  -2   3   5   8  11  14  20  22  26  29  33  38  41
<% end %>


<% partial 'partials/hint', locals: { name: 'Binäärihaku vs. Peräkkäishaku' } do %>
  
  <p>
    Peräkkäishaun pahimmassa tapauksessa käydään kaikki taulukon arvot läpi. Miljoona alkiota sisältävässä taulukossa tämä tarkoittaa miljoonan alkion tarkastelua.
  </p>

  <p>
    Binäärihaun pahimmassa tapauksessa tutkittava alue jaetaan kahteen osaan kunnes osan koko on yksi. Alkioita tarkastellaan huomattavasti vähemmän kuin peräkkäishaussa. Tarkastellaan tätä hieman tarkemmin.
  </p>

  <p>
    Lista, jossa on 16 alkiota, voidaan jakaa kahteen osaan korkeintaan 4 kertaa, eli 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1.
  </p>

  <p>
    Toisaalta, lista, jossa on miljoona alkiota voidaan jakaa kahteen osaan korkeintaa 20 kertaa, eli 1000000 -&gt; 500000 -&gt; 250000 -&gt; 125000 -&gt; 62500 -&gt; 31250 -&gt; 15625 -&gt; ~7813 -&gt; ~3907 -&gt; 1954 -&gt; ~977 -&gt; ~489 -&gt; ~245 -&gt; ~123 -&gt; ~62 -&gt; ~31 -&gt; ~16 -&gt; ~8 -&gt; ~4 -&gt; ~2 -&gt; ~1.
  </p>

  <p>
    Mitä tämä tarkoittaa? Binäärihakua käyttäen miljoona alkiota sisältävästä listasta tulee pahimmassa tapauksessa tarkastella noin kahtakymmentä alkiota, kun peräkkäishaussa tarkasteltavia alkioita on miljoona.
  </p>

  <p>
    Koska haettavien alkioiden määrä puolittuu binäärihaussa jokaisen tarkastelun yhteydessä, voi binäärihaun tehokkuutta tarkastella kaksikantaisen logaritmin avulla. Kaksikantainen logaritmi (<code>log<sub>2</sub></code>) annetusta luvusta kertoo kuinka monta kertaa luku voidaan puolittaa. Esimerkiksi kaksikantainen logaritmi luvusta 16777216 (<code>log<sub>2</sub> 16777216</code>) on 24, ja luvun 4294967296 kaksikantainen logaritmi, (<code>log<sub>2</sub> 4294967296</code>) on 32. Tämä tarkoittaa että 4294967296 eri arvoa sisältävästä järjestyksessä olevasta listasta hakeminen vaatisi binäärihaulta korkeintaan 32 eri alkion tarkastamista.
  </p>

<% end %>


<p>
  Collections-luokkakirjasto tarjoaa valmiiksi toteutetun binäärihakualgoritmin. Kerholainen-luokkamme vertaa pituuksia <code>compareTo()</code>-metodissaan, eli listasta etsiessä etsisimme samanpituista kerholaista.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
  kerholaiset.add(new Kerholainen("mikael", 182));
  kerholaiset.add(new Kerholainen("matti", 187));
  kerholaiset.add(new Kerholainen("joel", 184));

  Collections.sort(kerholaiset);

  Kerholainen haettava = new Kerholainen("Nimi", 180);
  int indeksi = Collections.binarySearch(kerholaiset, haettava);

  if (indeksi &gt;= 0) {
  System.out.println("180 senttiä pitkä löytyi indeksistä " + indeksi);
  System.out.println("nimi: " + kerholaiset.get(indeksi).getNimi());
  }

  haettava = new Kerholainen("Nimi", 187);
  int indeksi = Collections.binarySearch(kerholaiset, haettava);

  if (indeksi &gt;= 0) {
  System.out.println("187 senttiä pitkä löytyi indeksistä " + indeksi);
  System.out.println("nimi: " + kerholaiset.get(indeksi).getNimi());
  }
<% end %>

<% partial 'partials/sample_output' do %>
  187 senttiä pitkä löytyi indeksistä 2
  nimi: matti
<% end %>

<p>
  Esimerkissä kutsuttiin myös metodia <code>Collections.sort()</code> sillä binäärihakualgoritmi ei toimi jos käsiteltävä lista ei ole valmiiksi järjestyksessä. Huom! Älä kuitenkaan toteuta hakutoiminnallisuutta siten, että lista järjestetään jokaisen haun yhteydessä -- järjestäminen itsessään on hitaampaa kuin peräkkäishaku eli listan läpikäynti alkio kerrallaan. Binäärihaun hyödyt tulevatkin esille vasta useamman haun jälkeen.
</p>



<% partial 'partials/material_heading' do %>
  Muutamia yleishyödyllisiä tekniikoita
<% end %>


<p>
  Tutustutaan seuraavaksi muutamaan ohjelmoinnissa varsin näppärään tekniikaan sekä luokkaan.
</p>


<% partial 'partials/material_sub_heading' do %>
  Säännölliset lausekkeet
<% end %>

<p>
  Säännöllinen lauseke määrittelee joukon merkkijonoja tiiviissä muodossa. Säännöllisiä lausekkeita käytetään muunmuassa merkkijonojen oikeellisuuden tarkistamiseen. Merkkijonojen oikeellisuuden tarkastaminen tapahtuu luomalla säännöllinen lauseke, joka määrittelee merkkijonot, jotka ovat oikein.
</p>

<p>
  Tarkastellaan ongelmaa, jossa täytyy tarkistaa, onko käyttäjän antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa merkkijonolla "01", jota seuraa 7 numeroa väliltä 0&ndash;9.
</p>

<p>
  Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi käymällä opiskelijanumeroa esittävän merkkijonon läpi merkki merkiltä <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa että ensimmäinen merkki on "0", ja käyttää <code>Integer.parseInt</code> metodikutsua merkkijonon muuntamiseen numeroksi. Tämän jälkeen voisi tarkistaa että <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.
</p>

<p>
  Oikeellisuuden tarkistus säännöllisten lausekkeiden avulla tapahtuu ensin sopivan säännöllisen lausekkeen määrittelyn. Tämän jälkeen käytetään <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako merkkijono parametrina annettua säännöllistä lauseketta. Opiskelijanumeron tapauksessa sopiva säännöllinen lauseke on <code>"01[0-9]{7}"</code>, ja käyttäjän syöttämän opiskelijanumeron tarkistaminen käy seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.print("Anna opiskelijanumero: ");
  String numero = lukija.nextLine();

  if (numero.matches("01[0-9]{7}")) {
  System.out.println("Muoto on oikea.");
  } else {
  System.out.println("Muoto ei ole oikea.");
  }
<% end %>

<p>
  Käydään seuraavaksi läpi eniten käytettyjä säännöllisten lausekkeiden merkintöjä.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Vaihtoehtoisuus (pystyviiva)
<% end %>

<p>
  Pystyviiva tarkoittaa, että säännöllisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> määrittelee merkkijonot <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos merkkijono vastaa jotain määritellyistä vaihtoehdoista.
</p>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "00";

  if (merkkijono.matches("00|111|0000")) {
  System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
  } else {
  System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
  }
<% end %>


<% partial 'partials/sample_output' do %>
  Merkkijonosta löytyi joku kolmesta vaihtoehdosta
<% end %>

<p>
  Säännöllinen lauseke <code>00|111|0000</code> vaatii että merkkijono on täsmälleen määritellyn muotoinen: se ei määrittele <em>"contains"</em>-toiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "1111";

  if (merkkijono.matches("00|111|0000")) {
  System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
  } else {
  System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Merkkijonon osaan rajattu vaikutus (sulut)
<% end %>

<p>
  Sulkujen avulla voi määrittää, mihin säännöllisen lausekkeen osaan sulkujen sisällä olevat merkinnät vaikuttavat. Jos haluamme sallia merkkijonot <code>00000</code> ja <code>00001</code>, voimme määritellä ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan merkkijonoa. Lauseke <code>0000(0|1)</code> määrittelee merkkijonot <code>00000</code> ja <code>00001</code>.
</p>

<p>
  Vastaavasti säännöllinen lauseke <code>auto(|n|a)</code> määrittelee sanan auto yksikön nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).
</p>

<% partial 'partials/code_highlight' do %>
  System.out.print("Kirjoita joku sanan auto yksikön taivutusmuoto: ");
  String sana = lukija.nextLine();

  if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
  System.out.println("Oikein meni! RRrakastan tätä kieltä!");
  } else {
  System.out.println("Taivutusmuoto ei ole oikea.");
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Toistomerkinnät
<% end %>

<p>
  Usein halutaan, että merkkijonossa toistuu jokin tietty alimerkkijono. Säännöllisissä lausekkeissa on käytössä seuraavat toistomerkinnät:
</p>

<ul>
  <li>Merkintä <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "trolololololo";

      if (merkkijono.matches("trolo(lo)*")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "trolololololo";

      if (merkkijono.matches("tro(lo)+")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>

    <% partial 'partials/code_highlight' do %>
      String merkkijono = "nänänänänänänänä Bätmään!";

      if (merkkijono.matches("(nä)+ Bätmään!")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>

    <% partial 'partials/code_highlight' do %>
      String merkkijono = "You have to accidentally the whole meme";

      if (merkkijono.matches("You have to accidentally (delete )?the whole meme")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "1010";

      if (merkkijono.matches("(10){2}")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "1";

      if (merkkijono.matches("1{2,4}")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto ei ole oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "11111";

      if (merkkijono.matches("1{2,}")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>
</ul>

<p>
  Samassa säännöllisessä lausekkeessa voi käyttää myös useampia toistomerkintöjä. Esimerkiksi säännöllinen lauseke <code>5{3}(1|0)*5{3}</code> määrittelee merkkijonot, jotka alkavat ja loppuvat kolmella vitosella. Välissä saa tulla rajaton määrä ykkösiä ja nollia.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Merkkiryhmät (hakasulut)
<% end %>

<p>
  Merkkiryhmän avulla voi määritellä lyhyesti joukon merkkejä. Merkit kirjoitetaan hakasulkujen sisään, ja merkkivälin voi määrittää viivan avulla. Esimerkiksi merkintä <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintä <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintä <code>[a-c]*</code> määrittelee säännöllisen lausekkeen, joka vaatii että merkkijono sisältää vain merkkejä <code>a</code>, <code>b</code> ja <code>c</code>.
</p>


<%= partial 'partials/quiz', locals: { id: '5a02e242fb43ca000414c18f' } %>


<% partial 'partials/exercise', locals: { name: 'Säännölliset lausekkeet (3 osaa)' } do %>

  <p>
    Harjoitellaan hieman säännöllisten lausekkeiden käyttöä. Tehtävissä haetut metodit tehdään luokkaan <code>Tarkistin</code>.
  </p>


  <h2>Viikonpäivä</h2>

  <p>
    Tee säännöllisen lausekkeen avulla metodi <code>public boolean onViikonpaiva(String merkkijono)</code>, joka palauttaa <code>true</code> jos sen parametrina saama merkkijono on viikonpäivän lyhenne (ma, ti, ke, to, pe, la tai su).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">ti</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">abc</font>
    Muoto ei ole oikea.
  <% end %>


  <h2>Vokaalitarkistus</h2>

  <p>
    Tee metodi <code>public boolean kaikkiVokaaleja(String merkkijono)</code> joka tarkistaa säännöllisen lausekkeen avulla ovatko parametrina olevan merkkijonon kaikki merkit vokaaleja.
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">aie</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">ane</font>
    Muoto ei ole oikea.
  <% end %>


  <h2>Kellonaika</h2>

  <p>
    Säännölliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja merkkijonon "sopivuus" kannattaa tarkastaa muulla tyylillä tai voi olla tarkoituksenmukaista käyttää säännöllisiä lausekkeita vain osaan tarkastuksesta.
  </p>

  <p>
    Tee  metodi <code>public boolean kellonaika(String merkkijono)</code>  ohjelma, joka tarkistaa säännöllisen lausekkeen avulla onko parametrina oleva merkkijono muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">17:23:05</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">abc</font>
    Muoto ei ole oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">33:33:33</font>
    Muoto ei ole oikea.
  <% end %>

<% end %>

<p>
  Nykyään lähes kaikista ohjelmointikielistä löytyy tuki säännöllisille lausekkeille. Säännöllisten lausekkeiden teoriaa tarkastellaan muunmuassa kurssilla <em>Laskennan mallit</em>. Lisää säännöllisistä lausekkeista löydät esim. googlaamalla hakusanalla <em>regular expressions java</em> -- kannattaa myös lukea Codinghorror-blogin lyhyt artikkeli <a href="https://blog.codinghorror.com/regex-use-vs-regex-abuse/" target="_blank" rel="noopener">Regex use vs. Regex abuse</a>.
</p>


<% partial 'partials/material_sub_heading' do %>
  Lueteltu tyyppi eli Enum
<% end %>

<p>
  Jos tiedämme muuttujien mahdolliset arvot ennalta, voimme käyttää niiden esittämiseen <code>enum</code>-tyyppistä luokkaa eli <em>lueteltua tyyppiä</em>. Luetellut tyypit ovat oma luokkatyyppinsä rajapinnan ja normaalin luokan lisäksi. Lueteltu tyyppi määritellään avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka määrittelee neljä vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public enum Maa {
  RUUTU, PATA, RISTI, HERTTA
  }
<% end %>

<p>
  Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina määrittelemänsä vakioarvot. Lueteltujen tyyppien arvot eli vakiot on yleensä tapana kirjoittaa kokonaan isoin kirjaimin.
</p>

<p>
  Enum luodaan (yleensä) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>.
</p>

<p>
  Seuraavassa luokka <code>Kortti</code> jossa maa esitetään enumin avulla:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kortti {

  private int arvo;
  private Maa maa;

  public Kortti(int arvo, Maa maa) {
  this.arvo = arvo;
  this.maa = maa;
  }

  @Override
  public String toString() {
  return maa + " " + arvo;
  }

  public Maa getMaa() {
  return maa;
  }

  public int getArvo() {
  return arvo;
  }
  }
<% end %>

<p>
  Korttia käytetään seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  Kortti eka = new Kortti(10, Maa.HERTTA);

  System.out.println(eka);

  if (eka.getMaa() == Maa.PATA) {
  System.out.println("on pata");
  } else {
  System.out.println("ei ole pata");
  }
<% end %>

<p>Tulostuu:</p>

<% partial 'partials/sample_output' do %>
  HERTTA 10
  ei ole pata
<% end %>

<p>
  Huomaamme, että enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiä <code>Maa</code> ei ylemmän esimerkin "järjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvä sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.
</p>



<% partial 'partials/hint', locals: { name: 'Enumien vertailu' } do %>

  <p>
    Ylläolevassa esimerkissä kahta enumia verrattiin yhtäsuuruusmerkkien avulla. Miksi tämä on ok?
  </p>

  <p>
    Jokainen lueteltu arvo saa oman uniikin numerotunnuksen, ja niiden vertailu keskenään yhtäsuuruusmerkillä on ok. Kuten muutkin Javan luokat, myös luetellut arvot perivät Object-luokan ja sen equals-metodin. Luetelluilla luokilla myös equals-metodi vertailee tätä numerotunnusta.
  </p>

  <p>
    Luetellun arvon numeraalisen tunnuksen saa selville metodille <code>ordinal()</code>. Metodi palauttaa käytännössä järjestysnumeron -- jos lueteltu arvo on esitelty ensimmäisenä, on sen järjestysnumero 0. Jos toisena, järjestysnumero on 1, jne.
  </p>

  
  <% partial 'partials/code_highlight' do %>
    public enum Maa {
    RUUTU, PATA, RISTI, HERTTA
    }
  <% end %>

  <% partial 'partials/code_highlight' do %>
    System.out.println(Maa.RUUTU.ordinal());
    System.out.println(Maa.HERTTA.ordinal());
  <% end %>

  <% partial 'partials/sample_output' do %>
    0
    3
  <% end %>
  
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Lueteltujen tyyppien oliomuuttujat
<% end %>

<p>
  Luetellut tyypit voivat sisältää oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin määrittelevän luokan sisäisessä eli näkyvyysmääreen <code>private</code> omaavassa konstruktorissa. Enum-tyyppisillä luokilla ei saa olla <code>public</code>-konstruktoria.
</p>

<p>
  Seuraavassa lueteltu tyyppi <code>Vari</code>, joka sisältää vakioarvot PUNAINEN, VIHREA ja SININEN. Vakioille on määritelty <a href="https://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">värikoodin</a> kertova oliomuuttuja:
</p>

<% partial 'partials/code_highlight' do %>
  public enum Vari {
  // konstruktorin parametrit määritellään vakioarvoja lueteltaessa
  PUNAINEN("#FF0000"),
  VIHREA("#00FF00"),
  SININEN("#0000FF");

  private String koodi;        // oliomuuttuja

  private Vari(String koodi) { // konstruktori
  this.koodi = koodi;
  }

  public String getKoodi() {
  return this.koodi;
  }
  }
<% end %>

<p>
  Lueteltua tyyppiä <code>Vari</code> voidaan käyttää esimerkiksi seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.println(Vari.VIHREA.getKoodi());
<% end %>

<% partial 'partials/sample_output' do %>
  #00FF00
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Iteraattori
<% end %>

<p>
  Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssä korttipelissä pelaajan kädessä olevien korttien joukkoa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
  private List&lt;Kortti&gt; kortit;

  public Kasi() {
  this.kortit = new ArrayList&lt;&gt;();
  }

  public void lisaa(Kortti kortti) {
  this.kortit.add(kortti);
  }

  public void tulosta() {
  this.kortit.stream().forEach(kortti -&gt; {
  System.out.println(kortti);
  });
  }
  }
<% end %>

<p>
  Luokan metodi <code>tulosta</code> tulostaa jokaisen kädessä olevan kortin.
</p>

<p>
  ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosäiliöt" toteuttavat rajapinnan <em>Iterable</em>, ja ne voidaan käydä läpi myös käyttäen <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman läpikäyntiin. Seuraavassa on iteraattoria käyttävä versio korttien tulostamisesta:
</p>

<% partial 'partials/code_highlight' do %>
  public void tulosta() {
  Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

  while (iteraattori.hasNext()) {
  System.out.println(iteraattori.next());
  }
  }
<% end %>

<p>
  Iteraattori pyydetään kortteja sisältävältä listalta <code>kortit</code>. Iteraattori on ikäänkuin "sormi", joka osoittaa aina tiettyä listan sisällä olevaa olioa, ensin ensimmäistä ja sitten seuraavaa jne... kunnes "sormen" avulla on käyty jokainen olio läpi.
</p>

<p>
  Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytään onko läpikäytäviä olioita vielä jäljellä. Jos on, voidaan iteraattorilta pyytää seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana läpikäyntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa läpikäytävää olioa.
</p>

<p>
  Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myös muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  public void tulosta(){
  Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

  while (iteraattori.hasNext()) {
  Kortti seuraavanaVuorossa = iteraattori.next();
  System.out.println(seuraavanaVuorossa);
  }
  }
<% end %>


<p>
  Tarkastellaan seuraavaksi yhtä iteraattorin käyttökohdetta. Motivoidaan käyttökohde ensin ongelmallisella lähestymistavalla. Yritämme tehdä virran avulla metodia, joka poistaa käsiteltävästä virrasta ne kortit, joiden arvo on annettua arvoa pienempi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
  // ...

  public void poistaHuonommat(int arvo) {
  this.kortit.stream().forEach(kortti -&gt; {
  if (kortti.getArvo() &lt; arvo) {
  kortit.remove(kortti);
  }
  });
  }
  }
<% end %>

<p>
  Metodin suoritus aiheuttaa ongelman.
</p>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" java.util.ConcurrentModificationException
  at ...
  Java Result: 1
<% end %>

<p>
  Virheen syynä on se, että listan läpikäynti forEach-metodilla olettaa, ettei listaa muokata läpikäynnin yhteydessä. Listan muokkaaminen (eli tässä tapauksessa alkion poistaminen) aiheuttaa virheen -- voimme ajatella, että komento forEach menee tästä "sekaisin".
</p>

<p>
  Jos listalta halutaan poistaa osa olioista läpikäynnin aikana osa, tulee tämä tehdä iteraattoria käyttäen. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellä metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
  // ...

  public void poistaHuonommat(int arvo) {
  Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

  while (iteraattori.hasNext()) {
  if (iteraattori.next().getArvo() &lt; arvo) {
  // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
  iteraattori.remove();
  }
  }
  }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Enum ja Iteraattori (4 osaa)' } do %>

  <p>
    Tehdään ohjelma pienen yrityksen henkilöstön hallintaan.
  </p>

  <h2>Koulutus</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).
  </p>

  <h2>Henkilo</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Henkilo</code>. Henkilölle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkilöllä on myös koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekä alla olevan esimerkin mukaista jälkeä tekevä <code>toString</code>-metodi.
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo vilma = new Henkilo("Vilma", Koulutus.FT);
    System.out.println(vilma);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Vilma, FT
  <% end %>


  <h2>Tyontekijat</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. Työntekijät-olio sisältää listan Henkilo-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Henkilo lisattava)</code> lisää parametrina olevan henkilön työntekijäksi</li>
    <li><code>public void lisaa(List&lt;Henkilo&gt; lisattavat)</code> lisää parametrina olevan listan henkilöitä työntekijöiksi</li>
    <li><code>public void tulosta()</code> tulostaa kaikki työntekijät</li>
    <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa työntekijät joiden koulutus on sama kuin parametrissa määritelty koulutus</li>
  </ul>

  <p>
    <strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria käyttäen!
  </p>

  
  <h2>Irtisanominen</h2>

  <p>
    Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa Työntekijöiden joukosta kaikki henkilöt joiden koulutus on sama kuin metodin parametrina annettu.
  </p>

  <p>
    <strong>HUOM:</strong> toteuta metodi iteraattoria käyttäen!
  </p>

  <p>
    Seuraavassa esimerkki luokan käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Tyontekijat yliopisto = new Tyontekijat();
    yliopisto.lisaa(new Henkilo("Petrus", Koulutus.FT));
    yliopisto.lisaa(new Henkilo("Arto", Koulutus.FilYO));
    yliopisto.lisaa(new Henkilo("Elina", Koulutus.FT));

    yliopisto.tulosta();

    yliopisto.irtisano(Koulutus.FilYO);

    System.out.println("==");

    yliopisto.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    Petrus, FT
    Arto, FilYO
    Elina, FT
    ==
    Petrus, FT
    Elina, FT
  <% end %>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Kortit ojennukseen (6 osaa)' } do %>

  <p>
    Tehtäväpohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on esitetään numerona <em>2, 3, ..., 14</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Ässä on siis arvo 14. Arvo esitetään kokonaislukuna ja maa enum-tyyppisenä oliona. Kortilla on myös metodi toString, jota käyttäen kortin arvo ja maa tulostuvat "ihmisystävällisesti".
  </p>

  <p>
    Korttien luominen tapahtuu seuraavasti. 
  </p>

  <% partial 'partials/code_highlight' do %>
    Kortti eka = new Kortti(2, Maa.RUUTU);
    Kortti toka = new Kortti(14, Maa.PATA);
    Kortti kolmas = new Kortti(12, Maa.HERTTA);

    System.out.println(eka);
    System.out.println(toka);
    System.out.println(kolmas);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA A
    HERTTA Q
  <% end %>

  
  <h2>Kortti-luokasta Comparable</h2>

  <p>
    Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, että korttien järjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitä maan perusteella nousevassa järjestyksessä: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em>
  </p>

  <p>
    Maiden järjestämisessä apua löytynee <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html#ordinal--"  target="_blank" norel>Enum-luokan ordinal-metodista</a>.
  </p>

  <p>
    Järjestyksessä pienin kortti siis olisi risti kakkonen ja suurin pataässä.
  </p>

  
  <h2>Käsi</h2>

  <p>
    Tee seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kädessään pitämää korttien joukkoa. Tee kädelle seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Kortti kortti)</code> lisää käteen kortin</li>
    <li><code>public void tulosta()</code> tulostaa kädessä olevat kortit alla olevan esimerkin tyylillä</li>
  </ul>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA A
    HERTTA Q
    PATA 2
  <% end %>

  <p>
    Käytä ArrayListiä korttien tallentamiseen.
  </p>


  <h2>Käden järjestäminen</h2>

  <p>
    Tee kädelle metodi <code>public void jarjesta()</code> jota kutsumalla käden sisällä olevat kortit menevät suuruusjärjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.jarjesta();

    kasi.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA 2
    HERTTA Q
    PATA A
  <% end %>

  
  <h2>Käsien vertailu</h2>

  <p>
    Eräässä korttipelissä kahdesta korttikädestä arvokkaampi on se, jonka sisältämien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tämän kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.
  </p>

  <p>
    Esimerkkiohjelma, jossa vertaillaan käsiä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi1 = new Kasi();

    kasi1.lisaa(new Kortti(2, Maa.RUUTU));
    kasi1.lisaa(new Kortti(14, Maa.PATA));
    kasi1.lisaa(new Kortti(12, Maa.HERTTA));
    kasi1.lisaa(new Kortti(2, Maa.PATA));

    Kasi kasi2 = new Kasi();

    kasi2.lisaa(new Kortti(11, Maa.RUUTU));
    kasi2.lisaa(new Kortti(11, Maa.PATA));
    kasi2.lisaa(new Kortti(11, Maa.HERTTA));

    int vertailu = kasi1.compareTo(kasi2);

    if (vertailu &lt; 0) {
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi2.tulosta();
    } else if (vertailu &gt; 0){
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi1.tulosta();
    } else {
    System.out.println("kädet yhtä arvokkaat");
    }
  <% end %>

  <p>Tulostuu</p>

  <% partial 'partials/sample_output' do %>
    arvokkaampi käsi sisältää kortit
    RUUTU J
    PATA J
    HERTTA J
  <% end %>

  
  <h2>Korttien järjestäminen eri kriteerein</h2>

  <p>
    Entä jos haluaisimme välillä järjestää kortit hieman eri tavalla, esim. kaikki saman maan kortit peräkkäin? Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.
  </p>

  <p>
    Vaihtoehtoiset järjestämistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on järjestyksessä ennen korttia k2, positiivinen arvo jos k2 on järjestyksessä ennen k1:stä ja 0 muuten.
  </p>

  <p>
    Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkäin vievän järjestyksen määrittelevä luokka:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.Comparator;

    public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
    public int compare(Kortti k1, Kortti k2) {
    return k1.getMaa().ordinal() - k2.getMaa().ordinal();
    }
    }
  <% end %>

  <p>
    Maittainen järjestys on sama kuin kortin metodin <code>compareTo</code> maille määrittelemä järjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em>
  </p>

  <p>
    Järjestäminen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:
  </p>
  
  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;&gt;();

    kortit.add(new Kortti(3, Maa.PATA));
    kortit.add(new Kortti(2, Maa.RUUTU));
    kortit.add(new Kortti(14, Maa.PATA));
    kortit.add(new Kortti(12, Maa.HERTTA));
    kortit.add(new Kortti(2, Maa.PATA));

    SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
    Collections.sort(kortit, samatMaatVierekkainJarjestaja);

    kortit.stream().forEach(k -&gt; System.out.println(k));
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    HERTTA Q
    PATA 3
    PATA A
    PATA 2
  <% end %>

  <p>
    Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:
  </p>
  
  <% partial 'partials/code_highlight' do %>
    Collections.sort(kortit, new SamatMaatVierekkain());
  <% end %>


  <p>
    Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/data/collections/comparators.html">täällä</a>
  </p>

  <p>
    Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code> jonka avulla saat kortit muuten samanlaiseen järjestykseen kuin edellisessä esimerkissä paitsi, että saman maan kortit järjestyvät arvon mukaisesti.
  </p>


  <h2>Käden järjestäminen maittain</h2>

  <p>
    Lisää luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla käden sisällä olevat kortit menevät edellisen tehtävän vertailijan määrittelemään järjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(4, Maa.PATA));
    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(7, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.jarjestaMaittain();

    kasi.tulosta();
  <% end %>
  
  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    HERTTA 7
    HERTTA Q
    PATA 2
    PATA 4
    PATA A
  <% end %>


<% end %>



<% partial 'partials/exercise', locals: { name: 'Elokuvien suosittelija (8 osaa)' } do %>

  <p>
    <a href="https://signup.netflix.com/" target="_blank" rel="noopener">Netflix</a> lupasi lokakuussa 2006 miljoona dollaria henkilölle tai ryhmälle, joka kehittäisi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heidän oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank" rel="noopener">http://www.netflixprize.com/</a>).
  </p>

  <p>
    Rakennetaan tässä tehtävässä ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");
    Henkilo thomas = new Henkilo("Thomas");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);


    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Thomas suositus: Hiljaiset sillat
    Mikke suositus: Tuulen viemää
  <% end %>

  <p>
    Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sekä henkilökohtaisten henkilön antaminen arvioiden perusteella. Lähdetään rakentamaan ohjelmaa.
  </p>


  <h2>Henkilo ja Elokuva</h2>

  <p>
    Luo pakkaus <code>suosittelija.domain</code> ja lisää sinne luokat <code>Henkilo</code> ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String nimi)</code>, sekä metodi <code>public String getNimi()</code>, joka palauttaa konstruktorissa saadun nimen.
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo henkilo = new Henkilo("Pekka");
    Elokuva elokuva = new Elokuva("Eraserhead");

    System.out.println(henkilo.getNimi() + " ja " + elokuva.getNimi());
  <% end %>

  <% partial 'partials/sample_output' do %>
    Pekka ja Eraserhead
  <% end %>

  <p>
    Lisää luokille myös <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sekä korvaa metodit <code>equals</code> ja <code>hashCode</code>.
  </p>

  <p>
    Korvaa <code>equals</code> siten että samuusvertailu tapahtuu oliomuuttujan <code>nimi</code> perusteella. Metodi hashCode kannattaa generoida automaattisesti seuraavan ohjeen mukaan:
  </p>

  <p>
    <em>
      NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta equals() and hashCode(). Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.
    </em>
  </p>


  <h2>Arvio</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.domain</code> lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code> on julkinen metodi <code>public int getArvo()</code>, joka palauttaa arvioon liittyvän arvon. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:
  </p>

  <table class="table">
    <tr><th>Tunnus</th><th>Arvo</th></tr>
    <tr><td>HUONO</td><td>-5</td></tr>
    <tr><td>VALTTAVA</td><td>-3</td></tr>
    <tr><td>EI_NAHNYT</td><td>0</td></tr>
    <tr><td>NEUTRAALI</td><td>1</td></tr>
    <tr><td>OK</td><td>3</td></tr>
    <tr><td>HYVA</td><td>5</td></tr>
  </table>

  <p>
    Luokkaa voi käyttää seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    Arvio annettu = Arvio.HYVA;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
    annettu = Arvio.NEUTRAALI;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
  <% end %>

  <% partial 'partials/sample_output' do %>
    Arvio HYVA, arvo 5
    Arvio NEUTRAALI, arvo 1
  <% end %>


  <h2>ArvioRekisteri, osa 1</h2>

  <p>
    Aloitetaan arvioiden varastointiin liittyvän palvelun toteutus.
  </p>

  <p>
    Luo pakkaukseen <code>suosittelija</code> luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code> sekä seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code> lisää arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
    <li><code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code> palauttaa elokuvalle lisätyt arviot listana.</li>
    <li><code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code> palauttaa mapin, joka sisältää arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sisältää elokuvaan lisatyt arviot.</li>
  </ul>

  <p>
    Testaa metodien toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    ArvioRekisteri rekisteri = new ArvioRekisteri();
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

    System.out.println("Kaikki arviot: " + rekisteri.elokuvienArviot());
    System.out.println("Arviot Eraserheadille: " + rekisteri.annaArviot(eraserhead));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
    Arviot Eraserheadille: [HUONO, HUONO, HYVA]
  <% end %>


  <h2>ArvioRekisteri, osa 2</h2>

  <p>
    Lisätään seuraavaksi mahdollisuus henkilökohtaisten arvioiden lisäämiseen.
  </p>

  <p>
    Lisää luokkaan <code>ArvioRekisteri</code> seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaaArvio(Henkilo henkilo, Elokuva elokuva, Arvio arvio)</code> lisää parametrina annetulle elokuvalle tietyn henkilön tekemän arvion. Sama henkilö voi arvioida tietyn elokuvan vain kertaalleen. Henkilön tekemä arvio tulee myös lisätä kaikkiin elokuviin liittyviin arvioihin.</li>
    <li><code>public Arvio haeArvio(Henkilo henkilo, Elokuva elokuva)</code> palauttaa parametrina annetun henkilön tekemän arvion parametrina annetulle elokuvalle. Jos henkilö ei ole arvioinut kyseistä elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
    <li><code>public Map&lt;Elokuva, Arvio&gt; annaHenkilonArviot(Henkilo henkilo)</code> palauttaa hajautustaulun, joka sisältää henkilön tekemät arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyvät arviot. Jos henkilö ei ole arvioinut yhtään elokuvaa, palautetaan tyhjä hajautustaulu.</li>
    <li><code>public List&lt;Henkilo&gt; arvioijat()</code> palauttaa listan henkilöistä jotka ovat arvioineet elokuvia.</li></ul>

  <p>
    Henkilöiden tekemät arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkilö. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.
  </p>

  <p>
    Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla lähdekoodipätkällä:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

    System.out.println("Arviot Eraserheadille: " + arviot.annaArviot(eraserhead));
    System.out.println("Matin arviot: " + arviot.annaHenkilonArviot(matti));
    System.out.println("Arvioijat: " + arviot.arvioijat());
  <% end %>

  <% partial 'partials/sample_output' do %>
    Arviot Eraserheadille: [OK, OK]
    Matin arviot: {Tuulen viemää=HUONO, Eraserhead=OK}
    Arvioijat: [Pekka, Matti]
  <% end %>

  <p>
    Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.
  </p>


  <h2>HenkiloComparator</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>HenkiloComparator</code>. Luokan <code>HenkiloComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Henkilo&gt;</code>, ja sillä pitää olla konstruktori <code>public HenkiloComparator(Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>HenkiloComparator</code> käytetään myöhemmin henkilöiden järjestämiseen henkilöön liittyvän luvun perusteella.
  </p>

  <p>
    HenkiloComparator-luokan tulee mahdollistaa henkilöiden järjestäminen henkilöön liittyvän luvun perusteella.
  </p>

  <p>
    Testaa luokan toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");
    Henkilo thomas = new Henkilo("Thomas");

    Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet = new HashMap&lt;&gt;();
    henkiloidenSamuudet.put(matti, 42);
    henkiloidenSamuudet.put(pekka, 134);
    henkiloidenSamuudet.put(mikke, 8);
    henkiloidenSamuudet.put(thomas, 82);

    List&lt;Henkilo&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("Henkilöt ennen järjestämistä: " + henkilot);

    Collections.sort(henkilot, new HenkiloComparator(henkiloidenSamuudet));
    System.out.println("Henkilöt järjestämisen jälkeen: " + henkilot);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Henkilöt ennen järjestämistä: [Matti, Pekka, Mikke, Thomas]
    Henkilöt järjestämisen jälkeen: [Pekka, Thomas, Matti, Mikke]
  <% end %>


  <h2>ElokuvaComparator</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sillä pitää olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code> käytetään myöhemmin elokuvien järjestämiseen niiden arvioiden perusteella.
  </p>

  <p>
    ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien järjestäminen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimmäisenä, matalimman keskiarvon saanut viimeisenä.
  </p>

  <p>
    Testaa luokan toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

    List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
    System.out.println("Elokuvat ennen järjestämistä: " + elokuvat);

    Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
    System.out.println("Elokuvat järjestämisen jälkeen: " + elokuvat);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Elokuvat ennen järjestämistä: [Tuulen viemää, Hiljaiset sillat, Eraserhead]
    Elokuvat järjestämisen jälkeen: [Hiljaiset sillat, Tuulen viemää, Eraserhead]
  <% end %>


  <h2>Suosittelija, osa 1</h2>

  <p>
    Toteuta pakkaukseen <code>suosittelija</code> luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code> konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija käyttää arviorekisterissä olevia arvioita suositusten tekemiseen.
  </p>

  <p>
    Toteuta luokalle metodi <code>public Elokuva suositteleElokuva(Henkilo henkilo)</code>, joka suosittelee henkilölle elokuvia.
  </p>

  <p>
    Toteuta metodi ensin siten, että se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvittämiseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code> metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sekä listaa olemassaolevista elokuvista.
  </p>

  <p>
    Testaa ohjelman toimimista seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikael");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
    System.out.println("Mikaelille suositeltu elokuva oli: " + suositeltu);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Mikaelille suositeltu elokuva oli: Hiljaiset sillat
  <% end %>

  <p>
    Nyt tekemämme ensimmäinen vaihe toimii oikein ainoastaan henkilöille, jotka eivät ole vielä arvostelleet yhtään elokuvaa. Heidän elokuvamaustaanhan on mahdoton sanoa mitään ja paras arvaus on suositella heille keskimäärin parhaan arvosanan saanutta elokuvaa.
  </p>


  <h2>Suosittelija, osa 2</h2>

  <p>
    <em>
      Huom! Tehtävä on haastava. Kannattaa tehdä ensin muut tehtävät ja palata tähän myöhemmin. Voit palauttaa tehtäväsarjan TMC:hen vaikket saakaan tätä tehtävää tehdyksi, aivan kuten lähes kaikkien muidenkin tehtävien kohdalla.
    </em>
  </p>

  <p>
    Valitettavasti tämän osan virhediagnostiikkakaan ei ole samaa luokkaa kuin edellisissä kohdissa.
  </p>

  <p>
    Jos henkilöt ovat lisänneet omia suosituksia suosituspalveluun, tiedämme jotain heidän elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, että se luo henkilökohtaisen suosituksen jos henkilö on jo arvioinut elokuvia. Edellisessä osassa toteutettu toiminnallisuus tulee säilyttää: Jos henkilö ei ole arvioinut yhtäkään elokuvaa, hänelle suositellaan elokuva arvosanojen perusteella.
  </p>

  <p>
    Henkilökohtaiset suositukset perustuvat henkilön tekemien arvioiden samuuteen muiden henkilöiden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, missä ylärivillä on elokuvat, ja vasemmalla on arvioita tehneet henkilöt. Taulukon solut kuvaavat annettuja arvioita.
  </p>

  <table class="table">
    <tr><th>Henkilo \ Elokuva</th><td>Tuulen viemää</td><td>Hiljaiset sillat</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
    <tr><td>Matti</td><td>HUONO (-5)</td><td>HYVA (5)</td><td>OK (3)</td><td>-</td></tr>
    <tr><td>Pekka</td><td>OK (3)</td><td>-</td><td>HUONO (-5)</td><td>VALTTAVA (-3)</td></tr>
    <tr><td>Mikael</td><td>-</td><td>-</td><td>HUONO (-5)</td><td>-</td></tr>
    <tr><td>Thomas</td><td>-</td><td>HYVA (5)</td><td>-</td><td>HYVA (5)</td></tr>
  </table>

  <p>
    Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eivät ole katsoneet yhtäkään samaa elokuvaa.
  </p>

  <p>
    Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).
  </p>

  <% partial 'partials/sample_output' do %>
    -5 * -5 = 25
  <% end %>

  <p>
    Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat myös katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).
  </p>

  <% partial 'partials/sample_output' do %>
    -5 * 3 = -15
  <% end %>

  <p>
    Näiden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viemää.
  </p>

  <p>
    Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteistä elokuvaa. Matti antoi Tuulen viemälle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.
  </p>

  <% partial 'partials/sample_output' do %>
    -5 * 3 + 3 * -5 = -30
  <% end %>

  <p>
    Matin ja Mikaelin samuus on edellisestä laskusta tiedetty -15. Samuudet ovat symmetrisia.
  </p>

  <p>
    Matti ja Thomas ovat katsoneet Tuulen viemää, ja kumpikin antoi sille arvosanan hyvä (5). Matin ja Thomaksen samuus on siis 25.
  </p>

  <% partial 'partials/sample_output' do %>
    5 * 5 = 25
  <% end %>

  <p>
    Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.
  </p>

  <p>
    Toteuta yllä kuvattu suosittelumekanismi. Jos henkilölle ei löydy yhtään suositeltavaa elokuvaa, tai henkilö, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkilö ei ole vielä katsonut huonoiksi, välttäviksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code> arvo <code>null</code>. Edellisessä tehtävässä määritellyn lähestymistavan tulee toimia jos henkilö ei ole lisännyt yhtäkään arviota.
  </p>

  <p>
    Älä suosittele elokuvia, jotka henkilö on jo nähnyt.
  </p>

  <p>
    Voit testata ohjelmasi toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");
    Elokuva bluesBrothers = new Elokuva("Blues Brothers");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikael");
    Henkilo thomas = new Henkilo("Thomas");
    Henkilo arto = new Henkilo("Arto");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
    arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
    arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
    System.out.println(matti + " suositus: " + suosittelija.suositteleElokuva(matti));
    System.out.println(arto + " suositus: " + suosittelija.suositteleElokuva(arto));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Thomas suositus: Eraserhead
    Mikael suositus: Tuulen viemää
    Matti suositus: Blues Brothers
    Arto suositus: Hiljaiset sillat
  <% end %>

  <p>
    Miljoona käsissä? Ei ehkä vielä. Tietojenkäsittelytieteen tekoäly- ja koneoppimiskursseilla opitaan lisää tekniikoita oppivien järjestelmien rakentamiseen.
  </p>

<% end %>




<% partial 'partials/material_heading' do %>
  Graafiset käyttöliittymät
<% end %>

<p>
  Tutustutaan seuraavaksi graafisten käyttöliittymien luomiseen. Graafiset käyttöliittymät poikkeavat aiemmin toteuttamistamme tekstikäyttöliittymistä usealla tavalla. Graafisia käyttöliittymiä luodessa hyödynnämme ensisijaisesti käyttöliittymäkirjastoja, jotka tarjoavat valmiita käyttöliittymäkomponentteja kuten tekstikenttäelementtejä ja nappeja.
</p>

<p>
  Käyttäjän syötteiden käsittely poikkeaa myös tekstikäyttöliittymistä. Siinä missä tekstikäyttöliittymissä toiminnallisuus kytketään tietyn muotoiseen syötteeseen, graafisissa käyttöliittymissä toiminnallisuus lisätään käyttöliittymäkomponentteihin. Ohjelmoija esimerkiksi lisää käyttöliittymän nappiin metodin, joka käsittelee tapahtuman.
</p>

<p>
  Käytämme graafisten käyttöliittymien luomiseen Javan <a href="https://en.wikipedia.org/wiki/JavaFX" target="_blank" rel="noopener">JavaFX</a> käyttöliittymäkirjastoa.
</p>

<% partial 'partials/hint', locals: { name: 'JavaFx ja Maven' } do %>

  <p>
    Yhdennessätoista osassa käytetään JavaFx-nimistä kirjastoa. Linux-koneilla joudut -- riippuen Javan asennuksesta -- asentamaan myös openjfx-kirjaston. Tämän asentaminen onnistuu Ubuntussa (komentoriviltä) komennolla:
  </p>

  <pre>
  sudo apt-get install openjfx
  </pre>

  <p>
    Tehtäväpohjissa käytetään JavaFx-ohjelmien testaamiseen <a href="https://github.com/TestFX/TestFX/wiki" target="_blank" norel>TestFX</a>-nimistä apukirjastoa. Kun aloitat tehtävien tekemisen, joutunet valitsemaan NetBeansissa tehtäväpohjan kohdalla "Download declared dependencies."
  </p>
  
<% end %>

<p>
  Yksinkertaisen ikkunan luominen onnistuu JavaFX:n avulla seuraavanlaisella ohjelmalla.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus;

import javafx.application.Application;
import javafx.stage.Stage;

public class JavaFxSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
        ikkuna.setTitle("Hei Maailma!");
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(JavaFxSovellus.class);
    }
}
<% end %>



<p>
  Kun ohjelman käynnistää, sovellus näyttää seuraavalta.
</p>

<img src="/img/material/gui-helloworld.png" alt="Tyhjä ikkuna, jonka otsikko on 'Hei Maailma!'"/>

<p>&nbsp;</p>

<% partial 'partials/hint', locals: { name: 'Omien JavaFX-sovellusten laatiminen' } do %>

  <p>
    Voit tehdä omia JavaFx-projekteja NetBeansissa valitsemalla File -&gt; New Project. Valitse tämän jälkeen projektilistauksesta JavaFx ja sieltä JavaFx Application. Tämän jälkeen edessäsi on projektien luomiseen käytetty näkymä, missä voit nimetä projektin.
  </p>

<% end %>

<p>
  Mitä ohjelmassa oikein tapahtuu? Luokkamme JavaFxSovellus perii luokan <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/application/Application.html" target="_blank" rel="noopener">Application</a>, joka tarjoaa rungon graafisten käyttöliittymien luomiseen. Sovellus käynnistetään Application-luokalta perittävällä metodilla <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/application/Application.html#launch-java.lang.Class-java.lang.String...--" target="_blank" rel="noopener">launch</a>, jolle annetaan parametrina käynnistettävän luokan nimi muodossa <em>LuokanNimi.class</em>.
</p>

<p>
  Kun metodia launch kutsutaan, Application-luokassa sijaitseva metodi luo parametrina annetusta luokasta (tässä JavaFxSovellus) uuden olion ja kutsuu sen init-metodia. Metodi init periytyy luokasta Application, ja sitä käytetään esimerkiksi ohjelmassa käytettävien olioiden alustamiseen. Jätimme sen tässä toteuttamatta, sillä ohjelmamme on melko yksinkertainen. Metodin init kutsumisen jälkeen kutsutaan start, jolle annetaan parametrina ikkunaa kuvaava <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/stage/Stage.html" target="_blank" rel="noopener">Stage</a>-olio. Yllä tehdyssä start-metodin toteutuksessa parametrina saadulle stage-oliolle asetetaan otsikko metodilla setTitle, jonka jälkeen kutsutaan ikkunan näyttämiseen johtavaa metodia show. Lopulta ohjelma jää kuuntelemaan käyttöliittymässä tapahtuvia tapahtumia kuten ikkunan sulkemista, joka johtaa sovelluksen sammumiseen.
</p>


<% partial 'partials/exercise', locals: { name: 'Sovellukseni' } do %>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä, jonka otsikkona on "Sovellukseni". Sovelluksen tulee käynnistyä kun main-metodi suoritetaan.
  </p>

  <p>
    Huom! Sekä tässä että tulevassa tehtävässä testit käynnistävät sovelluksen. Käytössä olevissa testeissä on <a href="https://github.com/TestFX/TestFX/issues/245" target="_blank" rel="noopener">huomattu ongelmia</a> Windows-käyttöjärjestelmissä silloin, kun käyttöjärjestelmä skaalaa ruutua (tapahtuu isoilla resoluutioilla). Vaikkei testit toimisi paikallisesti oikein, voit palauttaa tehtävän kuitenkin TMC:lle, joka antaa testeistä tarkoitetun palautteen.
  </p>

<% end %>

<% partial 'partials/material_sub_heading' do %>
  Käyttöliittymän rakenne
<% end %>

<p>
  Graafiset käyttöliittymät koostuvat oleellisesti kolmesta osasta. Stage-olio toimii ohjelman ikkunana. Stage-oliolle asetetaan <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/Scene.html" target="_blank" rel="noopener">Scene</a>-olio, joka kuvastaa ikkunassa olevaa näkymää. Scene-olio taas sisältää näkymään liittyvien komponenttien asettelusta vastaavan olion (esim. FlowPane), joka taas sisältää konkreettiset käyttöliittymäkomponentit.
</p>

<p>
  Alla oleva ohjelma luo käyttöliittymän, jossa on yksittäinen nappi.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.FlowPane;
import javafx.stage.Stage;

public class JavaFxSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
        Button nappi = new Button("Tämä on nappi");

        FlowPane komponenttiryhma = new FlowPane();
        komponenttiryhma.getChildren().add(nappi);

        Scene nakyma = new Scene(komponenttiryhma);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(JavaFxSovellus.class);
    }
}
<% end %>

<p>
  Sovellus näyttää seuraavalta.
</p>

<img src="/img/material/gui-nappi.png" alt="Ikkuna, jossa on nappi. Napissa on teksti 'Tämä on nappi'."/>

<p>
  &nbsp;
</p>

<p>
  Käyttöliittymäkomponentit lisätään niiden asettelusta vastaavan olion -- edellä FlowPane -- "lapsiksi". Tämä liittyy JavaFx:n suunnittelussa tehtyyn päätökseen, missä jokainen käyttöliittymäkomponenttien asetteluun käytettävä olio voi sisältää muita käyttöliittymäkomponenttien asetteluun käytettäviä olioita sekä luonnollisesti myös käyttöliittymäkomponentteja. Tämä mahdollistaa graafiset käyttöliittymät, joissa käyttöliittymäkomponenttien asettelutapa riippuu niiden paikasta käyttöliittymässä. Esimerkiksi käyttöliittymässä ylhäällä olevan valikon vaihtoehdot asetetaan yleensä vierekkäin, kun taas listattavat asiat allekkain.
</p>

<p>
  Käyttöliittymän rakenne on siis lyhyesti seuraava. Ikkuna sisältää Scene-olion. Scene-olio sisältää käyttöliittymäkomponenttien asettelusta vastaavan olion. Käyttöliittymäkomponenttien asettelusta vastaava olio voi sisältää sekä käyttöliitymäkomponentteja, että käyttöliittymäkomponenttien asettelusta vastaavia olioita.
</p>

<!--
  TODO: kuva
</p>

stage
 |
scene
 |
käyttöliittymäkomponenttien asettelusta vastaava olio
 |        |
kälivast kälikomp kälikomp
 |
kälikomp
   -->


<% partial 'partials/material_sub_heading' do %>
  Käyttöliittymäkomponentit
<% end %>

<p>
  Graafisia käyttöliittymiä luodessa ohjelmoijat hyödyntävät tyypillisesti valmiiden käyttöliittymäkirjastojen tarjoamia osia sovellusten laatimiseen. Ohjelmoijan ei esimerkiksi kannata toteuttaa käyttöliittymän nappia tyhjästä (eli luoda luokkaa, joka piirtää napin sekä mahdollistaa siihen liittyvien toiminnallisuuksien käsittelyn), sillä vastaava työ on tehty muiden toimesta hyvin moneen kertaan.  Tutustutaan seuraavaksi muutamaan käyttöliittymäkomponenttiin.
</p>

<p>
  Tekstin näyttäminen tapahtuu <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Label.html" target="_blank" rel="noopener">Label</a></code>-luokan avulla. Label tarjoaa käyttöliittymäkomponentin, jolle voi asettaa tekstiä ja jonka sisältämää tekstiä voi muokata metodien avulla. Teksti asetetaan joko konstruktorissa tai erillisellä <code>setText</code>-metodilla.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.FlowPane;
import javafx.stage.Stage;

public class JavaFxSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
        Label teksti = new Label("Tekstielementti");

        FlowPane komponenttiryhma = new FlowPane();
        komponenttiryhma.getChildren().add(teksti);

        Scene nakyma = new Scene(komponenttiryhma);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(JavaFxSovellus.class);
    }
}
<% end %>

<img src="/img/material/gui-tekstielementti.png" alt="Ikkuna, jossa on tekstielementti. Ikkunassa näkyy teksti 'Tekstielementti'."/>

<p>
  &nbsp;
</p>

<p>
  Käyttöliittymään saa painikkeita <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Button.html" target="_blank" rel="noopener">Button</a>-luokan avulla. Napin lisääminen käyttöliittymään tapahtuu aivan kuten tekstielementin lisääminen.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.FlowPane;
import javafx.stage.Stage;

public class JavaFxSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
        Button nappi = new Button("Tämä on nappi");

        FlowPane komponenttiryhma = new FlowPane();
        komponenttiryhma.getChildren().add(nappi);

        Scene nakyma = new Scene(komponenttiryhma);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(JavaFxSovellus.class);
    }
}
<% end %>

<img src="/img/material/gui-nappi.png" alt="Ikkuna, jossa on nappi. Napissa on teksti 'Tämä on nappi'."/>

<p>&nbsp;</p>

<p>
  Sovellukseen voi lisätä myös useampia käyttöliittymäelementtejä samaan aikaan. Alla käytössä on sekä nappi että tekstielementti.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.FlowPane;
import javafx.stage.Stage;

public class JavaFxSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
        Button nappi = new Button("Tämä on nappi");
        Label teksti = new Label("Tekstielementti");

        FlowPane komponenttiryhma = new FlowPane();
        komponenttiryhma.getChildren().add(nappi);
        komponenttiryhma.getChildren().add(teksti);

        Scene nakyma = new Scene(komponenttiryhma);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(JavaFxSovellus.class);
    }
}
<% end %>

<p>
  Sovellus näyttää seuraavalta.
</p>

<img src="/img/material/gui-nappi-ja-teksti.png" alt="Ikkuna, jossa on nappi sekä tekstielementti. Napissa on teksti 'Tämä on nappi' ja tekstielementti sisältää tekstin 'Tekstielementti'."/>

<p>
  &nbsp;
</p>

<p>
  Osoitteessa <a href="https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/</a> on listattuna joukko valmiita käyttöliittymäkomponentteja. Sivu tarjoa myös esimerkkejä käyttöliittymäkomponenttien käytöstä.
</p>


<p>
  Käyttöliittymäkomponentteja on huomattava määrä. Niiden opiskeluun kannattaa käyttää verkossa olevia valmiita oppaita kuten edellä mainittua osoitetta <a href="https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/</a>. Käyttöliittymäkomponentteja kannattaa kokeilla aluksi erikseen siten, että kokeilee yhden komponentin lisäämistä ja tarkastelee sen toimintaa.
</p>

<p>
  Kun yksittäiset komponentit tulevat tutuksi, on niiden käyttäminen suoraviivaisempaa. Lähes kaikille komponenteille yhteistä on se, miten ne lisätään sovellukseen. Kun osaat lisätä yhden komponentin käyttöliittymään, osaat lisätä käytännössä lähes kaikki komponentit käyttöliittymään.
</p>

<p>
  Ainoa merkittävä ero käyttöliittymäkomponenttien lisäämisessä liittyy siihen, että mihin kohtaan käyttöliittymää komponentin haluaa lisätä. Tarkastellaan seuraavaksi käyttöliittymäkomponenttien asettelua.
</p>

<% partial 'partials/exercise', locals: { name: 'Nappi ja tekstielementti' } do %>

  <p>
    Luo edellistä esimerkkiä seuraten tehtäväpohjassa olevaan luokkaan käyttöliittymä, jossa on nappi (Button) ja tekstielementti (Label). Napin tulee olla tekstielementin vasemmalla puolella tai yläpuolella.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Nappi ja tekstikenttä' } do %>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä, jossa on nappi ja tekstikenttä. Tekstikentän saa toteutettu luokalla <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/TextField.html" target="_blank" rel="noopener">TextField</a>. Napin tulee olla tekstikentän vasemmalla puolella tai yläpuolella.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Käyttöliittymäkomponenttien asettelu
<% end %>

<p>
  Jokaisella käyttöliittymäkomponentilla on oma sijainti käyttöliittymässä. Komponentin sijainnin määrää käytössä oleva käyttöliittymäkomponenttien asetteluun käytettävä luokka.
</p>

<p>
  Edellisissä esimerkeissä käytimme käyttöliittymäkomponenttien asetteluun <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/FlowPane.html" target="_blank" rel="noopener">FlowPane</a>-nimistä luokkaa. FlowPanen avulla käyttöliittymään lisättävät komponentit tulevat vierekkäin. Jos ikkunan koko pienenee siten, että kaikki komponentit eivät mahdu vierekkäin, rivitetään komponentit automaattisesti. Alla olevassa kuvassa edellisen esimerkin tuottamaa sovellusta on kavennettu, jolloin elementit ovat rivittyneet automaattisesti.
</p>

<img src="/img/material/gui-nappi-ja-teksti-rivitetty.png" alt="Ikkuna, jossa on nappi sekä tekstielementti. Napissa on teksti 'Tämä on nappi' ja tekstielementti sisältää tekstin 'Tekstielementti'. Ikkunan leveys on niin pieni, että elementit ovat rivitetty omille riveilleen."/>

<p>&nbsp;</p>


<% partial 'partials/material_sub_sub_heading' do %>
  BorderPane
<% end %>

<p>
  BorderPane-luokan avulla käyttöliittymäkomponentit voidaan asetella viiteen pääkohtaan käyttöliittymässä: ylälaita, oikea laita, alalaita, vasen laita ja keskikohta. Perinteiset sovellukset, kuten käyttämäsi web-selain hyödyntävät tätä asettelua. Ylälaidassa on valikko sekä osoiterivi, ja keskellä on sivun sisältö.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;

public class JavaFxSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
        BorderPane asettelu = new BorderPane();
        asettelu.setTop(new Label("ylälaita"));
        asettelu.setRight(new Label("oikea laita"));
        asettelu.setBottom(new Label("alalaita"));
        asettelu.setLeft(new Label("vasen laita"));
        asettelu.setCenter(new Label("keskikohta"));

        Scene nakyma = new Scene(asettelu);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(JavaFxSovellus.class);
    }
}
<% end %>

<img src="/img/material/gui-borderpane.png" alt="BorderPane-asettelua käyttävä käyttöliittymä, jossa jokaiseen pääkohtaan on asetettu tekstielementti."/>

<p>
  &nbsp;
</p>

<% partial 'partials/exercise', locals: { name: 'BorderPane' } do %>


  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä, joka käyttää BorderPane-luokkaa elementtien asetteluun. Lisää ylälaitaan tekstielementti, jossa on teksti "NORTH", oikeaan laitaan tekstielementti, jossa on teksti "EAST", ja alalaitaan tekstielementti, jossa on teksti "SOUTH".
  </p>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  HBox
<% end %>

<p>
  HBox-luokan avulla käyttöliittymäkomponentit asetellaan riviin.
</p>

<% partial 'partials/code_highlight' do %>
@Override
public void start(Stage ikkuna) {
    HBox asettelu = new HBox();

    asettelu.getChildren().add(new Label("eka"));
    asettelu.getChildren().add(new Label("toka"));
    asettelu.getChildren().add(new Label("kolmas"));

    Scene nakyma = new Scene(asettelu);

    ikkuna.setScene(nakyma);
    ikkuna.show();
}
<% end %>

<img src="/img/material/gui-hbox.png" alt="Tekstielementit on asetettu riviin HBox-asettelun avulla. Elementit ovat kiinni toisissaan."/>

<p>
  &nbsp;
</p>

<p>
  Kuten edellisestä esimerkistä huomaa, HBox asettaa käyttöliittymäelementit oletuksena täysin toisiinsa kiinni. Metodin setSpacing avulla elementtien väliin saa tyhjää.
</p>

<% partial 'partials/code_highlight' do %>
@Override
public void start(Stage ikkuna) {
    HBox asettelu = new HBox();
    asettelu.setSpacing(10);

    asettelu.getChildren().add(new Label("eka"));
    asettelu.getChildren().add(new Label("toka"));
    asettelu.getChildren().add(new Label("kolmas"));

    Scene nakyma = new Scene(asettelu);

    ikkuna.setScene(nakyma);
    ikkuna.show();
}
<% end %>

<img src="/img/material/gui-hbox-spacing.png" alt="Tekstielementit on asetettu riviin HBox-asettelun avulla. Elementtien välillä on 10 pikseliä eroa."/>

<p>
  &nbsp;
</p>

<p>
  Luokka VBox toimii vastaavasti, mutta asettelee käyttöliittymäkomponentit allekkain.
</p>

<img src="/img/material/gui-vbox-spacing.png" alt="Tekstielementit on asetettu allekkain VBox-asettelun avulla. Elementtien välillä on 10 pikseliä eroa."/>

<p>
  &nbsp;
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  GridPane
<% end %>

<p>
  <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/layout/GridPane.html" target="_blank" rel="noopener">GridPane</a>-luokan avulla käyttöliittymäkomponentit asetellaan ruudukkoon. Alla olevassa esimerkissä luodaan 3x3-kokoinen ruudukko, jossa jokaisessa ruudussa on nappi.
</p>

<% partial 'partials/code_highlight' do %>
@Override
public void start(Stage ikkuna) {
    GridPane asettelu = new GridPane();

    for (int x = 1; x <= 3; x++) {
        for (int y = 1; y <= 3; y++) {
            asettelu.add(new Button("" + x + ", " + y), x, y);
        }
    }

    Scene nakyma = new Scene(asettelu);

    ikkuna.setScene(nakyma);
    ikkuna.show();
}
<% end %>

<img src="/img/material/gui-gridpane-3x3.png" alt="3 kertaa 3 ruudukkoon asetetut 9 nappia."/>

<p>
  &nbsp;
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Useampi asettelija samassa
<% end %>

<p>
  Käyttöliittymäkomponenttien asettelijoita voi myös yhdistellä. Tyypillinen ratkaisu on BorderPane-asettelun käyttäminen pohjalla, jonka sisälle asetetaan muita asetteluja. Alla olevassa esimerkissä BorderPanen ylälaidassa on samalle riville asetteluun käytetty HBox ja vasemmassa laidassa allekkain asetteluun käytetty VBox. Keskelle on laitettu tekstikenttä.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class JavaFxSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
	BorderPane asettelu = new BorderPane();

	HBox napit = new HBox();
	napit.setSpacing(10);
	napit.getChildren().add(new Button("Eka"));
	napit.getChildren().add(new Button("Toka"));
	napit.getChildren().add(new Button("Kolmas"));

	VBox tekstit = new VBox();
	tekstit.setSpacing(10);
	tekstit.getChildren().add(new Label("Eka"));
	tekstit.getChildren().add(new Label("Toka"));
	tekstit.getChildren().add(new Label("Kolmas"));

	asettelu.setTop(napit);
	asettelu.setLeft(tekstit);

	asettelu.setCenter(new TextArea(""));

	Scene nakyma = new Scene(asettelu);

	ikkuna.setScene(nakyma);
	ikkuna.show();
    }

    public static void main(String[] args) {
	launch(JavaFxSovellus.class);
    }
}
<% end %>

<img src="/img/material/gui-useampi.png" alt="Samassa käyttöliittymässä käytetty useampaa asettelijaa. BorderPane luo rungon, ylälaidassa on HBox ja vasemmassa laidassa VBox. Keskellä olevaan tekstilaatikkoon on kirjoitettu tekstiä."/>

<p>
  &nbsp;
</p>



<% partial 'partials/exercise', locals: { name: 'Tekstitilastointia' } do %>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan sovellus, joka käyttää BorderPane-luokkaa asetteluun. Keskellä tulee olla TextArea-luokasta luotu tekstikenttä, ja alalaidassa kolme tekstielementtiä. Aseta alalaidan tekstielementit HBox-olion sisään. Ensimmäisessä tekstielementissä tulee olla teksti "Kirjaimia: 0". Toisessa tekstielementissä tulee olla teksti "Sanoja: 0". Kolmannessa tekstielementissä tulee olla teksti "Pisin sana on:".
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Tapahtumien käsittely
<% end %>

<p>
  Edellä toteuttamamme käyttöliittymän ovat loppujenlopuksi hieman tylsiä sillä ne eivät reagoi millään tavalla käyttöliittymässä tehtyihin tapahtumiin. Reagoimattomuus ei johdu käyttöliittymäkomponenteista, vaan siitä että emme ole lisänneet käyttöliittymäkomponentteihin tapahtumien käsittelyyn tarvittavaa toiminnallisuutta.
</p>

<p>
  Nappien painaminen käsitellään <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/event/EventHandler.html" target="_blank" rel="noopener">EventHandler</a>-rajapinnan toteuttavalla luokalla. Tapahtuman tyyppi on tällöin <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/event/ActionEvent.html" target="_blank" rel="noopener">ActionEvent</a>. Rajapinnan toteutukseen määritellään <em>mitä tehdään</em> silloin, kun käyttäjä painaa nappia.
</p>

<% partial 'partials/code_highlight' do %>
Button nappi = new Button("Tämä on nappi");
nappi.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
    @Override
    public void handle(ActionEvent event) {
        System.out.println("Painettu!");
    }
});
<% end %>

<p>
  Edellisessä osassa nähty tapa merkitä rajapinnasta luotu olio lyhyemmällä tavalla toimii tässäkin.
</p>

<% partial 'partials/code_highlight' do %>
Button nappi = new Button("Tämä on nappi");
nappi.setOnAction((event) -&gt; {
    System.out.println("Painettu!");
});
<% end %>

<p>
  Kun edellä olevaa nappi painetaan, tulostetaan teksti "Painettu!".
</p>

<p>
  Käyttöliittymäkomponentteihin liitetyt tapahtumankäsittelijät kuten edellä käytetty EventHandler liittyvät aina tiettyihin käyttöliittymäkomponentteihin. Aina kun käyttöliittymäkomponentille tehdään toiminto, esimerkiksi napille napin painaminen, jokaista kyseiseen käyttöliittymäkomponenttiin liittyvää tapahtumankäsittelijää kutsutaan, ja niihin liittyvä ohjelmakoodi suoritetaan.
</p>

<p>
  Haluamme tyypillisesti että tapahtumankäsittelijä muokkaa jonkun olion tilaa. Päästäksemme olioon käsiksi, tulee tapahtumankäsittelijällä olla viite käsiteltävään olioon. Pohditaan seuraavaa käyttöliittymää jossa on kaksi tekstikenttää sekä nappi.
</p>

<% partial 'partials/code_highlight' do %>
@Override
public void start(Stage ikkuna) {
    TextField vasenTeksti = new TextField();
    TextField oikeaTeksti = new TextField();
    Button nappi = new Button("Kopioi");

    HBox komponenttiryhma = new HBox();
    komponenttiryhma.setSpacing(20);
    komponenttiryhma.getChildren().addAll(vasenTeksti, nappi, oikeaTeksti);

    Scene nakyma = new Scene(komponenttiryhma);

    ikkuna.setScene(nakyma);
    ikkuna.show();
}
<% end %>

<p>
  Käyttöliittymän vasemmassa ja oikeassa laidassa on tekstikenttä. Tekstikenttien lisäksi käyttöliittymän keskellä on nappi, jossa on teksti "Kopioi".
</p>

<img src="/img/material/gui-kopioija.png" alt="Kaksi tekstikenttää sekä nappi, jossa on teksti 'Kopioi'."/>

<p>&nbsp;</p>

<p>
  Haluaisimme luoda tilanteen, missä vasemman tekstikentän sisältö kopioituu oikean kentän sisällöksi kun käyttäjä painaa nappia. Tämä onnistuu EventHandler-rajapinnan toteuttavan olion avulla. Toteutettava metodi pystyy käyttämään metodin edellä määriteltyjä olioita, jos olioiden arvoa ei aseteta ohjelmassa uudestaan yhtäsuuruusmerkillä (eli viitteet eivät muutu).
</p>

<% partial 'partials/code_highlight' do %>
@Override
public void start(Stage ikkuna) {
    TextField vasenTeksti = new TextField();
    TextField oikeaTeksti = new TextField();
    Button nappi = new Button("Kopioi");

    nappi.setOnAction((event) -&gt; {
        oikeaTeksti.setText(vasenTeksti.getText());
    });

    HBox komponenttiryhma = new HBox();
    komponenttiryhma.setSpacing(20);
    komponenttiryhma.getChildren().addAll(vasenTeksti, nappi, oikeaTeksti);

    Scene nakyma = new Scene(komponenttiryhma);

    ikkuna.setScene(nakyma);
    ikkuna.show();
}
<% end %>

<p>
  Nyt nappia painettaessa vasemman tekstikentän sisältö kopioituu oikealla olevaan tekstikenttään.
</p>

<img src="/img/material/gui-kopioija-2.png" alt="Kaksi tekstikenttää sekä nappi, jossa on teksti 'Kopioi'."/>

<p>
  &nbsp;
</p>

<% partial 'partials/exercise', locals: { name: 'Ilmoitin' } do %>

  <p>
    Toteuta tehtäväpohjassa olevaan luokkaan käyttöliittymä, jossa on kolme käyttöliittymäkomponenttia. Ylin komponentti on tekstikenttä (TextField), keskimmäinen komponentti nappi (Button), ja alin komponentti tekstielementti (Label). Asettele komponentit VBox-luokan avulla. Käyttöliittymän tulee näyttää (esimerkiksi) seuraavalta.
  </p>

  <img src="/img/material/gui-ilmoitin-1.png" alt="."/>

  <p>&nbsp;</p>

  <p>
    Lisää tämän jälkeen sovellukseen toiminnallisuus, missä napin painaminen johtaa siihen, että tekstikentän teksti kopioituu tekstielementin arvoksi. Alla olevassa esimerkissä tekstikenttään on kirjoitettu teksti "hei mualima!", jonka jälkeen nappia on painettu.
  </p>

  <img src="/img/material/gui-ilmoitin-2.png" alt="."/>

  <p>&nbsp;</p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Ristinolla (3 osaa)' } do %>

  <p>
    Tässä tehtävässä toteutat 3x3-kokoisen ristinollapelin. Tehtävä on jaettu kolmeen osaan: ensin luodaan käyttöliittymän osat, sitten nappien toiminnallisuus, ja lopuksi mahdollisuus pelin loppuun pelaamiseen.
  </p>

  <img src="/img/material/gui-ristinolla.png" alt="3x3 ristinolla."/>

  <p>
    Huom! Saat nappien merkit pysymään saman kokoisina sopivalla fontilla. Kuvakaappauksessa nappien käyttämä fontti on asetettu seuraavalla tavalla:
  </p>

  <% partial 'partials/code_highlight' do %>
Button nappi = new Button(" ");
nappi.setFont(Font.font("Monospaced", 40));
  <% end %>


  <h2>Käyttöliittymä</h2>

  <p>
    Muokkaa luokkaa RistinollaSovellus siten, että se käynnistää graafisen käyttöliittymän. Käytä käyttöliittymäkomponenttien asetteluun ensin BorderPane-luokkaa. Aseta BorderPanen ylälaitaan tekstielementti, joka sisältää tiedon vuorosta sekä pelin loppuessa tiedon pelin loppumisesta. Aseta BorderPanen keskelle GridPane, joka sisältää 9 nappia. GridPanessa tulee olla 3 riviä ja 3 saraketta, jolloin napit muodostavat 3x3-ruudukon.
  </p>


  <h2>Vuorojen vaihtaminen ja reilu peli</h2>

  <p>
    Pelissä pelaavat X ja O. Pelin aloittaa aina X. Lisää peliin toiminnallisuus, missä nappia painamalla tilanne päivittyy siten, että nappiin asetetaan vuorossa olevan pelaajan merkki (jos on X:n vuoro, nappiin tulee teksti X). Tämän jälkeen vuoro siirtyy seuraavalle pelaajalle.
  </p>

  <p>
    Pelin ylälaidassa olevan tekstikentän tulee kertoa aina vuorossa oleva pelaaja. Teksti on aluksi "Vuoro: X". Kun X pelaa vuoronsa, eli painaa jotain nappia, tekstiksi asetetaan "Vuoro: O". Tämän jälkeen kun O pelaa vuoronsa, tekstiksi asetetaan taas "Vuoro: X".
  </p>

  <p>
    Huom! Jos pelaaja on jo pelannut tietyn ruudun, ei toinen pelaaja saa enää pelata sitä. Varmista, ettei vuoro muutu tilanteessa, missä pelaaja yrittää pelata jo pelatun ruudun.
  </p>

  <p>
    Huom2! Mahdollisesti kohtaamasi virhe "local variables referenced from a lambda expression must be final or effectively final" johtuu siitä, että rajapinnoista tehdyt oliot eivät voi käyttää metodin ulkopuolella määriteltyjä muuttujia. Voit "kiertää" virheen luomalla uudet muuttujat, joihin asetat ongelmalliset arvot juuri ennen niiden käyttöönottoa metodissa.
  </p>


  <h2>Pelin loppuun vieminen</h2>

  <p>
    Lisää peliin toiminnallisuus, missä pelin voi pelata loppuun. Peli loppuu jos toinen pelaajista saa kolme samaa merkkiä riviin (pysty, vaaka, vino). Pelin loppuminen tulee ilmaista siten, että ylälaidassa on teksti "Loppu!". Tämän jälkeen pelin jatkaminen ei enää onnistu.
  </p>

<% end %>


<p>
  Käytettävä tapahtumankäsittelijä riippuu käyttöliittymäkomponentista, johon tapahtumankäsittelijä kytketään. Jos haluaisimme seurata tekstikenttään tapahtuvia muutoksia merkki merkiltä, käyttäisimme rajapintaa <a href="https://docs.oracle.com/javafx/2/api/javafx/beans/value/ChangeListener.html" target="_blank" rel="noopener">ChangeListener</a>.  Alla olevassa esimerkissä vasempaan tekstikenttään on kytketty rajapinnan ChangeListener toteuttava olio, joka sekä tulostaa muutokset tekstikonsoliin että asettaa aina uuden arvon oikealla olevaan tekstikenttään.
</p>

<% partial 'partials/code_highlight' do %>
vasenTeksti.textProperty().addListener(new ChangeListener&lt;String&gt;() {
    @Override
    public void changed(ObservableValue&lt;? extends String&gt; muutos,
            String vanhaArvo, String uusiArvo) {

        System.out.println(vanhaArvo + " -&gt; " + uusiArvo);
        oikeaTeksti.setText(uusiArvo);
    }
});
<% end %>

<p>
  Edellä muutoksia havainnoidaan tekstikenttään liittyvästä tekstistä. Koska teksti on merkkijonomuotoista, on muutoksia käsittelevälle rajapinnalle annettu tyypiksi merkkijono. Kuten edellä, myös tässäkin esimerkissä ohjelmakoodi voidaan esittää lyhyemmässä muodossa.
</p>

<% partial 'partials/code_highlight' do %>
vasenTeksti.textProperty().addListener((muutos, vanhaArvo, uusiArvo) -&gt; {
    System.out.println(vanhaArvo + " -&gt; " + uusiArvo);
    oikeaTeksti.setText(uusiArvo);
});
<% end %>

<p>
  Ohjelma voi tehdä myös tilastointia. Edellisessä tehtävässä luotujen tekstikenttien arvot saa laskettua melko suoraviivaisesti. Alla olevaa esimerkkiä noudattaen arvot päivittyisivät aina kun käyttäjä muuttaa tekstikentän sisältöä.
</p>

<% partial 'partials/code_highlight' do %>
vasenTeksti.textProperty().addListener((muutos, vanhaArvo, uusiArvo) -&gt; {
    int merkkeja = uusiArvo.length();
    String[] palat = uusiArvo.split(" ");
    int sanoja = palat.length;
    String pisin = Arrays.stream(palat)
        .sorted((s1, s2) -&gt; s2.length() - s1.length())
        .findFirst()
        .get();

    // asetetaan arvot tekstielementteihin
});
<% end %>



<% partial 'partials/exercise', locals: { name: 'Tekstitilastointia, osa II' } do %>

  <p>
    Kopioi tehtävässä Tekstitilastointia tekemäsi toteutus tehtäväpohjassa olevaan luokkaan ja liitä mukaan yllä olevassa esimerkissä oleva toiminnallisuus tilastojen laskemiseen. Lopputuloksena ohjelman pitäisi laskea kirjoitetusta tekstistä tilastoja, jotka päivittyvät automaattisesti sovellukseen.
  </p>

  <img src="/img/material/gui-tilastoja.gif" alt="Esimerkki tekstitilastointiin tarkoitetun ohjelman toiminnasta."/>

<% end %>



<% partial 'partials/material_sub_heading' do %>
  Sovelluslogiikan ja käyttöliittymälogiikan eriyttäminen
<% end %>

<p>
  Sovelluslogiikan (esimerkiksi ristinollan rivien tarkastamiseen tai vuorojen ylläpitoon liittyvä toiminnallisuus) ja käyttöliittymän pitäminen samassa luokassa tai samoissa luokissa on yleisesti ottaen huono asia. Se vaikeuttaa ohjelman testaamista ja muokkaamista huomattavasti ja tekee lähdekoodista myös vaikeammin luettavaa. Motto "Jokaisella luokalla pitäisi olla vain yksi selkeä vastuu" pätee hyvin tässäkin.
</p>

<p>
  Tarkastellaan sovelluslogiikan erottamista käyttöliittymälogiikasta. Oletetaan, että käytössämme on seuraavan rajapinnan toteuttava olio ja haluamme toteuttaa käyttöliittymän henkilöiden tallentamiseen.
</p>

<% partial 'partials/code_highlight' do %>
public interface Henkilovarasto {
    void talleta(Henkilo henkilo);
    Henkilo hae(String henkilotunnus);

    void poista(Henkilo henkilo);
    void poista(String henkilotunnus);
    void poistaKaikki();

    Collection&lt;Henkilo&gt; haeKaikki();
}
<% end %>

<p>
  Käyttöliittymää toteutettaessa hyvä aloitustapa on ensin käyttöliittymän piirtäminen, jota seuraa sopivien käyttöliittymäkomponenttien lisääminen käyttöliittymään. Henkilöiden tallennuksessa tarvitsemme kentät nimelle ja henkilötunnukselle sekä napin jolla henkilö voidaan lisätä. Käytetään luokkaa TextField nimen ja henkilötunnuksen syöttämiseen ja luokkaa Button napin toteuttamiseen. Luodaan käyttöliittymään lisäksi selventävät Label-tyyppiset selitystekstit.
</p>

<p>
  Käytetään käyttöliittymän asetteluun <code>GridPane</code>-asettelijaa. Rivejä käyttöliittymässä on 3, sarakkeita 2. Lisätään tapahtumien käsittelytoiminnallisuus myöhemmin. Käyttöliittymän alustusmetodi näyttää seuraavalta.
</p>

<% partial 'partials/code_highlight' do %>
@Override
public void start(Stage ikkuna) {

    Label nimiTeksti = new Label("Nimi: ");
    TextField nimiKentta = new TextField();
    Label hetuTeksti = new Label("Hetu: ");
    TextField hetuKentta = new TextField();

    Button lisaaNappi = new Button("Lisää henkilö!");

    GridPane komponenttiryhma = new GridPane();
    komponenttiryhma.add(nimiTeksti, 0, 0);
    komponenttiryhma.add(nimiKentta, 1, 0);
    komponenttiryhma.add(hetuTeksti, 0, 1);
    komponenttiryhma.add(hetuKentta, 1, 1);
    komponenttiryhma.add(lisaaNappi, 1, 2);

    // tyylittelyä: lisätään tyhjää tilaa reunoille ym
    komponenttiryhma.setHgap(10);
    komponenttiryhma.setVgap(10);
    komponenttiryhma.setPadding(new Insets(10, 10, 10, 10));

    Scene nakyma = new Scene(komponenttiryhma);

    ikkuna.setScene(nakyma);
    ikkuna.show();
}
<% end %>

<img src="/img/material/gui-lisaa-henkilo.png" alt="Kaksi tekstikenttää sekä nappi, jossa on teksti 'Kopioi'."/>

<p>
  &nbsp;
</p>

<p>
  Luodaan seuraavaksi ohjelmaan ActionEvent-rajapinnan toteuttava olio, joka lisää kenttien arvot Henkilovarasto-rajapinnalle.
</p>

<% partial 'partials/code_highlight' do %>
@Override
public void start(Stage ikkuna) {
    // ...

    lisaaNappi.setOnAction((event) -&gt; {
        henkilovarasto.talleta(new Henkilo(nimiTeksti.getText(), hetuTeksti.getText());
    });
    // ...
}
<% end %>

<p>
  Mutta. Mistä saamme konkreettisen Henkilovarasto-olion? Se luodaan esimerkiksi esimerkiksi start-metodin alussa. Alla annettuna koko sovelluksen runko.
</p>

<% partial 'partials/code_highlight' do %>
// pakkaus

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class HenkiloSovellus extends Application {

    @Override
    public void start(Stage ikkuna) {
        Henkilovarasto henkilovarasto = new OmaHenkilovarasto();

        Label nimiTeksti = new Label("Nimi: ");
        TextField nimiKentta = new TextField();
        Label hetuTeksti = new Label("Hetu: ");
        TextField hetuKentta = new TextField();

        Button lisaaNappi = new Button("Lisää henkilö!");
        lisaaNappi.setOnAction((event) -&gt; {
            Henkilo lisattava = new Henkilo(nimiTeksti.getText(), hetuTeksti.getText());
            henkilovarasto.talleta(new Henkilo(lisattava);
        });

        GridPane komponenttiryhma = new GridPane();
        komponenttiryhma.add(nimiTeksti, 0, 0);
        komponenttiryhma.add(nimiKentta, 1, 0);
        komponenttiryhma.add(hetuTeksti, 0, 1);
        komponenttiryhma.add(hetuKentta, 1, 1);
        komponenttiryhma.add(lisaaNappi, 1, 2);

        // tyylittelyä: lisätään tyhjää tilaa reunoille ym
        komponenttiryhma.setHgap(10);
        komponenttiryhma.setVgap(10);
        komponenttiryhma.setPadding(new Insets(10, 10, 10, 10));

        Scene nakyma = new Scene(komponenttiryhma);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(HenkiloSovellus.class);
    }
}
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Piirtäminen
<% end %>

<p>
  JavaFX-käyttöliittymäkirjastossa piirtämiseen käytetään <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/canvas/Canvas.html" target="_blank" rel="noopener">Canvas</a>-oliota. Canvas-olio edustaa tyhjää taulua, johon voi piirtää. Piirtäminen tapahtuu Canvas-oliolta saatavalla <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/canvas/GraphicsContext.html" target="_blank" rel="noopener">GraphicsContext</a>-oliolla.
</p>

<p>
  Alla olevassa esimerkissä on luotu yksinkertainen piirto-ohjelma. Ohjelmassa luodaan 640 pikseliä leveä ja 480 pikseliä korkea piirtoalusta, joka asetetaan BorderPane-asettelun keskelle. Tämän lisäksi luodaan piirtovärin valintaan käytettävä <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/ColorPicker.html" target="_blank" rel="noopener">ColorPicker</a>-olio, jolta saa tietoonsa kullakin hetkellä valittuna olevan värin. Värin valitsin asetetaan BorderPane-asettelun keskelle. Piirtoalustaan lisätään hiiren liikkumista kuunteleva tapahtuman käsittelijä. Kun hiirtä liikutetaan nappi pohjassa (onMouseDragged), kutsutaan GraphicsContext-olion värin asetusmetodia sekä piirretään hiiren kohtaan pieni ympyrä.

<% partial 'partials/code_highlight' do %>
// pakkaus

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.ColorPicker;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;

public class MiniPaint extends Application {

    @Override
    public void start(Stage ikkuna) {

        Canvas piirtoalusta = new Canvas(640, 480);
        GraphicsContext piirturi = piirtoalusta.getGraphicsContext2D();

        ColorPicker varinValitsin = new ColorPicker();

        BorderPane asettelu = new BorderPane();
        asettelu.setRight(varinValitsin);
        asettelu.setCenter(piirtoalusta);

        piirtoalusta.setOnMouseDragged((event) -&gt; {
            double kohtaX = event.getX();
            double kohtaY = event.getY();
            piirturi.setFill(varinValitsin.getValue());
            piirturi.fillOval(kohtaX, kohtaY, 4, 4);
        });

        Scene nakyma = new Scene(asettelu);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(MiniPaint.class);
    }
}
<% end %>

<p>
  Sovellus näyttää seuraavanlaiselta. Alla sovellusta on käytetty jo hieman piirtämiseen.
</p>

<img src="/img/material/gui-paint.png" alt="Yksinkertainen piirto-ohjelma. Käyttäjä voi piirtää pitämällä hiirtä pohjassa. Oikeassa laidassa on värin valintaan käytettävä ColorPicker-olio."/>

<p>
  &nbsp;
</p>

<p>
  Canvas-luokan avulla voidaan myös luoda ohjelma, joka piirtää kuvaa jatkuvasti. Tämä tapahtuu <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/animation/AnimationTimer.html" target="_blank" rel="noopener">AnimationTimer</a>-luokan avulla. AnimationTimer-luokka määrittelee metodin <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/animation/AnimationTimer.html#handle-long-" target="_blank" rel="noopener">handle</a>, joka luokkaa käyttävän ohjelmoijan tulee toteuttaa. Metodi handle saa parametrina nykyhetken nanosekunteina, jonka avulla voidaan vaikuttaa piirtovälien pituuteen.
</p>

<p>
  Alla olevassa esimerkissä on ohjelma, jossa piirretään satunnaiseen kohtaan piste kymmenen kertaa sekunnissa.
</p>

<% partial 'partials/code_highlight' do %>
// pakkaus..

import java.util.Random;
import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class AnimaationAlku extends Application {

    @Override
    public void start(Stage ikkuna) {

        Canvas piirtoalusta = new Canvas(320, 240);
        GraphicsContext piirturi = piirtoalusta.getGraphicsContext2D();
        piirturi.setFill(Color.BLACK);

        BorderPane asettelu = new BorderPane();
        asettelu.setCenter(piirtoalusta);

        Random arpoja = new Random();

        new AnimationTimer() {
            long edellinen = 0;

            @Override
            public void handle(long nykyhetki) {
                if (nykyhetki - edellinen < 100000000) {
                    return;
                }

                int x = arpoja.nextInt(310);
                int y = arpoja.nextInt(230);

                piirturi.fillOval(x, y, 10, 10);

                this.edellinen = nykyhetki;
            }
        }.start();

        Scene nakyma = new Scene(asettelu);

        ikkuna.setScene(nakyma);
        ikkuna.show();
    }

    public static void main(String[] args) {
        launch(AnimaationAlku.class);
    }
}
<% end %>

<p>
  Ohjelma toimii käynnistyessään esimerkiksi seuraavasti.
</p>

<img src="/img/material/gui-animaatio.gif" alt="Edellinen ohjelma toiminnassa. Kuvaan ilmestyy kymmenen pistettä sekunnissa."/>

<p>&nbsp;</p>

<p>
  Silloin tällöin ohjelma halutaan toteuttaa siten, että uusi tila piirretään aina edellisen tilanteen päälle. Tällöin tapana on tyhjentää ruutu ennen uutta piirtämistä. Tämä onnistuu lisäämällä edelliseen ohjelmaamme rivi <code>piirturi.clearRect(0, 0, 320, 240);</code> ennen handle-metodissa olevaa piirtokomentoa. Komento tyhjentää kohdasta (0, 0) lähtien 320 pikseliä leveän ja 240 pikseliä korkean suunnikkaan.
</p>



<% partial 'partials/exercise', locals: { name: 'Hymiö' } do %>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä. Lisää graafiseen käyttöliittymään Canvas-olio, ja piirrä käyttöliittymään Canvas-olioon liittyvän GraphicsContext-olion avulla hymiö.
  </p>

  <p>
    Tehtävässä ei ole testejä -- palauta se kun saat hymiön piirtämisen toimimaan. Huomaa ettei tässä ole tarkoitus piirtää hymiötä esimerkiksi hiirellä -- käytä suoraan GraphicsContext-olion tarjoamia metodeja.
  </p>

  <img src="/img/material/gui-hymio.png" alt="Hymiö" />

<% end %>


<% partial 'partials/exercise', locals: { name: 'Hiekkaranta (5 osaa)' } do %>

  <p>
    Tässä tehtävässä luodaan <a href="https://en.wikipedia.org/wiki/Falling-sand_game" target="_blank" rel="noopener">falling sand game</a>-tyyppinen sovellus, jota käytetään erilaisten aineiden simulointiin. Ohjelmassamme simuloidaan hiekan ja veden käyttäytymistä. Lopullisen sovelluksen toiminta on esimerkiksi seuraavanlainen.
  </p>

  <img src="/img/material/gui-simulaatio.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>

  <p>
    Huom! Käytät tässä tehtävässä luokassa HiekkarantaSovellus olevaa metodia <code>public static int toteutetutOsat()</code> toteutettujen tehtävän osien raportointiin. Älä poista metodia, vaan muokkaa sitä aina kun saat yksittäisen osan valmiiksi. Tehtävä koostuu viidestä osasta.
  </p>

  <p>
    Huom2! Kun toteutat simulaatiota, varmista että ohjelma pitää tarpeeksi pitkiä taukoja piirtämisten ja simulaatioiden välillä. Tällöin tehoja jää myös testien ajamiseen. Testien suorittaminen palvelimella päätyy heikosti, jos kaikki palvelimen teho menee animaation suorittamiseen. Tällöin testien ajon viestinä on esim. kryptinen "Missing test output.". Jos saat tämän virheen palvelimelta, kokeile suoritusta esimerkiksi siten, että simulaatiota piirretään ja päivitetään korkeintaan 20 kertaa sekunnissa.
  </p>


  <p>
    Huom3! Kun piirrät hiekkalaatikkoa, piirrä musta alue yhtenä isona suorakulmiona piirtämisen alussa. Näin jokaista yksittäistä mustaa pistettä ei tarvitse erikseen piirtää, ja voit keskittyä muiden pisteiden piirtämiseen.
  </p>


  <h2>Palaset kohdalleen</h2>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä. Graafisen käyttöliittymän komponenttien asettelu tulee tehdä BorderPane-luokan avulla. Lisää BorderPane-luokan keskelle Canvas-olio, jota käytetään piirtämiseen. Aseta Canvas-olion leveydeksi ja korkeudeksi 200 pikseliä. Lisää BorderPane-luokan oikealle laidalle VBox-olio, joka sisältää kolme <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/RadioButton.html" target="_blank" rel="noopener">RadioButton</a>-oliota. Ensimmäiseen RadioButton-olioon tulee liittyä teksti "Metalli", toiseen teksti "Hiekka", ja kolmanteen teksti "Vesi".
  </p>

  <p>
    Kun saat tämän osan valmiiksi, muokkaa luokan HiekkarantaSovellus metodia <code>public static int toteutetutOsat()</code> siten, että se palauttaa arvon 1. Voit myös palauttaa tehtävän, niin saat siitä ensimmäisen pisteen.
  </p>


  <h2>Simulaation alkupalat</h2>

  <p>
    Luo pakkaukseen hiekkaranta luokka Simulaatio. Luokalla Simulaatio tulee olla seuraavat konstruktorit ja metodit. Käytä luokassa hyödyksi valmista enum-luokkaa Tyyppi.
  </p>

  <ul>
    <li>
      Konstruktori <code>public Simulaatio(int leveys, int korkeus)</code> luo annetun levyisen ja korkuisen simulaation. Jokainen kohta on aluksi tyhjä.
    </li>
    <li>
      Metodi <code>public void lisaa(int x, int y, Tyyppi tyyppi</code> lisää annettuun kohtaan annetun tyyppisen elementin. Tyyppi on joko tyhjä, metalli, hiekka tai vesi.
    </li>
    <li>
      Metodi <code>public Tyyppi sisalto(int x, int y)</code> palauttaa annetussa kohdassa olevan sisällön. Vastaus on joko Tyyppi.TYHJA, Tyyppi.METALLI, Tyyppi.HIEKKA tai Tyyppi.VESI. Jos kohtaan ei ole lisätty mitään arvoa, tyyppi on Tyyppi.TYHJA. Jos käyttäjä kysyy tietoa alueen ulkopuolelta, palauta Tyyppi.METALLI.
    </li>
    <li>
      Metodi <code>public void paivita()</code> päivittää simulaatiota yhden askeleen. Päivitystoiminnallisuuden toteutus aloitetaan kohtapuoliin .
    </li>
  </ul>

  <p>
    Kun saat tämän osan valmiiksi, muokkaa luokan HiekkarantaSovellus metodia <code>public static int toteutetutOsat()</code> siten, että se palauttaa arvon 2. Voit myös palauttaa tehtävän, niin saat siitä toisen pisteen.
  </p>



  <h2>Metallin lisääminen ja piirtäminen</h2>

  <p>
    Lisää edellä toteuttamasi Simulaatio osaksi käyttöliittymää. Aseta simulaation leveydeksi 200 ja korkeudeksi 200 pikseliä (simulaation tulee toimia myös muun kokoisena). Lisää tämän jälkeen sovellukseen mahdollisuus metallin lisäämiseen. Metallia lisätään kun käyttäjä piirtää kuvaan sisältöä ja metalli on valittuna oikealla laidalla olevasta valikosta.
  </p>

  <p>
    Käytä simulaation käyttäjälle näyttämiseen AnimationTimer-luokkaa sekä Canvas-oliota. Piirrä canvas-olion sisältö uudestaan kymmenen kertaa sekunnissa. Kun metallin lisääminen onnistuu, se toimii esimerkiksi seuraavalla tavalla. Alla olevassa esimerkissä hiiren pohjassapito lisää useampia metallipisteitä samaan aikaan.
  </p>

  <img src="/img/material/gui-simulaatio-metalli.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>

  <p>
    Kun saat tämän osan valmiiksi, muokkaa luokan HiekkarantaSovellus metodia <code>public static int toteutetutOsat()</code> siten, että se palauttaa arvon 3. Voit myös palauttaa tehtävän, niin saat kolmannen pisteen.
  </p>


  <h2>Hiekan lisääminen ja toiminnallisuus</h2>

  <p>
    Lisää tämän jälkeen toiminnallisuus hiekan lisäämiseen ja piirtämiseen. Hiekka tulee piirtää eri värillä kuin metalli. Google auttaa tarvittaessa piirtämisessä -- esimerkiksi haku "javafx how to draw on canvas using animationtimer" antaa linkkejä, joista on hyötyä.
  </p>

  <p>
    Kun onnistut myös hiekan lisäämiseen käyttöliittymässä (metallin lisäämisen tulee myös onnistua!), muokkaa tämän jälkeen Simulaatio-luokan metodia paivita. Metodin paivita tulee toimia siten, että se tarkistaa jokaiselle hiekkaa sisältävälle kohdalle kohdan alla olevat kolme vaihtoehtoa. Jos joku vaihtoehdoista on tyhjä, hiekka siirretään alaspäin tyhjään kohtaan.
  </p>

  <p>
    Nyt sovelluksessa pitäisi tapahtua liikettä kun piirrät hiekkaa. Saat Random-luokan avulla sovellukseesi satunnaisuutta -- hiekan ei tarvitse toimia aina täsmälleen samalla tavalla.
  </p>

  <img src="/img/material/gui-simulaatio-metalli-ja-hiekka.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta. Kuvassa hiekka toimii metallin kanssa." />

  <p>
    &nbsp;
  </p>

  <p>
    Kun saat tämän osan valmiiksi, muokkaa luokan HiekkarantaSovellus metodia <code>public static int toteutetutOsat()</code> siten, että se palauttaa arvon 4. Voit myös palauttaa tehtävän, niin saat neljännen pisteen.
  </p>


  <h2>Veden lisääminen</h2>

  <p>
    Lisää tämän jälkeen toiminnallisuus veden lisäämiseen ja piirtämiseen. Piirrä vesi eri värillä kuin hiekka tai metalli.
  </p>

  <p>
    Muokkaa tämän jälkeen Simulaatio-luokan metodia paivita siten, että se siirtää kutsun yhteydessä vettä alaspäin <em>jos</em> joku veden alapuolella olevista kohdista on tyhjä. Jos yksikään kohdista ei ole tyhjiä, mutta jommalla kummalla laidalla on sijaa, siirretään vettä sivulle.
  </p>

  <p>
    Muokkaa vielä sovellusta siten, että hiekka syrjäyttää veden. Kun lisäät hiekkaa, veden tulee siis väistää hiekkaa. Nyt sovelluksen pitäisi toimia kokonaisuudessaan!
  </p>

  <img src="/img/material/gui-simulaatio.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>

  <p>
    Kun saat tämän osan valmiiksi, muokkaa luokan HiekkarantaSovellus metodia <code>public static int toteutetutOsat()</code> siten, että se palauttaa arvon 5. Voit myös palauttaa tehtävän, niin saat viidennen pisteen.
  </p>

  <p>
    Palauta tehtävä viimeistään nyt. Voit tämän jälkeen lähteä toteuttamaan uusia toiminnallisuuksia. Miten toteuttaisit esimerkiksi laavan?
  </p>


<% end %>


<%= partial 'partials/quiz', locals: { id: '5a11fb7f23571900049f64ed' } %>
