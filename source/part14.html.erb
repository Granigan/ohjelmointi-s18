---
  title: Osa 14
  exercise_page: true
  quiz_page: true
  published: false
---

<% partial 'partials/hint', locals: { name: 'Neljännentoista osan tavoitteet' } do %>

  <p>
    Osaa näyttää kuvia sekä soittaa äänitiedostoja. Luo suuremman ohjelman esimerkkiä noudattaen. Osaa tehdä graafista käyttöliittymää käyttävästä ohjelmasta paketin, jonka voi jakaa muille.
  </p>

<% end %>


<% partial 'partials/material_heading' do %>
  Multimedian käyttö sovelluksissa
<% end %>

<p>
  Tutustutaan lyhyesti multimedian käyttöön JavaFX-sovelluksissa.
</p>

<% partial 'partials/material_sub_heading' do %>
  Kuvat
<% end %>

<p>
  Kuvan näyttämiseen osana sovellusta on useita tapoja. Eräs suoraviivainen lähestymistapa hyödyntää JavaFx:n <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/Image.html" target="_blank">Image</a> ja <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/image/ImageView.html" target="_blank">ImageView</a> luokkia.
</p>

<p>
  Image-luokalle annetaan parametrina avattavan kuvatiedoston nimi -- nimeä tulee edeltää etuliite <code>file:</code>, joka kertoo kuvan olevan tiedosto. Alla olevassa esimerkissä ladataan tiedosto <code>humming.jpg</code>, joka annetaan luotavalle ImageView-oliolle parametrina. Tämän jälkeen ImageView-olio asetetaan Pane-asetteluun -- Pane-asettelu ei ota mm. kantaa sen sisältävien elementtien sijaintiin. Lopulta asettelu asetetaan osaksi Scene-oliota ja se asetetaan näkyville.
</p>

<% partial 'partials/code_highlight' do %>
import javafx.application.Application;
import static javafx.application.Application.launch;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

public class KuvaApplication extends Application {

    @Override
    public void start(Stage stage) {

        Image kuvatiedosto = new Image("file:humming.jpg");
        ImageView kuva = new ImageView(kuvatiedosto);

        Pane ruutu = new Pane();
        ruutu.getChildren().add(kuva);

        stage.setScene(new Scene(ruutu));
        stage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }

}
<% end %>

<p>
  Ohjelman suorittaminen luo seuraavanlaisen ikkunan. Tässä oletetaan, että tiedosto <code>humming.jpg</code> on olemassa, ja että se löytyy projektin juuresta (samasta kansiosta kuin tiedosto <code>pom.xml</code>).
</p>

<img src="/img/material/image-ja-imageview.png" />

<p>&nbsp;</p>

<p>
  Esimerkissä käytetään <a href="https://www.flickr.com/photos/15323831@N05" target="_blank">Linda Tanner</a>in kuvaa osoitteesta <a href="http://www.freestockphotos.biz/stockphoto/17874" target="_blank">http://www.freestockphotos.biz/stockphoto/17874</a>. Kuva on lisensoitu <a href="https://creativecommons.org/licenses/by/2.0/" target="_blank">Creative Commons CC BY 2.0</a>-lisenssillä.
</p>

<p>
  ImageView-olio tarjoaa joukon menetelmiä kuvan (yksinkertaiseen käsittelyyn). Kuvaa voi muunmuassa kääntää, sen kokoa voi muuttaa, ja sitä voi siirtää ruudulla. Alla olevassa esimerkissä kuva on käännetty ympäri, sen koko on puolitettu, ja sitä on siirretty hieman oikealle.
</p>

<% partial 'partials/code_highlight' do %>
    @Override
    public void start(Stage stage) {

        Image kuvatiedosto = new Image("file:humming.jpg");
        ImageView kuva = new ImageView(kuvatiedosto);
        
        kuva.setRotate(180);
        kuva.setScaleX(0.5);
        kuva.setScaleY(0.5);
        
        kuva.setTranslateX(50);

        Pane ruutu = new Pane();
        ruutu.getChildren().add(kuva);

        stage.setScene(new Scene(ruutu));
        stage.show();

    }
<% end %>

<img src="/img/material/humming-kaannetty.png" />

<p>&nbsp;</p>


<p>
  ImageView-luokka tarjoaa pääsyn kuvaan, mutta sen kautta ei pääse yksittäisiin pikseleihin (eli yksittäisiin yhtä väriä sisältäviin pieniin "ruutuihin", joista kuva koostuu). Kuvan yksittäisiä pikseleitä voi lukea Image-oliosta saatavan <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/PixelReader.html" target="_blank">PixelReader</a>-olion avulla. PixelReader-olion avulla voidaan käydä koko kuva läpi pikseli pikseliltä, samalla kuvaa erilliseen <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/WritableImage.html" target="_blank">WritableImage</a>-olioon kirjoittaen.
</p>

<p>
  Alla olevassa esimerkissä kuva kopioidaan pikseli pikseliltä erilliselle WritableImage-oliolle, joka näytetään sovelluksessa.
</p>

<% partial 'partials/code_highlight' do %>
    @Override
    public void start(Stage stage) {

        Image kuvatiedosto = new Image("file:humming.jpg");

        PixelReader lukija = kuvatiedosto.getPixelReader();

        int leveys = (int) kuvatiedosto.getWidth();
        int korkeus = (int) kuvatiedosto.getHeight();

        WritableImage kohdeKuva = new WritableImage(leveys, korkeus);
        PixelWriter kirjoittaja = kohdeKuva.getPixelWriter();

        for (int y = 0; y &lt; korkeus; y++) {
            for (int x = 0; x &lt; leveys; x++) {

                Color vari = lukija.getColor(x, y);
                double punainen = vari.getRed();
                double vihrea = vari.getGreen();
                double sininen = vari.getBlue();
                double lapinakyvyys = vari.getOpacity();

                Color uusiVari = new Color(punainen, vihrea, sininen, lapinakyvyys);

                kirjoittaja.setColor(x, y, uusiVari);
            }
        }

        ImageView kuva = new ImageView(kohdeKuva);

        Pane pane = new Pane();
        pane.getChildren().add(kuva);

        stage.setScene(new Scene(pane));
        stage.show();
    }
<% end %>

<p>
  Kuvan ulkomuoto ei ole muuttunut lainkaan.
</p>

<img src="/img/material/image-ja-imageview.png" />

<p>&nbsp;</p>

<p>
  Muistellaan kurssin ensimmäistä osaa sekä tehtävää Salapaikka ranskassa. Tehtävässä käsiteltiin kuvankäsittelyyn liittynyttä ohjelmistovirhettä: <em>"Tämä virhe oli aika harmittava. Se muutti kaikki siniset ja vihreät väriarvot pelkäksi kohinaksi, joten niistä ei ole mitään iloa eikä niitä saa koskaan takaisin kuvaan. Lisäksi punaisen värin määrä jokaisessa pikselissä jakautui noin kymmenellä kopioinnin yhteydessä, joten kuvan punainen väri on aivan liian tumma."</em>
</p>

<p>
  Lisätään kuvaan edellinen ohjelmistovirhe, eli muunnetaan siniset ja vihreät väriarvot kohinaksi (satunnaisiksi luvuiksi). Jaetaan myös punaisen värin määrä kymmenellä.
</p>

<% partial 'partials/code_highlight' do %>
        Random arpoja = new Random();
        
        for (int y = 0; y < korkeus; y++) {
            for (int x = 0; x < leveys; x++) {

                Color vari = lukija.getColor(x, y);
                double punainen = vari.getRed() /  10;
                double vihrea = arpoja.nextDouble();
                double sininen = arpoja.nextDouble();
                double lapinakyvyys = vari.getOpacity();

                Color uusiVari = new Color(punainen, vihrea, sininen, lapinakyvyys);

                kirjoittaja.setColor(x, y, uusiVari);
            }
        }
<% end %>

<p>
  Mysteerikuvasta tulee melko tutunnäköinen.
</p>

<img src="/img/material/kuva-mysteeri.png" />

<p>&nbsp;</p>

<% partial 'partials/exercise', locals: { name: 'Kollaasi' } do %>

  <p>
    Andy Warhol tuli tutuksi kuvakollaaseista, joissa yksi tai useampi kuva toistui useampaan otteeseen esimerkiksi eri väreissä.
  </p>

  <p>    
    Tehtäväpohjassa on ohjelma, joka lataa ja näyttää Mona Lisan. Tehtävänäsi on luoda Andy Warholmainen muunnos annetusta kuvasta. Muunnos voi olla esimerkiksi alla olevan kuvan näköinen, tai se voi olla jotain muuta.
  </p>

  <img src="/img/material/monalisa-kollaasi.png" />

  <p>
    &nbsp;
  </p>

  <p>
    Vinkki! Kannattaa pyrkiä ensin tilanteeseen, missä kuva toistuu kahdesti, isona ja pienenä. Kts. alla.
  </p>

  <img src="/img/material/monalisa-kollaasi-alku.png" />

  <p>
    &nbsp;
  </p>
  
  <p>
    Kun saat muodostettua kollaasin, tehtävää voi jatkaa halutessaan. Voit esimerkiksi etsiä käyttöösi toisen tai useamman kuvan (valitkaa png-muodossa oleva kuva), tai lähteä miettimään parempaa väriä käyttämällenne kuvalle. Alla olevassa esimerkissä väri vaihdettu negatiiviksi -- tämä onnistuu ottamalla jokaisen värin erotus luvusta yksi, esim. <code>punainen = 1.0 - punainen</code>.
  </p>
  
  <img src="/img/material/monalisa-negatiivi.png" />

  <p>
    &nbsp;
  </p>

  <p>
    <em>
      Tehtäväpohjan mukana tuleva Mona Lisa -kuva on noudettu Wikimedian osoitteesta <a href="https://commons.wikimedia.org/wiki/Category:Mona_Lisa" target="_blank">https://commons.wikimedia.org/wiki/Category:Mona_Lisa</a>. Käytetty kuva on vapaasti käytettävissä.
    </em>
  </p>
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Matkavalokuvat (2 osaa)' } do %>

  <p>
    Matkailijat tykkäävät ottaa valokuvia. Usein kuvissa sattuu kuitenkin olemaan ärsyttävä turisti, joka on esimerkiksi kuvatun kohteen edessä. Harmitus kasvaa erityisesti, jos samainen turisti esiintyy jokaisessa kuvassa.
  </p>

  <p>
    Alla on kaksi kuvaa eräästä reissusta.
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-1.png"/>

  <p>&nbsp;</p>

  <img src="/img/exercises/06-19-matkavalokuvat-2.png"/>

  <p>&nbsp;</p>

  <p>
    Täydennetään ohjelmaa, mikä mahdollistaa kuvan katsomisen ilman turistia. Apunamme meillä on iso nippu samasta kohteesta otettuja kuvia (turisti on harmittavasti kylläkin jokaisessa niistä...)
  </p>

  <p>
    Tehtäväpohjassa on valmiina ohjelma, jolla voi tarkastella kuvia. Huomaat, että ohjelmassa käytetty kuvien näyttämistapa poikkeaa hieman edellisistä esimerkeistä -- kuten todettua, lähestymistapoja on useita. Kun ohjelma on käynnissä, painamalla numeronäppäintä saat näkyville kuvalistan tietyssä indeksissä olevan kuvan. Kun painat näppäintä "v", näet kuvan muodossa, missä jokaisen kuvan jokaisesta pikselistä on valittu vaaleimmat pikseliarvot.
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-vaalein.png"/>

  <p>&nbsp;</p>

  <h2>Tummimman värin valinta</h2>

  <p>
    Muokkaa sovellusta siten, että kun käyttäjä painaa näppäintä "t", ohjelma näyttää kuvan, missä näkyy yhdistettävien kuvien tummimmat pikselit. Toteuta tummimman värin valinta luokan Yhdistin metodiin <code>public WritableImage tummin(final ArrayList&lt;Image&gt; kuvat)</code> -- ota mallia metodista <code>vaalein</code>.
  </p>

  <p>
    Kun olet lisännyt tummennustoiminnallisuuden, tumman kuvan pitäisi näyttää kutakuinkin seuraavalta.
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-tummin.png"/>

  <p>&nbsp;</p>

  <h2>Värien mediaani</h2>

  <p>
    Noniin, hankkiudutaan turistista eroon.
  </p>

  <p>
    Muokkaa sovellusta siten, että kun käyttäjä painaa näppäintä "m", ohjelma näyttää kuvan, missä näkyy yhdistettävien kuvien väriarvojen mediaanit. Toteuta mediaanivärin valinta luokan Yhdistin metodiin <code>public WritableImage mediaani(final ArrayList&lt;Image&gt; kuvat)</code>.
  </p>

  <p>
    Mediaani on järjestettyjen lukujen keskimmäinen arvo. Esimerkiksi, jos viiden kuvan sinisten värien arvot ovat <code>211, 123, 17, 155, 8</code>, on niiden mediaani <code>123</code>. Saat mediaanin selville järjestämällä arvot, ja valitsemalla listan keskimmäisen arvon.
  </p>

  <p>
    Toteutuksen pitäisi poistaa ärsyttävä turisti:
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-mediaani.png"/>


  <p>
    <em>Tehtävän alkuperäinen versio: John Nicholson / Austin Peay State University</em>
  </p>

<% end %>

<% partial 'partials/material_sub_heading' do %>
  Äänet
<% end %>

<p>
  Äänitiedostojen käsittelyyn löytyy myös useampia menetelmiä, joista tässä käsitellään yksi tapa. Tapa liittyy äänitiedostojen käsittelyyn äänileikkeinä (audioclip), jotka ovat esimerkiksi ääniefektejä ym.
</p>

<p>
  Esimerkissä käytetään Daniel Simionin <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">Creative Commons Attribution 3.0</a> -lisenssillä julkaisemaa äänitiedostoa. Äänitiedoston voi kuunnella alla. Äänitiedosto on noudettu osoitteessa <a href="http://soundbible.com/" target="_blank">http://soundbible.com/</a> olevasta palvelusta.
</p>

<audio controls>
  <source src="../img/front-desk-bells-daniel_simon.wav" type="audio/wav"/>
</audio>

<p>
  Oletetaan, että tiedoston nimi on <code>bell.wav</code>, ja että se sijaitsee projektin juuressa. Yksinkertaisimmillaan äänen soittaminen tapahtuu seuraavasti.
</p>

<pre>
AudioClip leike = new AudioClip("file:bell.wav");
leike.play();
</pre>

<p>
  AudioClip-olion toiminta on riippuvainen JavaFx:n kirjastoista, joten äänitiedosto tulee käynnistää osana JavaFx-ohjelmaa. Allaoleva esimerkki etsii projektin juuresta tiedostoa <code>bell.wav</code> ja luo siitä äänileikkeen. Tämän jälkeen äänileike soitetaan, ja sovellukseen liittyvä (tyhjä) ikkuna avataan. 
</p>  

<% partial 'partials/code_highlight' do %>
import javafx.application.Application;
import static javafx.application.Application.launch;
import javafx.scene.media.AudioClip;
import javafx.stage.Stage;

public class AudioClipApplication extends Application {

    @Override
    public void start(Stage stage) {

        AudioClip leike = new AudioClip("file:bell.wav");
        leike.play();

        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }

}
<% end %>

<% partial 'partials/exercise', locals: { name: 'Hurraa' } do %>

  <p>
    Tehtäväpohjan juurikansiossa on tiedosto <code>Applause-Yannick_Lemieux.wav</code>, joka sisältää hurrausäänen. Tehtävänäsi on luoda sovellus, missä on "Hurraa"-nappi. Kun käyttäjä painaa nappia, sovelluksen tulee soittaa edellä mainittu äänitiedosto.
  </p>

  <img src="/img/material/hurraa-nappi.png"/>

  <p>&nbsp;</p>

  <p>
    <em>
      Äänitiedosto on Yannick Lemieuxin nauhoittama. Tiedosto on lisensoitu Creative Commonsin Attribuutiolisenssillä (<a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">https://creativecommons.org/licenses/by/3.0/</a>).
    </em>
  </p>
<% end %>



<% partial 'partials/hint', locals: { name: 'Mediasoittimen luominen' } do %>

  <p>
    Osoitteessa <a href="https://examples.javacodegeeks.com/desktop-java/javafx/javafx-media-api/" target="_blank">https://examples.javacodegeeks.com/desktop-java/javafx/javafx-media-api/</a> on opas mediasoittimen luomiseen. Jos äänten soittaminen ja käsittely ohjelmallisesti kiinnostaa, oppaaseen kannattaa tutustua.
  </p>
  
<% end %>


<% partial 'partials/material_heading' do %>
  Laajempi sovellus: Asteroids
<% end %>

<p>
  <a href="https://en.wikipedia.org/wiki/Asteroids_(video_game)" target="_blank">Asteroids</a> on <a href="https://en.wikipedia.org/wiki/Atari,_Inc." target="_blank">Atari</a>n kehittämä ja vuonna 1979 julkaisema tietokonepeliklassikko. Pelissä pelaaja ohjaa kolmionmuotoista avaruusalusta, ja pelin tavoitteena on tuhota asteroideja niitä ampuen. 
</p>

<p>
  Seuraavaksi tehdään laajempi esimerkki, missä toteutetaan osa Asteroids-pelistä. Peli on myös kurssin tehtävänä -- tee peli esimerkkiä seuraten annettuun tehtäväpohjaan (esimerkin lopussa).
</p>

<p>
  Peli koostetaan useammassa osassa, jotka ovat seuraavat:
</p>

<ul>
  <li>
    Peliruudun luominen
  </li>
  <li>
    Aluksen luominen
  </li>
  <li>
    Aluksen kääntäminen
  </li>
  <li>
    Aluksen liikuttaminen
  </li>
  <li>
    Asteroidin luominen
  </li>
  <li>
    Aluksen ja asteroidin törmääminen
  </li>
  <li>
    Useampi asteroidi
  </li>
  <li>
    Ruudussa pysyminen
  </li>
  <li>
    Ammukset
  </li>
  <li>
    Pisteiden lisääminen
  </li>
  <li>
    Lisää asteroideja
  </li>
</ul>


<% partial 'partials/material_sub_heading' do %>
  Peliruudun luominen
<% end %>

<p>
  Rakennetaan ohjelma niin, että ohjelman ruutu voi sisältää vapaavalintaisen määrän elementtejä, joiden sijaintiin käytettävä asettelu ei ota kantaa. Tähän sopii hyvin luokka <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Pane.html" target="_blank">Pane</a>. Luokka Pane sisältää edellisestä <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html" target="_blank">ObservableList</a>-tyyppisen listan lapsielementtejä. Listaan pääsee käsiksi Pane-luokan metodin <code>getChildren</code>-kautta.
</p>

<p>
  Alla olevassa esimerkissä on ohjelma, joka luo 300 pikseliä leveän ja 200 pikseliä korkean ruudun. Ruudussa on kohdassa 30, 50 ympyrä, jonka säde on 10 pikseliä. Tietokoneohjelmissa koordinaatiston origo on tyypillisesti ikkunan vasemmassa yläkulmassa. Lisäksi y-koordinaatin arvo kasvaa alaspäin mennessä.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.application.Application;
  import javafx.scene.Scene;
  import javafx.scene.layout.Pane;
  import javafx.scene.shape.Circle;
  import javafx.stage.Stage;

  public class PaneEsimerkki extends Application {

      @Override
      public void start(Stage stage) throws Exception {
          Pane ruutu = new Pane();
          ruutu.setPrefSize(300, 200);
          ruutu.getChildren().add(new Circle(30, 50, 10));
  
          Scene scene = new Scene(ruutu);
          stage.setScene(scene);
          stage.show();
      }

      public static void main(String[] args) {
          launch(args);
      }
  }
<% end %>


<img src="/img/material/pane-circle.png" alt="Ympyrä ikkunassa."/>

<p>&nbsp;</p>

<p>
  Kutsutaan ohjelmaamme AsteroidsSovellukseksi. AsteroidsSovellus mukailee yllä olevaa esimerkkiä. Sovelluksessa ei aseteta ruutuun ympyrää, mutta sovellukselle on asetettu otsikko. Ikkunan leveys on 600 pikseliä ja korkeus 400 pikseliä.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.application.Application;
  import javafx.scene.Scene;
  import javafx.scene.layout.Pane;
  import javafx.stage.Stage;

  public class AsteroidsSovellus extends Application {

      @Override
      public void start(Stage stage) throws Exception {
          Pane ruutu = new Pane();
          ruutu.setPrefSize(600, 400);
  
          Scene scene = new Scene(ruutu);
          stage.setTitle("Asteroids!");
          stage.setScene(scene);
          stage.show();
      }

      public static void main(String[] args) {
          launch(args);
      }
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Aluksen luominen
<% end %>

<p>
  Luodaan ohjelmaan seuraavaksi alus. Asteroidsissa alus on kolmio. Kolmion esittäminen onnistuu monikulmiota kuvaavan <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Polygon.html" target="_blank">Polygon</a>-luokan avulla. Monikulmion kulmat asetetaan Polygon-oliolle joko konstruktorin parametrina tai Polygon-luokan sisältämään listaan. Listaan pääsee käsiksi metodilla <code>getPoints</code>.
</p>

<p>
  Alla olevassa esimerkissä ruutuun on lisätty 100 pikseliä leveä ja 50 pikseliä korkea suunnikas, joka on luotu Polygon-luokan avulla.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public void start(Stage stage) throws Exception {
      Pane ruutu = new Pane();
      ruutu.setPrefSize(300, 200);

      Polygon suunnikas = new Polygon(0, 0, 100, 0, 100, 50, 0, 50);
      ruutu.getChildren().add(suunnikas);
  
      Scene scene = new Scene(ruutu);
      stage.setScene(scene);
      stage.show();
  }
<% end %>

<img src="/img/material/pane-suunnikas.png" alt="Suunnikas ikkunassa."/>

<p>&nbsp;</p>

<p>
  Polygon-olion siirtäminen sopivampaan paikkaan onnistuu sen tarjoamien <code>setTranslateX</code> ja <code>setTranslateY</code>-metodien avulla. Alla olevassa esimerkissä luodaan edellistä esimerkkiä vastaava suunnikas, mutta nyt suunnikasta on siirretty 100 pikseliä oikealle ja 20 pikseliä alas.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public void start(Stage stage) throws Exception {
      Pane ruutu = new Pane();
      ruutu.setPrefSize(300, 200);

      Polygon suunnikas = new Polygon(0, 0, 100, 0, 100, 50, 0, 50);
      suunnikas.setTranslateX(100);
      suunnikas.setTranslateY(20);

      ruutu.getChildren().add(suunnikas);
  
      Scene scene = new Scene(ruutu);
      stage.setScene(scene);
      stage.show();
  }
<% end %>

<img src="/img/material/pane-suunnikas-siirretty.png" alt="Suunnikas ikkunassa. Suunnikasta on siirretty 100 pikseliä oikealle ja 20 pikseliä alas."/>

<p>&nbsp;</p>

<p>
  Luodaan alusta kuvaava kolmio ja lisätään se aiempaan AsteroidsSovellukseemme. Siirretään hahmo ruudun keskelle -- koska ruudun leveys on 600 pikseliä ja ruudun korkeus on 400 pikseliä, hahmoa siirretään 300 pikseliä oikealla ja 200 pikseliä alas.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.application.Application;
  import javafx.scene.Scene;
  import javafx.scene.layout.Pane;
  import javafx.scene.shape.Polygon;
  import javafx.stage.Stage;

  public class AsteroidsSovellus extends Application {

      @Override
      public void start(Stage stage) throws Exception {
          Pane ruutu = new Pane();
          ruutu.setPrefSize(600, 400);

          Polygon alus = new Polygon(-5, -5, 10, 0, -5, 5);
          alus.setTranslateX(300);
          alus.setTranslateY(200);
          
          ruutu.getChildren().add(alus);
  
          Scene scene = new Scene(ruutu);
          stage.setTitle("Asteroids!");
          stage.setScene(scene);
          stage.show();
      }

      public static void main(String[] args) {
          launch(args);
      }
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Aluksen kääntäminen
<% end %>

<p>
  Luokat kuten Polygon ja Circle perivät JavaFx:n <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/Node.html" target="_blank">Node</a>-luokan. Node-luokalla on valmiina muuttuja <code>rotate</code>, joka kuvaa esineen käännöstä asteina. Minkä tahansa Node-luokan perivän olion kääntäminen on siis melko suoraviivaista -- tarvitsee vain käyttää valmista metodia <code>setRotate</code>. Metodille annetaan parametrina käännöksen asteluku. 
</p>

<p>
  Alla olevassa esimerkissä edellä nähtyä esimerkkiä on muunnettu siten, että alusta on käännetty 30 astetta.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public void start(Stage stage) throws Exception {
      Pane ruutu = new Pane();
      ruutu.setPrefSize(600, 400);

      Polygon alus = new Polygon(-5, -5, 10, 0, -5, 5);
      alus.setTranslateX(300);
      alus.setTranslateY(200);
      alus.setRotate(30);

      ruutu.getChildren().add(alus);
  
      Scene scene = new Scene(ruutu);
      stage.setScene(scene);
      stage.show();
  }
<% end %>

<p>
  Todellisuudessa emme kuitenkaan halua tilannetta, missä alus kääntyy vain kerran, vaan tilanteen, missä alusta voi ohjata pelin käynnissäollessa. Tarvitsemme siis tapahtumankuuntelijan, joka kuuntelee näppäimistöä ja kääntää alusta näppäimistön painalluksen yhteydessä.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Näppäimistön kuuntelija, osa 1
<% end %>

<p>
  Ikkunan sisältöä kuvaava <code>Scene</code>-olio tarjoaa metodin <code>setOnKeyPressed</code>, jolle voidaan antaa parametrina tapahtumia käsittelevä olio. Luodaan tapahtumankäsittelijä, joka reagoi näppäimistöön. Näppäimistötapahtumiin liittyy enumeroitu muuttuja <code>KeyCode</code>, joka kertoo painetun napin. Olemme kiinnostuneita napeista vasen (LEFT) ja oikea (RIGHT).
</p>

<p>
  Tehdään ensin testiversio, missä aluksen käännös on yksinkertainen. Jos käyttäjä painaa nuolta vasemmalle, asteeksi asetetaan -30. Jos taas käyttäjä painaa nuolta oikealle, asteeksi asetetaan 30.
</p>

<% partial 'partials/code_highlight' do %>
  scene.setOnKeyPressed(event -&gt; {
      if (event.getCode() == KeyCode.LEFT) {
          alus.setRotate(-30);
      }

      if (event.getCode() == KeyCode.RIGHT) {
          alus.setRotate(30);
      }
  });
<% end %>

<p>
  Jos aluksen sijaan käytössä olisi suunnikas, ohjelman toiminta näyttäisi seuraavanlaiselta.
</p>

<img src="/img/material/pane-polygon-move.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>

<p>
  Käännöksen saa tasaiseksi hyödyntämällä tietoa olemassaolevasta käännöksestä. Alla olevassa esimerkissä alus kääntyy viisi astetta kerrallaan.
</p>

<% partial 'partials/code_highlight' do %>
  scene.setOnKeyPressed(event -&gt; {
      if (event.getCode() == KeyCode.LEFT) {
          alus.setRotate(alus.getRotate() - 5);
      }

      if (event.getCode() == KeyCode.RIGHT) {
          alus.setRotate(alus.getRotate() + 5);
      }
  });
<% end %>

<p>
  Alla kuvattuna vastaava esimerkki, missä aluksen sijaan käännetään suunnikasta.
</p>

<img src="/img/material/pane-polygon-move-rotate.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Näppäimistön kuuntelija, osa 2
<% end %>

<p>
  Edellä kuvattu lähestymistapa mahdollistaa "ihan ok"-tyyppisen kääntämisen. Lähestymistavassa on samalla ongelma -- liike ei ole sulavaa. Kun nappia painaa, alus kääntyy, pitää pienen tauon, ja jatkaa vasta tämän jälkeen kääntymistä.
</p>

<p>
  Tämä liittyy siihen, miten ohjelmat oletuksena käsittelevät näppäinten painalluksen. Jos ohjelma käsittelisi näppäimen painalluksen useana tapahtumana heti kun näppäintä painetaan, muuttuisi esimerkiksi tekstin kirjoittaminen paljon hankalammaksi, sillä hieman pidemmät painallukset tuottaisivat heti useampia merkkejä.
</p>

<p>
  Muutetaan näppäinten käsittelyä siten, että pidämme kirjaa pohjassa olevista napeista. Tämä onnistuu (esimerkiksi) hajautustaulun avulla. Hajautustaulu sisältää avaimena KeyCode-olion, eli nappia kuvaavan olion, ja arvona Boolean-tyyppisen muuttujan. Jos tiettyyn nappiin liittyvän boolean-muuttujan arvo on <code>true</code>, nappi on pohjassa, muulloin nappi ei ole pohjassa.
</p>

<p>
  Nyt huomioidaan myös napin nostaminen, eli <code>onKeyReleased</code>-tapahtuma.
</p>

<% partial 'partials/code_highlight' do %>
  Map&lt;KeyCode, Boolean&gt; painetutNapit = new HashMap&lt;&gt;();

  scene.setOnKeyPressed(event -&gt; {
      painetutNapit.put(event.getCode(), Boolean.TRUE);
  });

  scene.setOnKeyReleased(event -&gt; {
      painetutNapit.put(event.getCode(), Boolean.FALSE);
  });
<% end %>

<p>
  Mutta! Eihän tuolla mikään nyt käännä alusta.
</p>

<p>
  Ei niin. Tarvitsemme vielä kääntämistoiminnallisuuden. Otetaan käyttöön animaatioiden luomiseen tarkoitettu AnimationTimer-luokka, ja annetaan sen vastuulle aluksen kääntäminen mikäli vasen tai oikea nappi on pohjassa.
</p>

<% partial 'partials/code_highlight' do %>
  Map&lt;KeyCode, Boolean&gt; painetutNapit = new HashMap&lt;&gt;();

  scene.setOnKeyPressed(event -&gt; {
      painetutNapit.put(event.getCode(), Boolean.TRUE);
  });

  scene.setOnKeyReleased(event -&gt; {
      painetutNapit.put(event.getCode(), Boolean.FALSE);
  });
  
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
              alus.setRotate(alus.getRotate() - 5);
          }
  
          if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
              alus.setRotate(alus.getRotate() + 5);
          }
      }
  }.start();
<% end %>

<p>
  AnimationTimer-luokan maetodia <code>handle</code> kutsutaan noin 60 kertaa sekunnissa. Nyt kääntyminen on paljon sulavampaa (tosin, sitä ei alla olevasta gif-kuvasta taida huomata...).
</p>


<img src="/img/material/pane-polygon-move-rotate-better.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>


<% partial 'partials/material_sub_heading' do %>
  Aluksen liikuttaminen
<% end %>

<p>
  Alustamme pystyy nyt kääntämään. Lisätään seuraavaksi mahdollisuus liikkumiseen. Alus voi liikkua mihin tahansa ilmansuuntaan, eli liikkeen kuvaamiseen tarvitaan sekä x- että y-koordinaatin arvo. Konkreettinen liikkuminen tapahtuu muuntamalla alusta kuvaavan polygonin sijaintia ohjelman edetessä.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Ensimmäinen yritys
<% end %>

<p>
  Hyödynnetään Javan valmista <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/geometry/Point2D.html" target="_blank">Point2D</a>-luokkaa liikkeen kuvaamiseen -- luokalla on sekä x- että y-koordinaatti.
</p>

<p>
  Ensimmäinen testiversio on liike-muuttujan luominen sekä sen lisääminen AnimationTimer-luokan handle-metodiin.
</p>

<% partial 'partials/code_highlight' do %>
  Point2D liike = new Point2D(1, 0);
<% end %>

<% partial 'partials/code_highlight' do %>
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
              alus.setRotate(alus.getRotate() - 5);
          }
  
          if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
              alus.setRotate(alus.getRotate() + 5);
          }
  
          alus.setTranslateX(alus.getTranslateX() + liike.getX());
      }
  }.start();
<% end %>

<p>
  Huraa! Alus liikkuu (ja sitä voi kääntää). Se tosin katoaa aika nopeasti..
</p>

<img src="/img/material/pane-alus-liikkuu.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>

<p>
  Valitsemamme Point2D luokka muistuttaa hieman String-luokkaa siinä, että se on <em>immutaabeli</em>. Emme voi muuttaa olemassaolevan pisteen arvoja, vaan pisteen metodien kutsuminen palauttaa aina uuden arvon. Tämä on hieman ongelmallista, sillä olioiden arvoja ei saa asettaa uudestaan metodien sisällä -- emme siis voi tehdä esimerkiksi seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          // .. ei toimi ..
          if(painetutNapit.getOrDefault(KeyCode.UP, false)) {
              liike = liike.add(new Point2D(1, 1));
          }
          // ..
      }
  }.start();
<% end %>

<p>
  Metodikutsut ovat kuitenkin sallittuja. Taitaa olla aika refaktoroinnille, eli ohjelman rakenteen selkeyttämiselle..
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Ohjelman refaktorointi
<% end %>

<p>
  Luodaan luokka Alus, joka sisältää Polygon-olion sekä Point2D-olion. Polygon-olio kuvaa alusta, ja Point2D-olio aluksen liikettä. Alus saa konstruktorin parametrina aluksen x- ja y-koordinaatit, jonka lisäksi alusta voi kääntää vasemmalle ja oikealle. 
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.geometry.Point2D;
  import javafx.scene.shape.Polygon;

  public class Alus {

      private Polygon hahmo;
      private Point2D liike;

      public Alus(int x, int y) {
          this.hahmo = new Polygon(-5, -5, 10, 0, -5, 5);
          this.hahmo.setTranslateX(x);
          this.hahmo.setTranslateY(y);

          this.liike = new Point2D(0, 0);
      }

      public Polygon getHahmo() {
          return hahmo;
      }

      public void kaannaVasemmalle() {
          this.hahmo.setRotate(this.hahmo.getRotate() - 5);
      }

      public void kaannaOikealle() {
          this.hahmo.setRotate(this.hahmo.getRotate() - 5);
      }

      public void liikuta() {
          this.hahmo.setTranslateX(this.hahmo.getTranslateX() + this.liike.getX());
          this.hahmo.setTranslateY(this.hahmo.getTranslateY() + this.liike.getY());
      }
  }
<% end %>

<p>
  Refaktoroinnin johdosta sovellusta tulee muuttaa muutamasta kohtaa. Liikettä kuvaavan pisteen sijaan ja alusta kuvaavan monikulmion sijaan luodaan Alus. Tämän lisäksi Pane-oliolle annetaan alukseen liittyvä Polygon-olio, mutta ei itse alus-oliota.
</p>

<% partial 'partials/code_highlight' do %>
  Alus alus = new Alus(150, 100);

  ruutu.getChildren().add(alus.getHahmo());
<% end %>

<p>
  Myös AnimationTimer-olion metodia tulee päivittää siten, että metodissa hyödynnetään aluksen metodeja.
</p>

<% partial 'partials/code_highlight' do %>
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
              alus.kaannaVasemmalle();
          }
  
          if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
              alus.kaannaOikealle();
          }
  
          alus.liiku();
      }
  }.start();
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Toinen yritys
<% end %>

<p>
  Alus liikkuu, mutta aluksen liikettä ei voi vielä muuttaa. Lisätään alukselle kiihdytystoiminnallisuus. Kiihdytyksen tulee toimia niin, että aluksen nopeus kiihtyy aluksen osoittamaan suuntaan. Saamme kiihdytyksen monikulmion asteesta, jonka saa selville metodilla <code>getRotate()</code>. Olemme käyttäneet tätä jo paljon alusta kääntäessä.
</p>

<p>
  Kiihdytyksen suunta saadaan selville sini- ja kosinifunktion avulla. Nämä löytyvät Javan valmiista <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html" target="_blank">Math</a>-luokasta. Metodit saavat parametrina asteen radiaaneina, joten joudumme hyödyntämään myös Math-luokan asteiden radiaaneiksi muuttavaa metodia.
</p>

<% partial 'partials/code_highlight' do %>
  double muutosX = Math.cos(Math.toRadians(<em>kulmaAsteina</em>));
  double muutosY = Math.sin(Math.toRadians(<em>kulmaAsteina</em>));
<% end %>

<p>
  Luokan Alus kiihdyta-metodin ensimmäinen versio on seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public void kiihdyta() {
      double muutosX = Math.cos(Math.toRadians(this.hahmo.getRotate()));
      double muutosY = Math.sin(Math.toRadians(this.hahmo.getRotate()));

      this.liike = this.liike.add(muutosX, muutosY);
  }
<% end %>

<p>
  Lisätään sovellukseen vielä kiihdytystoiminnallisuus. Kiihdytysmetodia kutsutaan kun käyttäjä painaa ylös-nappia. 
</p>

<% partial 'partials/code_highlight' do %>
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
              alus.kaannaVasemmalle();
          }
  
          if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
              alus.kaannaOikealle();
          }
  
          if(painetutNapit.getOrDefault(KeyCode.UP, false)) {
              alus.kiihdyta();
          }

          alus.liiku();
      }
  }.start();
<% end %>

<img src="/img/material/pane-alus-kiihtyy.gif" alt="Alus kiihtyy."/>

<p>&nbsp;</p>

<p>
  Kuten huomaamme, alus kiihtyy. Kiihtyvyys on tosin aika kova, joten sitä on hyvä korjata hieman. Muokataan aluksen kiihdyta-metodia siten, että muutos on vain 5% edellisestä. 
</p>

<% partial 'partials/code_highlight' do %>
  public void kiihdyta() {
      double muutosX = Math.cos(Math.toRadians(this.hahmo.getRotate()));
      double muutosY = Math.sin(Math.toRadians(this.hahmo.getRotate()));

      muutosX *= 0.05;
      muutosY *= 0.05;
  
      this.liike = this.liike.add(muutosX, muutosY);
  }
<% end %>

<p>
  Nyt aluksen ohjaus on jotenkuten mahdollista.
</p>

<img src="/img/material/alus-kiihtyy-fiksummin.gif" alt="Alus kiihtyy siten, että sitä pystyy kontrolloimaan."/>

<p>&nbsp;</p>


<% partial 'partials/material_sub_heading' do %>
  Asteroidin luominen
<% end %>

<p>
  Luodaan seuraavaksi asteroidi. Asteroidilla on muoto, sijainti ja liike.
</p>

<p>
  Hmm..
</p>

<p>
  Oikeastaan lähes täysin samat asiat kuin mitä aluksella on -- vain muoto on erilainen. Tässä kohtaa on hyvä hetki <em>yleistämiselle</em>. Luodaan <em>abstrakti luokka</em> Hahmo, joka saa parametrina muodon ja sijainnin. Huomaat, että toiminnallisuus on lähes täysin kopioitu luokasta <code>Alus</code>.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.geometry.Point2D;
  import javafx.scene.shape.Polygon;

  public abstract class Hahmo {

      private Polygon hahmo;
      private Point2D liike;

      public Hahmo(Polygon monikulmio, int x, int y) {
          this.hahmo = monikulmio;
          this.hahmo.setTranslateX(x);
          this.hahmo.setTranslateY(y);

          this.liike = new Point2D(0, 0);
      }

      public Polygon getHahmo() {
          return hahmo;
      }

      public void kaannaVasemmalle() {
          this.hahmo.setRotate(this.hahmo.getRotate() - 5);
      }

      public void kaannaOikealle() {
          this.hahmo.setRotate(this.hahmo.getRotate() + 5);
      }

      public void liiku() {
          this.hahmo.setTranslateX(this.hahmo.getTranslateX() + this.liike.getX());
          this.hahmo.setTranslateY(this.hahmo.getTranslateY() + this.liike.getY());
      }

      public void kiihdyta() {
          double muutosX = Math.cos(Math.toRadians(this.hahmo.getRotate()));
          double muutosY = Math.sin(Math.toRadians(this.hahmo.getRotate()));

          muutosX *= 0.05;
          muutosY *= 0.05;

          this.liike = this.liike.add(muutosX, muutosY);
      }
  }
<% end %>

<p>
  Muokataan luokkaa Alus siten, että se perii luokan Hahmo.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.scene.shape.Polygon;

  public class Alus extends Hahmo {

      public Alus(int x, int y) {
          super(new Polygon(-5, -5, 10, 0, -5, 5), x, y);
      }
  }
<% end %>

<p>
  Aika suoraviivaista.
</p>

<p>
  Lisätään seuraavaksi luokka Asteroidi. Tehdään ensimmäisestä toteutuksesta suorakulmio ja palataan asteroidin muotoon myöhemmin.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.scene.shape.Polygon;

  public class Asteroidi extends Hahmo {

      public Asteroidi(int x, int y) {
          super(new Polygon(20, -20, 20, 20, -20, 20, -20, -20), x, y);
      }
  }
<% end %>

<p>
  Testataan vielä, että asteroidin voi lisätä sovellukseen.
</p>

<% partial 'partials/code_highlight' do %>
  Pane ruutu = new Pane();
  // koon asetus .. 

  Alus alus = new Alus(150, 100);
  Asteroidi asteroidi = new Asteroidi(50, 50);

  ruutu.getChildren().add(alus.getHahmo());
  ruutu.getChildren().add(asteroidi.getHahmo());
  
  asteroidi.kaannaOikealle();
  asteroidi.kaannaOikealle();
  asteroidi.kiihdyta();
  asteroidi.kiihdyta();
<% end %>

<p>
  Jotta asteroidi liikkuisi, tulee siihen liittyvää liiku-metodia kutsua animaatiossa.
</p>

<% partial 'partials/code_highlight' do %>
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          if (painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
              alus.kaannaVasemmalle();
          }

          if (painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
              alus.kaannaOikealle();
          }

          if (painetutNapit.getOrDefault(KeyCode.UP, false)) {
              alus.kiihdyta();
          }

          alus.liiku();
          asteroidi.liiku();
      }
  }.start();
<% end %>

<p>
  Sovelluksessamme on nyt sekä alus että asteroidi.
</p>

<img src="/img/material/asteroidi-huti.gif" alt="Sovelluksessa sekä alus että yksi asteroidi."/>

<p>&nbsp;</p>


<% partial 'partials/material_sub_heading' do %>
  Aluksen ja asteroidin törmääminen
<% end %>

<p>
  Toteutetaan seuraavaksi aluksen ja asteroidin törmäämisen tarkistaminen. Jos alus törmää asterodiin, kutsutaan AnimationTimer-olion metodia <code>stop</code>, joka lopettaa animaation.
</p>

<p>
  Sekä alus että asteroidi ovat hahmoja. Lisätään luokalle <code>Hahmo</code> metodi, jota käytetään törmäyksen tarkastamiseen. Metodin ensimmäinen versio on sellainen, että hahmo ei koskaan törmää toiseen hahmoon.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean tormaa(Hahmo toinen) {
      return false;
  }
<% end %>

<p>
  Luokalla <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Shape.html" target="_blank">Shape</a>, jonka Polygon <em>myös</em> perii, on törmäyksen tarkastamista varten varsin näppärä metodi. Metodi <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Shape.html#intersect-javafx.scene.shape.Shape-javafx.scene.shape.Shape-" target="_blank">public static Shape intersect(Shape shape1, Shape shape2)</a> palauttaa kahden Shape-tyyppisen olion leikkausalueen.
</p>

<p>
  Jos alue on tyhjä, törmäystä ei ole tapahtunut. Muokataan törmäysten tarkistamista siten, että se hyödyntää edellä mainittua metodia. 
</p>

<% partial 'partials/code_highlight' do %>
  public boolean tormaa(Hahmo toinen) {
      Shape tormaysalue = Shape.intersect(this.hahmo, toinen.getHahmo());
      return tormaysalue.getBoundsInLocal().getWidth() != -1;
  }
<% end %>

<p>
  Lisätään ohjelmaan vielä toiminnallisuus, joka lopettaa sovelluksen törmäyksen yhteydessä.
</p>

<% partial 'partials/code_highlight' do %>
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          if (painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
              alus.kaannaVasemmalle();
          }

          if (painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
              alus.kaannaOikealle();
          }

          if (painetutNapit.getOrDefault(KeyCode.UP, false)) {
              alus.kiihdyta();
          }

          alus.liiku();
          asteroidi.liiku();

          if (alus.tormaa(asteroidi)) {
              stop();
          }
      }
  }.start();
<% end %>

<p>
  Nyt sovellus pysähtyy aluksen ja asteroidin törmätessä.
</p>

<img src="/img/material/asteroids-tormays.gif" alt="Sovellus pysähtyy mikäli alus ja asteroidi törmäävät."/>

<p>&nbsp;</p>



<% partial 'partials/material_sub_heading' do %>
  Useampi asteroidi
<% end %>

<p>
  Muokataan sovellusta seuraavaksi siten, että sovelluksessa on useampia asteroideja. Asteroidit on hyvä esittää listana. Alla olevassa esimerkissä luodaan ensin alus, jonka jälkeen sovellukseen lisätään viisi asteroidia.
</p>

<% partial 'partials/code_highlight' do %>
  Alus alus = new Alus(150, 100);
  List&lt;Asteroidi&gt; asteroidit = new ArrayList&lt;&gt;();
  for (int i = 0; i &lt; 5; i++) {
      Random rnd = new Random();
      Asteroidi asteroidi = new Asteroidi(rnd.nextInt(100), rnd.nextInt(100));
      asteroidit.add(asteroidi);
  }

  ruutu.getChildren().add(alus.getHahmo());
  asteroidit.forEach(asteroidi -&gt; ruutu.getChildren().add(asteroidi.getHahmo()));
<% end %>

<p>
  Muokataan vielä asteroidien piirtämistä ja törmäystoiminnallisuutta siten, että yksittäisen asteroidin sijaan käydään lista läpi.
</p>

<% partial 'partials/code_highlight' do %>
  new AnimationTimer() {

      @Override
      public void handle(long nykyhetki) {
          if (painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
              alus.kaannaVasemmalle();
          }

          if (painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
              alus.kaannaOikealle();
          }

          if (painetutNapit.getOrDefault(KeyCode.UP, false)) {
              alus.kiihdyta();
          }

          alus.liiku();
          asteroidit.forEach(asteroidi -&gt; asteroidi.liiku());

          asteroidit.forEach(asteroidi -&gt; {
              if (alus.tormaa(asteroidi)) {
                  stop();
              }
          });

      }
  }.start();
<% end %>

<p>
  Ohjelman käynnistyessä siinä on nyt useampia asteroideja.
</p>

<img src="/img/material/asteroids-monta-asteroidia.png" alt="Monta asteroidia."/>

<p>&nbsp;</p>

<p>
  Tällä hetkellä jokainen asteroidi näyttää samalta ja liikkuu samalla tavalla. Olisi hienoa, jos asteroideissa olisi vähän vaihtelua. Muokataan Asteroidi-luokkaa siten, että luokalla on erillinen metodi asteroidin rakenteen arpomiseen. Sovitaan, että asteroidit ovat aina viisikulmaisia, ja että niiden perusmuoto on viisikulmio. Luodaan vaihtelua asteroideihin muokkaamalla niiden kulmien sijainteja hieman.
</p>

<p>
  Viisikulmion kulmien laskemiseen saa apua osoitteesta <a href="http://mathworld.wolfram.com/Pentagon.html" target=_blank">http://mathworld.wolfram.com/Pentagon.html</a>. Alla on sovellettu linkin takana olevaa kaavaa, jonka lisäksi monikulmion koko on vaihteleva sekä monikulmion kulmien sijainnit voivat vaihdella hieman.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.Random;
  import javafx.scene.shape.Polygon;

  public class MonikulmioTehdas {

      public Polygon luoMonikulmio() {
          Random rnd = new Random();

          double koko = 10 + rnd.nextInt(10);

          Polygon monikulmio = new Polygon();
          double c1 = Math.cos(Math.PI * 2 / 5);
          double c2 = Math.cos(Math.PI / 5);
          double s1 = Math.sin(Math.PI * 2 / 5);
          double s2 = Math.sin(Math.PI * 4 / 5);

          monikulmio.getPoints().addAll(
              koko, 0.0,
              koko * c1, -1 * koko * s1,
              -1 * koko * c2, -1 * koko * s2,
              -1 * koko * c2, koko * s2,
              koko * c1, koko * s1);

          for (int i = 0; i &lt; monikulmio.getPoints().size(); i++) {
              int muutos = rnd.nextInt(5) - 2;
              monikulmio.getPoints().set(i, monikulmio.getPoints().get(i) + muutos);
          }

          return monikulmio;
      }
  }
<% end %>

<p>
  Muokataan luokkaa Asteroidi siten, että se hyödyntää yllä kuvattua monikulmioiden luomiseen tarkoitettua luokkaa. 
</p>

<% partial 'partials/code_highlight' do %>
  public class Asteroidi extends Hahmo {

      public Asteroidi(int x, int y) {
          super(new MonikulmioTehdas().luoMonikulmio(), x, y);
      }

  }
<% end %>

<p>
  Nyt asteroidit ovat monipuolisempia. 
</p>

<img src="/img/material/asteroids-satunnaiset-monikulmiot.png" alt="Asteroideissa on vaihtelua."/>

<p>&nbsp;</p>

<p>
  Lisätään asteroideille vielä liike ja suunta. Liike ja suunta on osittain määriteltynä luokassa Hahmo, mutta haluamme toimintaan hieman satunnaisuutta. Kun asteroidi luodaan, sen suunnan tulee olla satunnainen luku välillä [0, 360[. Tämän lisäksi asteroidi liikkuu hieman -- liike määritetään satunnaisena määränä kiihdytyskutsuja hahmon luonnin yhteydessä. Lopuksi asteroidilla on myös pieni pyörimisliike. Aina kun asteroidi liikkuu, se myös pyörii hieman.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.Random;

  public class Asteroidi extends Hahmo {

      private double pyorimisliike;

      public Asteroidi(int x, int y) {
          super(new MonikulmioTehdas().luoMonikulmio(), x, y);

          Random rnd = new Random();

          super.getHahmo().setRotate(rnd.nextInt(360));

          int kiihdytystenMaara = 1 + rnd.nextInt(10);
          for (int i = 0; i &lt; kiihdytystenMaara; i++) {
              kiihdyta();
          }

          this.pyorimisliike = 0.5 - rnd.nextDouble();
      }

      @Override
      public void liiku() {
          super.liiku();
          super.getHahmo().setRotate(super.getHahmo().getRotate() + pyorimisliike);
      }
  }
<% end %>

<p>
  Yllä olevassa esimerkissä hyödynnetään perintää myös metodissa <code>liiku</code>. Kun Asteroidin liiku-metodia kutsutaan, metodi kutsuu ensin yläluokassa Hahmo määriteltyä metodia liiku. Tämän jälkeen hahmoa käännetään pyörimisliikkeen verran. Lopputuloksena asteroidilla on pieni pyörimisliike.
</p>


<img src="/img/material/asteroidit-liikkuu.gif" />

<p>&nbsp;</p>


<% partial 'partials/material_sub_heading' do %>
  Ruudussa pysyminen
<% end %>

<p>
  Sovellus on hieman tylsä, sillä asteroidit ja alus voivat siirtyä pois ruudusta. Muokataan sovellusta siten, että asteroidit ja alus pysyvät jatkuvasti ruudussa. Tämä onnistuu muokkaamalla niiden liikkumista siten, että oikealta laidalta poistuttaessa hahmo tulee takaisin vasemmalta laidalta ja toisinpäin. Vastaava toiminnallisuus tarvitaan myös yläkautta ja alakautta poistumiselle. 
</p>

<p>
  Määritellään AsteroidsSovellukselle vakioarvoiset muuttujat leveys ja korkeus. Luokille voidaan määritellä luokkakohtaisia arvoja avainsanan <code>static</code> avulla. Alla määritellään muuttujat <code>LEVEYS</code> ja <code>KORKEUS</code>, joihin voidaan viitata muualta ohjelmasta.
</p>


<% partial 'partials/code_highlight' do %>
  public class AsteroidsSovellus extends Application {

      public static int LEVEYS = 300;
      public static int KORKEUS = 200;

      @Override
      public void start(Stage stage) throws Exception {
          Pane ruutu = new Pane();
          ruutu.setPrefSize(LEVEYS, KORKEUS);

          Alus alus = new Alus(LEVEYS / 2, KORKEUS / 2);
          List&lt;Asteroidi&gt; asteroidit = new ArrayList&lt;&gt;();
          for (int i = 0; i &lt; 5; i++) {
              Random rnd = new Random();
              Asteroidi asteroidi = new Asteroidi(rnd.nextInt(LEVEYS / 3), rnd.nextInt(KORKEUS));
              asteroidit.add(asteroidi);
          }

          ruutu.getChildren().add(alus.getHahmo());
          asteroidit.forEach(asteroidi -&gt; ruutu.getChildren().add(asteroidi.getHahmo()));

  // ...
<% end %>

<p>
  Muuttujat, jotka on määritelty avainsanalla <code>static</code>, eivät liity luokasta tehtäviin olioihin. Jos <code>static</code>-muuttujalla on määre <code>public</code> -- kuten yllä -- voi muuttujaan viitata myös muista luokista. Muokataan luokan Hahmo liiku-metodia siten, että se hyödyntää AsteroidsSovelluksen <em>staattisia muuttujia</em> LEVEYS ja KORKEUS. Alla oleva liiku-metodi tarkastaa, että hahmo on jatkuvasti näkyvillä. 
</p>

<% partial 'partials/code_highlight' do %>
  public void liiku() {
      this.hahmo.setTranslateX(this.hahmo.getTranslateX() + this.liike.getX());
      this.hahmo.setTranslateY(this.hahmo.getTranslateY() + this.liike.getY());

      if (this.hahmo.getTranslateX() &lt; 0) {
          this.hahmo.setTranslateX(this.hahmo.getTranslateX() + AsteroidsSovellus.LEVEYS);
      }

      if (this.hahmo.getTranslateX() &gt; AsteroidsSovellus.LEVEYS) {
          this.hahmo.setTranslateX(this.hahmo.getTranslateX() % AsteroidsSovellus.LEVEYS);
      }

      if (this.hahmo.getTranslateY() &lt; 0) {
          this.hahmo.setTranslateY(this.hahmo.getTranslateY() + AsteroidsSovellus.KORKEUS);
      }

      if (this.hahmo.getTranslateY() &gt; AsteroidsSovellus.KORKEUS) {
          this.hahmo.setTranslateY(this.hahmo.getTranslateY() % AsteroidsSovellus.KORKEUS);
      }
  }
<% end %>

<p>
  Nyt hahmot pysyvät ruudussa.
</p>

<img src="/img/material/asteroids-pysyy-ruudussa.gif" />

<p>&nbsp;</p>

<p>
  Emme ole yllä kuvattuun versioon täysin tyytyväisiä, sillä hahmot saattavat "hypätä" ruudun laidalta toiselle. Hahmon kokoa ei huomioida yllä kuvatussa liikkumistoiminnossa, jolloin hahmon x- tai y-koordinaatti voi olla ulkona ruudusta, vaikka osa hahmosta olisi vielä näkyvissä. Tähän löytyy -- mahdollisesti -- ratkaisu Node-luokalta löytyvästä getBoundsInParent-metodista. Emme tarkastele tätä kuitenkaan sen enempää.
</p>


<% partial 'partials/material_sub_heading' do %>
  Ammukset
<% end %>

<p>
  Asteroids ilman ammuksia olisi pelkkää väistelyä. Lisätään asteroidsiin seuraavaksi ammukset. Ammuksilla on muoto, suunta ja liike. Voimme käyttää Hahmoa myös Ammusten luomiseen. Luodaan Ammus-luokan ensimmäinen versio, missä ammusta kuvataan neliön avulla.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.scene.shape.Polygon;

  public class Ammus extends Hahmo {

      public Ammus(int x, int y) {
          super(new Polygon(2, -2, 2, 2, -2, 2, -2, -2), x, y);
      }

  }
<% end %>

<p>
  Toisin kuin hahmojen ja asteroidien tapauksessa, emme halua että pelin alkutilassa on ammuksia. Määritellään ammuksia varten lista, mutta jätetään se aluksi tyhjäksi.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;Ammus&gt; ammukset = new ArrayList&lt;&gt;();
<% end %>

<p>
  Ammus luodaan kun käyttäjä painaa välilyöntiä. Ammuksen luomisen yhteydessä sen suunnaksi asetetaan aluksen suunta. Luodaan ampumisesta ensimmäinen versio.
</p>

<% partial 'partials/code_highlight' do %>
  if (painetutNapit.getOrDefault(KeyCode.SPACE, false)) {
      // ammutaan
      Ammus ammus = new Ammus((int) alus.getHahmo().getTranslateX(), (int) alus.getHahmo().getTranslateY());
      ammus.getHahmo().setRotate(alus.getHahmo().getRotate());
      ammukset.add(ammus);

      ruutu.getChildren().add(ammus.getHahmo());
  }
<% end %>

<p>
  Ensimmäisessä versiossa alus ampuu kun käyttäjä painaa välilyöntiä, mutta ammukset eivät liiku. Ammukset eivät myöskään törmää muihin hahmoihin.
</p>

<img src="/img/material/alus-ampuu.gif" />

<p>&nbsp;</p>

<p>
  Haluamme, että ammuksen liikettä voidaan muokata. Tällä hetkellä Hahmon muuttuja <code>liike</code> on kuitenkin määritelty private-tyyppiseksi, eikä siihen ole pääsyä minkään metodin kautta. Lisätään luokalle <code>Hahmo</code> metodit <code>getLiike</code> ja <code>setLiike</code>.
</p>

<p>
  Tämän jälkeen ammuksen nopeuden asettaminen on suoraviivaista. Kiihdytetään ammuksen nopeutta hieman (jottei ammus jää koskaan paikalleen), normalisoidaan nopeus (käytännössä nopeutta käsitellään vektorina, jonka pituudeksi asetetaan 1), jonka jälkeen nopeutta kasvatetaan hieman. Tässä nopeus kerrotaan kolmella.
</p>

<% partial 'partials/code_highlight' do %>
  if (painetutNapit.getOrDefault(KeyCode.SPACE, false)) {
      // ammutaan
      Ammus ammus = new Ammus((int) alus.getHahmo().getTranslateX(), (int) alus.getHahmo().getTranslateY());
      ammus.getHahmo().setRotate(alus.getHahmo().getRotate());
      ammukset.add(ammus);
  
      ammus.kiihdyta();
      ammus.setLiike(ammus.getLiike().normalize().multiply(3));
  
      ruutu.getChildren().add(ammus.getHahmo());
  }
<% end %>

<p>
  Lisätään vielä ammusten liikkuminen muiden hahmojen liikkumisen yhteyteen.
</p>

<% partial 'partials/code_highlight' do %>
  alus.liiku();
  asteroidit.forEach(asteroidi -&gt; asteroidi.liiku());
  ammukset.forEach(ammus -&gt; ammus.liiku());
<% end %>

<p>
  Nyt ammukset liikkuvat. Ne eivät kuitenkaan vielä törmää mihinkään, ja niitä on aika.. paljon. Rajataan ammusten määrää ensin hieman -- sovitaan, että ammuksia saa olla kerrallaan korkeintaan 3.
</p>

<% partial 'partials/code_highlight' do %>
  if (painetutNapit.getOrDefault(KeyCode.SPACE, false)
          && ammukset.size() &lt; 3) {
      // ammutaan
      Ammus ammus = new Ammus((int) alus.getHahmo().getTranslateX(), (int) alus.getHahmo().getTranslateY());
      ammus.getHahmo().setRotate(alus.getHahmo().getRotate());
      ammukset.add(ammus);

      ammus.kiihdyta();
      ammus.setLiike(ammus.getLiike().normalize().multiply(3));

      ruutu.getChildren().add(ammus.getHahmo());
  }
<% end %>

<p>
  Lisätään tämän jälkeen ammuksille törmäystoiminnallisuus. Ammukset voivat törmätä asteroideihin. Jos ammus törmää asteroidiin, asteroidi poistetaan sekä piirrettävistä asteroideista että asteroidilistasta.
</p>

<% partial 'partials/code_highlight' do %>
  ammukset.forEach(ammus -&gt; {
      List&lt;Asteroidi&gt; tormatyt = asteroidit.stream()
              .filter(asteroidi -&gt; asteroidi.tormaa(ammus))
              .collect(Collectors.toList());

      tormatyt.stream().forEach(tormatty -&gt; {
          asteroidit.remove(tormatty);
          ruutu.getChildren().remove(tormatty.getHahmo());
      });
  });
<% end %>

<img src="/img/material/ammus-poistaa-asteroidin.gif" />

<p>&nbsp;</p>

<p>
  Ammukset eivät kuitenkaan poistu törmäyksen yhteydessä. Eräs tapa poistaa myös ammukset on esitelty seuraavassa esimerkissä.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;Ammus&gt; poistettavatAmmukset = ammukset.stream().filter(ammus -&gt; {
      List&lt;Asteroidi&gt; tormatyt = asteroidit.stream()
              .filter(asteroidi -&gt; asteroidi.tormaa(ammus))
              .collect(Collectors.toList());

      if(tormatyt.isEmpty()) {
          return false; 
      }
  
      tormatyt.stream().forEach(tormatty -&gt; {
          asteroidit.remove(tormatty);
          ruutu.getChildren().remove(tormatty.getHahmo());
      });
  
      return true;
  }).collect(Collectors.toList());
  
  poistettavatAmmukset.forEach(ammus -&gt; {
      ruutu.getChildren().remove(ammus.getHahmo());
      ammukset.remove(ammus);
  });
<% end %>

<p>
  Vaikka lähestymistapa toimii, voisi sitä ehkäpä parantaa hieman. Kyseessä on käytännössä hahmon "pelissä olemisen" määrittely. Hahmolle voisi esimerkiksi määritellä ominaisuuden "elossa", jota voisi hyödyntää edellä olevan selkeyttämiseen. Kyseisen muuttujan avulla ohjelma selkiytyy hieman.
</p>

<% partial 'partials/code_highlight' do %>
  ammukset.forEach(ammus -&gt; {
      asteroidit.forEach(asteroidi -&gt; {
          if(ammus.tormaa(asteroidi)) {
              ammus.setElossa(false);
              asteroidi.setElossa(false);
          }
      });
  });

  ammukset.stream()
          .filter(ammus -&gt; !ammus.isElossa())
          .forEach(ammus -&gt; ruutu.getChildren().remove(ammus.getHahmo()));
  ammukset.removeAll(ammukset.stream()
          .filter(ammus -&gt; !ammus.isElossa())
          .collect(Collectors.toList()));
  
  asteroidit.stream()
          .filter(asteroidi -&gt; !asteroidi.isElossa())
          .forEach(asteroidi -&gt; ruutu.getChildren().remove(asteroidi.getHahmo()));
  asteroidit.removeAll(asteroidit.stream()
          .filter(asteroidi -&gt; !asteroidi.isElossa())
          .collect(Collectors.toList()));
<% end %>

<p>
  Lopun riviparit ovat myös käytännössä identtiset -- kummatkin käsittelevät hahmoja. Ehkäpä tässä olisi lisäkohta refaktoroinnille.
</p>

<img src="/img/material/ammus-poistuu.gif" />

<p>&nbsp;</p>


<% partial 'partials/material_sub_heading' do %>
  Pisteiden lisääminen
<% end %>

<p>
  Lähes jokaiseen Asteroids-peliin kuuluu pisteiden seuraaminen. Pisteet kirjoitetaan ohjelmaan teksti-oliona, jonka arvoa muutetaan aina pisteiden muuttuessa. Sovitaan, että käyttäjä saa aina 1000 pistettä kun hän saa tuhottua asteroidin. 
</p>

<p>
  Javan tarjoama <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/text/Text.html" target="_blank">Text</a>-luokka on tähän tarkoitukseen mainio. Tekstioliolle määritellään koordinaatti sekä sisältö. Alla olevassa esimerkissä pisteet ovat aina 0.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public void start(Stage stage) throws Exception {
      Pane ruutu = new Pane();
      Text text = new Text(10, 20, "Points: 0");
      ruutu.getChildren().add(text);
  
      Scene scene = new Scene(ruutu);
      stage.setTitle("Asteroids!");
      stage.setScene(scene);
      stage.show();
  }
<% end %>


<img src="/img/material/asteroids-pisteet.png" alt="Ikkuna, jossa on teksti pisteet. Pisteet on nollassa."/>

<p>&nbsp;</p>

<p>
  Yllä olevassa esimerkissä pisteet ovat aina 0. Haluamme kuitenkin muuttuvat pisteet. Yksi näppärä väline tähän on luokka <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" target="_blank">AtomicInteger</a>, joka tarjoaa kokonaisluvun kapseloituna oliona. AtomicInteger mahdollistaa myös pisteiden kasvattamisen metodikutsun yhteydessä.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public void start(Stage stage) throws Exception {
      Pane ruutu = new Pane();
      Text text = new Text(10, 20, "Points: 0");
      ruutu.getChildren().add(text);

      AtomicInteger pisteet = new AtomicInteger();
  
      Scene scene = new Scene(ruutu);
      stage.setTitle("Asteroids!");
      stage.setScene(scene);
      stage.show();


      new AnimationTimer() {

          @Override
          public void handle(long nykyhetki) {
              text.setText("Pisteet: " + pisteet.incrementAndGet());
          }
      }.start();
  }
<% end %>

<img src="/img/material/pisteet-kasvavat.gif" alt="Ikkuna, jossa on teksti pisteet. Pisteet kasvavat."/>

<p>&nbsp;</p>

<p>
  Saamme siis pisteet näkyville ja pisteet kasvamaan. Kytketään pisteiden laskenta asteroids-peliin siten, että pisteitä tulee aina kun pelaajan ammus osuu asteroidiin.
</p>

<p>
  Tämän voi toteuttaa osana ammusten ja asteroidien törmäystä. 
</p>

<% partial 'partials/code_highlight' do %>
  ammukset.forEach(ammus -&gt; {
      asteroidit.forEach(asteroidi -&gt; {
          if(ammus.tormaa(asteroidi)) {
              ammus.setElossa(false);
              asteroidi.setElossa(false);
          }
      });

      if(!ammus.isElossa()) {
          text.setText("Points: " + pisteet.addAndGet(1000));
      } 
  });
<% end %>

<p>
  Nyt, olettaen että pisteiden kasvatus on poistettu animationtimerin alusta, pisteitä saa aina asteroidiin osuttaessa.
</p>

<img src="/img/material/asteroids-ammuskelua.gif" alt="Like a boss."/>

<p>&nbsp;</p>


<% partial 'partials/material_sub_heading' do %>
  Lisää asteroideja
<% end %>

<p>
  Kun osumme asteroideihin, ne katoavat ja ammuttava loppuu kesken. Tämä ei ole hyväksyttävää!
</p>

<p>
  Lisätään ohjelmaan arpomistoiminnallisuus, mikä lisää asteroideja pelin edetessä. Asteroideja lisätään puolen prosentin todennäköisyydellä AnimationTimer-olion kutsujen yhteydessä. Tämän lisäksi uusi asteroidi lisätään vain mikäli se ei heti törmää alukseen.
</p>

<p>
  AnimationTimer-olion metodia handle kutsutaan noin 60 kertaa sekunnissa, joten uusia asteroideja tulee kymmenessä sekunnissa muutamia. Kutsu lisätään AnimationTimer-olion handle-metodin loppuun.
</p>

<% partial 'partials/code_highlight' do %>
  if(Math.random() &lt; 0.005) {
      Asteroidi asteroidi = new Asteroidi(LEVEYS, KORKEUS);
      if(!asteroidi.tormaa(alus)) {
          asteroidit.add(asteroidi);
          ruutu.getChildren().add(asteroidi.getHahmo());
      }
  }
<% end %>


<img src="/img/material/asteroids-ready.gif" alt="Like a boss."/>

<p>&nbsp;</p>


<% partial 'partials/exercise', locals: { name: 'Asteroids (11 osaa)' } do %>

  <p>
    Tehtäväpohjassa on tyhjä ohjelmapohja. Toteuta tehtävään edellistä laajempaa esimerkkiä seuraten Asteroids-peli. Jokainen esimerkin alikohta (esim 2.3 ja 2.4) vastaa yhtä pelin osaa.
  </p>

  <p>
    Toteuta peliin siis kohdat:
  </p>

  <ol>
    <li>
      Peliruudun luominen
    </li>
    <li>
      Aluksen luominen
    </li>
    <li>
      Aluksen kääntäminen
    </li>
    <li>
      Aluksen liikuttaminen
    </li>
    <li>
      Asteroidin luominen
    </li>
    <li>
      Aluksen ja asteroidin törmääminen
    </li>
    <li>
      Useampi asteroidi
    </li>
    <li>
      Ruudussa pysyminen
    </li>
    <li>
      Ammukset
    </li>
    <li>
      Pisteiden lisääminen
    </li>
    <li>
      Lisää asteroideja
    </li>
  </ol>
  
  <p>
    Sitä mukaa kun toteutat peliä tehtäväpohjaan, päivitä luokan AsteroidsSovellus metodia <code>osiaToteutettu</code> palauttamaan valmiiksi saamasi osan numero. Voit palauttaa tehtävän vaikket tekisikään kaikkia osia, jolloin saat pisteitä tehtävän niistä osista, jotka olet tehnyt.
  </p>

  <p>
    Esimerkiksi, kun olet saanut aluksen kääntämisen toimimaan, olet vaiheessa 3, jolloin metodin <code>osiaToteutettu</code> tulisi palautta arvo <code>3</code>.
  </p>

  <p>
    Leppoisaa vääntöä! Kun saat tehtävän valmiiksi, saat toki jatkaa. Peliin voi lisätä esimerkisi ääniä ja erilaisia hahmoja -- miten esimerkiksi Ufot toimisivat pelissä? Voisivatko ne yrittää ampua hahmon alusta?
  </p>

<% end %>


<% partial 'partials/material_heading' do %>
  Sovellukset ohjelmointiympäristön ulkopuolella
<% end %>


<p>
  Sovelluksemme ovat tähän mennessä toimineet vain ohjelmointiympäristössä. Tämä ei kuitenkaan ole käytännössä totta, sillä ohjelman käynnistäminen ohjelmointiympäristössä vastaa melko vahvasti sen käynnistämistä ohjelmointiympäristön ulkopuolella. Voimme määritellä luokan, jossa olevaa metodia <code>public static void main</code> käytetään ohjelman käynnistämiseen. 
</p>

<p>
  Mavenia ja JavaFX:ää käyttävien projektien "paketointiin" löytyy valmis Maven-liitännäinen <a href="http://javafx-maven-plugin.github.io/" target="_blank">http://javafx-maven-plugin.github.io/</a>. Liitännäinen tarjoaa muunmuassa mahdollisuuden sovelluksen paketointiin jar-tiedostoksi, minkä voi suorittaa suoraan komentoriviltä.
</p>

<p>
  Liitännäisen käyttöönotto tapahtuu lisäämällä projektin <code>pom.xml</code>-tiedostoon tieto ohjelman käännöksen aikana suoritettavasta liitännäisestä. 
</p>

<% partial 'partials/xml_highlight' do %>
  &lt;build&gt;
    &lt;plugins&gt;
      
      &lt;plugin&gt;
        &lt;groupId&gt;com.zenjava&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;8.6.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;mainClass&gt;asteroids.AsteroidsSovellus&lt;/mainClass&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      
    &lt;/plugins&gt;
  &lt;/build&gt;
<% end %>

<p>
  Nyt kun sovelluksen paketoi erillisen <code>mvn jfx:jar</code>-kutsun avulla, projektista luodaan jar-tiedosto, jonka voi käynnistää komentoriviltä.
</p>

<p>
Kutsun voi antaa NetBeansissa klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Run Maven -&gt; Goals...". Tämän jälkeen avautuvaan ikkunaan syötetään kohtaan "Goals" merkkijono "jfx:jar". Kun tämän jälkeen painetaan ok, sovelluksesta luodaan valmis paketti.
</p>


<p>
  NetBeansin Output-välilehti antaa vinkkiä sovelluksen suorittamisesta.
</p>

<% partial 'partials/sample_output' do %>
  // ...
  --- javafx-maven-plugin:8.6.0:jar (default-cli) @ Osa13_04.Asteroids ---
  Building JavaFX JAR for application
  Adding 'deploy' directory to Mojo classpath: ...
<% end %>


<p>
  Jos kaikki menee hyvin, sovelluksen kansiosta <code>target</code> löytyy alikansio <code>jfx</code>. Tämän alla on kansio <code>app</code>, joka sisältää suoritettavan jar-päätteisen tiedoston.
</p>

<p>
  Nyt sovelluksen voi käynnistää komentoriviltä. Kun annamme komentorivillä komennon "java -jar" -- eli, käynnistä jar-paketoitu ohjelma Javalla, jota seuraa yllä luotu jar-tiedosto, käynnistyy ohjelma.
</p>

<pre>
$ java -jar "/<em>polku</em>/osa13/Osa13_04.Asteroids/target/jfx/app/Osa13_04.Asteroids-1.0-SNAPSHOT.jar"
</pre>

<% partial 'partials/hint', locals: { name: 'Asennettavan sovelluksen luominen' } do %>

  <p>
    Edellä kuvattu menetelmä paketoi sovelluksen suoritettavaan muotoon. Tietokoneiden normaalikäyttäjät eivät kuitenkaan ole tottuneet sovellusten käynnistämiseen komentoriviltä -- osalla heistä ei myöskään ole Javaa asennettuna, jonka edellinen komento vaatii.
  </p>

  <p>
    Sovellusten paketointiin ja tuotteistamiseen ym. syvennytään laajemmin mm. kursseilla ohjelmistotekniikan menetelmät ja ohjelmistotuotanto.
  </p>
  
<% end %>


<% partial 'partials/exercise', locals: { name: '2048 (5 osaa)' } do %>

  <p>
    <a href="https://en.wikipedia.org/wiki/2048_(video_game)" target="_blank" rel="noopener">2048</a> on suosittu peli. Peliä pelataan 4x4 -kokoisessa lukuja sisältävässä ruudukossa, ja siinä on neljä mahdollista siirtoa: (o)ikealle, (a)las, (v)asemmalle ja (y)lös. Jokainen siirto siirtää kaikkia ruudukossa olevia arvoja niin paljon haluttuun suuntaan kuin mahdollista. Jos kahdessa vierekkäisessä ruudussa on sama arvo, yhdistetään ruutujen arvot yhteen. Esimerkiksi:
  </p>

  <pre>

2 0 2 0
0 0 0 1
0 1 0 0
0 0 0 0
&gt; o

0 0 0 4
0 0 0 1
0 0 0 1
0 1 0 0
  </pre>

  <p>
    Aina kun pelaaja tekee siirron, satunnaiseen nolla-arvoiseen kohtaan arvotaan uusi luku. Peli loppuu kun yhdessä ruuduista on luku 2048 tai siirtäminen ei enää onnistu. Alla esimerkki pelin kulusta.
  </p>

  <pre>
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0

&gt; o
0 0 0 1
0 0 0 0
0 0 0 0
0 1 0 0

&gt; o
0 0 0 1
0 0 0 0
0 0 0 1
0 0 0 1

&gt; a
0 0 0 0
0 0 0 0
1 0 0 2
0 0 0 1

&gt; a
1 0 0 0
0 0 0 0
0 0 0 2
1 0 0 1

&gt; v
1 0 0 0
0 0 0 0
2 0 0 0
2 1 0 0

&gt; y
1 1 0 0
4 0 0 0
0 0 0 0
0 1 0 0

&gt; v
2 0 0 0
4 0 0 0
0 0 0 0
1 0 1 0

&gt; v
2 0 0 0
4 1 0 0
0 0 0 0
2 0 0 0

&gt;
  </pre>

  <p>
    Tässä tehtävässä rakennat pelin toimintaan tarvittua ydintoiminnallisuutta. Tehtävässä kerrataan myös toistolauseiden ja indeksien käyttöä.
  </p>

  <h2>Peliruudukko</h2>

  <p>
    Luo pakkaukseen sovellus luokka Peliruudukko. Luokalla tulee olla parametriton konstruktori, joka luo 4x4-kokoisen ruudukon, ja jonka vasemmassa yläkulmassa on arvo 1. Oleta, että kaksiulotteisen taulukon ensimmäinen indeksi kuvaa y-koordinaattia, ja toinen indeksi x-koordinaattia. Oleta lisäksi, että y-koordinaatti kasvaa alaspäin. Vasen yläkulma on siis kohdassa taulukko[0][0] ja vasen alakulma kohdassa taulukko[3][0] -- olettaen, että taulukon koko on 4.
  </p>

  <p>
    Lisää luokalle myös metodit public int[][] getTaulukko(), joka palauttaa pelin sisäisen tilan, ja public void setTaulukko(int[][] taulukko), jolla voi asettaa pelin sisäisen tilan.
  </p>

  <h2>Siirrä oikealle</h2>

  <p>
    Tee tämän jälkeen peliruudukolle metodi public void siirraOikealle(), joka siirtää jokaisen rivin palat oikealle. Metodi yhdistää tarvittaessa myös samanarvoiset muuttujat. Alla muutamia esimerkkeja.
  </p>

  <pre>
1 1 1 1
1 1 0 1
1 1 1 0
1 0 1 1

&gt; o
0 0 0 4
0 0 1 2
0 0 1 2
0 0 1 2
  </pre>

  <pre>
1 0 0 1
0 1 0 1
2 2 4 0
0 1 0 0

&gt; o
0 0 0 2
0 0 0 2
0 0 0 8
0 0 0 1
  </pre>

  <h2>Siirrä ylös ja siirrä alas</h2>

  <p>
    Tee seuraavaksi peliruudukolle metodit public void siirraYlos(), joka siirtää jokaisen rivin palat ylös, ja public void siirraAlas(), joka siirtää jokaisen rivin palat alas. Metodi yhdistää tarvittaessa myös samanarvoiset muuttujat.
  </p>

  <h2>Siirrä vasemmalle ja pelin loppuminen</h2>

  <p>
    Tee seuraavaksi peliruudukolle metodi public void siirraVasemmalle(), joka siirtää jokaisen rivin palat vasemmalle. Kun metodi siirraVasemmalle on valmis, toteuta sovellukseen metodi public boolean peliKaynnissa(), joka palauttaa tiedon pelin jatkumisesta.
  </p>

  <p>
    Peli jatkuu jos (1) pelissä on yksikin ruutu, jossa on arvo 0, tai (2) kaksi pelin vierekkaista (vaaka- tai pystytasossa) ruutua ovat samanarvoiset.
  </p>

  <h2>Tekstikayttoliittyma ja uuden luvun arpominen</h2>

  <p>
    Tee lopulta pelille tekstikäyttöliittymä. Pelin tulee käynnistyä kun luokassa Peli olevaa main-metodia kutsutaan. Pelaajalle tulee tarjota vaihtoehdot o, v, y, a, x, missä o on oikealle, v on vasemmalle, y on ylös, a on alas, ja x on lopeta. Jokaisen siirron -- paitsi pelin lopettavan x:n -- jälkeen taulukon satunnaiseen tyhjään kohtaan tulee lisätä luku 1. Alla on esimerkki tekstikäyttöliittymän toiminnasta.
  </p>

  <% partial 'partials/sample_output' do %>
    1 0 0 0
    0 0 0 0
    0 0 0 0
    0 0 0 0

    &gt; <font color="red">o</font>
    0 0 0 1
    0 0 0 0
    0 0 0 1
    0 0 0 0

    &gt; <font color="red">y</font>
    0 0 0 2
    1 0 0 0
    0 0 0 0
    0 0 0 0

    &gt; <font color="red">v</font>
    2 0 1 0
    1 0 0 0
    0 0 0 0
    0 0 0 0

    &gt; <font color="red">o</font>
    0 0 2 1
    0 0 0 1
    0 1 0 0
    0 0 0 0

    &gt; <font color="red">y</font>
    0 1 2 2
    0 0 0 0
    0 0 0 0
    0 0 1 0

    &gt; <font color="red">o</font>
    0 0 1 4
    0 0 0 0
    0 0 0 1
    0 0 0 1

    &gt; <font color="red">x</font>
  <% end %>

<% end %>



<% partial 'partials/hint', locals: { name: 'Mitä seuraavaksi?' } do %>

  <p>
    Tämän kurssin jälkeen on hyvä ottaa kurssit Tietokantojen perusteet sekä Tietorakenteet ja algoritmit. Kurssin tietokantojen perusteet jälkeen kannattaa ottaa kurssi Ohjelmistotekniikan menetelmät. Jos kurssia Tietokoneen toiminta ei ole vielä suorittanut, myös sen ottaminen on suositeltavaa. Muistathan, että kurssin Tietorakenteet ja algoritmit esitietovaatimuksena on kurssi Johdatus yliopistomatematiikkaan.
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  ArrayList ja Hajautustaulu
<% end %>

<p>
  ArrayList ja Hajautustaulu ovat ohjemoinnissa hyvin yleisesti käytettyjä tietorakenteita. Tarkastellaan tässä niiden todellista toteutusta -- alla rakennetaan askeleittain ensin ArrayListiä imitoiva tietorakenne <code>Lista</code>, jota hyödynnetään sitten tietorakenteen <code>Hajautustaulu</code> tekemisessä.
</p>

<% partial 'partials/material_sub_heading' do %>
  Geneerinen tyyppi
<% end %>


<p>
  Olemme listoihin tutustumisesta lähtien kertoneet erilaisille tietorakenteille niiden sisältämän arvon tyypin. Esimerkiksi String-tyyppisiä olioita sisältävä lista on esitelty muodossa <code>ArrayList&lt;String&gt;</code>. Tässä on kuitenkin ihmetyttänyt se, että miten ihmeessä listat ja muutkin tietorakenteet voivat sisältää erityyppisiä oliota.
</p>

<p>
  Geneerisyys (<em>generics</em>) liittyy olioita säilövien luokkien tapaan säilöä vapaavalintaisen tyyppisiä olioita. Vapaavalintaisuus perustuu luokkien määrittelyssä käytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan määritellä <em>olion luontivaiheessa</em> valittavia tyyppejä. Luokan geneerisyys määritellään antamalla luokan nimen jälkeen haluttu määrä luokan tyyppiparametreja pienempi kuin ja suurempi kuin -merkkien väliin. Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden minkälaisen tahansa olion.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;T&gt; {
  private T alkio;

  public void asetaArvo(T alkio) {
  this.alkio = alkio;
  }

  public T haeArvo() {
  return alkio;
  }
  }
<% end %>

<p>
  Määrittely <code>public class Lokero&lt;T&gt;</code> kertoo että luokalle <code>Lokero</code> tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun jälkeen kaikki olion sisäiset muuttujat tulevat olemaan kutsun yhteydessä annettua tyyppiä. Luodaan merkkijonon tallentava lokero.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;String&gt; merkkijono = new Lokero&lt;&gt;();
  merkkijono.asetaArvo(":)");

  System.out.println(merkkijono.haeArvo());<% end %>

<% partial 'partials/sample_output' do %>
  :)
<% end %>

<p>
  Yllä olevalla ohjelmalla merkkijono-nimisen <code>Lokero</code>-olion <em>ajonaikainen</em> toteutus on seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;String&gt; {
  private String alkio;

  public void asetaArvo(String alkio) {
  this.alkio = alkio;
  }

  public String haeArvo() {
  return alkio;
  }
  }
<% end %>

<p>
  Tyyppiparametria vaihtamalla voidaan luoda myös muuntyyppisiä olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;Integer&gt; luku = new Lokero&lt;&gt;();
  luku.asetaArvo(5);

  System.out.println(luku.haeArvo());<% end %>


<% partial 'partials/sample_output' do %>
  5
<% end %>

<p>
  Yllä olevalla esimerkillä <code>luku</code>-nimisen Lokeron toteutus olisi ajonaikaisesti taas seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;Integer&gt; {
  private Integer alkio;

  public void asetaArvo(Integer alkio) {
  this.alkio = alkio;
  }

  public Integer haeArvo() {
  return alkio;
  }
  }
<% end %>

<p>
  Samalla tavalla ohjelmoija voisi toteuttaa esimerkiksi luokan <code>Pari</code>, mihin voi laittaa kaksi halutun tyyppistä oliota.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;T, K&gt; {
  private T eka;
  private K toka;

  public void asetaArvot(T eka, K toka) {
  this.eka = eka;
  this.toka = toka;
  }

  public T haeEka() {
  return this.eka;
  }

  public K haeToka() {
  return this.toka;
  }
  }
<% end %>


<p>
  Huomattava osa Javan tietorakenteista mahdollistaa eri tyyppisten muuttujien käytön. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  Map&lt;String, String&gt; avainArvoParit = new HashMap&lt;&gt;();
<% end %>

<p>
  Jatkossa kun näet esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code> tiedät että sen sisäisessä rakenteessa on käytetty geneeristä tyyppiparametria. Sama periaate löytyy esimerkiksi rajapinnassa Comparable.
</p>


<% partial 'partials/material_sub_heading' do %>
  Listarakenne
<% end %>

<p>
  Tarkastellaan erästä tapaa Javan tarjoaman ArrayList-tietorakenteen toteuttamiseen. Javan ArrayList hyödyntää sisäisesti taulukkoa, mikä on määritelty generisen tyyppiseksi -- tämän takia listalle saa lisätä käytännössä minkä tyyppisiä arvoja tahansa. Lista tarjoaa useita metodeja, joista tämän esimerkin kannalta oleellisia ovat <code>add</code> eli lisääminen, <code>contains</code> eli olemassaolon tarkastaminen, <code>remove</code> eli poistaminen sekä <code>get</code>, eli tietystä indeksistä hakeminen.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.add("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.remove("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan luominen
<% end %>

<p>
  Luodaan luokka <code>Lista</code>. Listarakenne sisältää geneerisen taulukon -- eli taulukon, jonka alkioiden tyyppi määräytyy ajonaikaisesti tyyppiparametreista. Asetetaan taulukon alkukooksi <code>10</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {
  private T[] arvot;

  public Lista() {
  this.arvot = (T[]) new Object[10];
  }
  }
<% end %>

<p>
  Lista kapseloi taulukon. Alkutilanteessa jokainen taulukon indeksi sisältää <code>null</code>-viitteen.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle
<% end %>

<p>
  Lisätään luokalle metodi <code>public void lisaa(T arvo)</code>, mikä mahdollistaa arvojen lisäämisen listalle. Luodaan luokalle tätä varten erillinen kokonaislukumuuttuja, joka pitää kirjaa taulukon ensimmäisestä tyhjästä paikasta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {

  private T[] arvot;
  private int arvoja;

  public Lista() {
  this.arvot = (T[]) new Object[10];
  this.arvoja = 0;
  }

  public void lisaa(T arvo) {
  this.arvot[this.arvoja] = arvo;
  this.arvoja++;
  }
  }
<% end %>

<p>
  Nyt arvojen lisääminen listalle onnistuu -- tai, ainakin listan luominen ja metodin kutsuminen onnistuu -- emme vielä voi testata ovatko arvot todellisuudessa listalla.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle, osa 2
<% end %>

<p>
  Edellä kuvatussa <code>lisaa</code>-metodissa on pieni ongelma. Ongelma ilmenee kun seuraava ohjelmakoodi suoritetaan.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  for (int i = 0; i &lt; 11; i++) {
  lista.lisaa("hei");
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
  at tietorakenteita.Lista.lisaa(Lista.java:14)
  at tietorakenteita.Ohjelma.main(Ohjelma.java:8)
<% end %>

<p>
  Listan koko ei kasva. Eräs ArrayList-luokan oleellisimmista toiminnallisuuksista on se, että sen koko kasvaa aina tarvittaessa -- ohjelmoijan ei siis tarvitse varoa listan täyttymistä.
</p>

<p>
  Lisätään ohjelmaan listan koon kasvattamiseen liittyvä toiminnallisuus. Listan kokoa kasvatetaan aina jos täyteen listaan yritetään lisätä arvo. Kasvattaminen toteutetaan käytännössä siten, että luomme uuden taulukon, mihin vanhan taulukon arvot kopioidaan. Tämän jälkeen vanha taulukko jätetään heitteille, ja uudesta taulukosta tulee olion käyttämä taulukko.
</p>

<p>
  Javan kuudennessa versiossa uuden taulukon koko lasketaan kaavalla <code>vanhakoko * 3 / 2 + 1</code>. Hyödynnetään samaa kaavaa omassa toteutuksessamme. Luodaan kasvattamista varten erillinen metodi <code>kasvata</code>, joka on vain luokan omien metodien käytössä (eli sillä on <code>private</code>-näkyvyys).
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
  T[] uusi = (T[]) new Object[this.arvot.length * 3 / 2 + 1];
  for (int i = 0; i &lt; this.arvot.length; i++) {
  uusi[i] = this.arvot[i];
  }
  
  this.arvot = uusi;
  }
<% end %>

<p>
  Toteutus luo uuden taulukon, jonka koko on noin 1.5-kertainen vanhaan taulukkoon verrattuna. Tämän jälkeen kaikki vanhan taulukon alkiot kopioidaan uuteen taulukkoon ja lopulta olion <code>arvot</code>-muuttujan -- eli taulukon -- arvoksi asetetaan uusi taulukko.
</p>

<p>
  Muokataan vielä metodia <code>lisaa</code> siten, että taulukon kokoa kasvatetaan tarvittaessa.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(T arvo) {
  if(this.arvoja == this.arvot.length) {
  kasvata();
  }
  
  this.arvot[this.arvoja] = arvo;
  this.arvoja++;
  }
<% end %>

<p>
  Nyt arvoja voi lisätä listalle lähes rajattomasti.
</p>


<% partial 'partials/hint', locals: { name: 'Edellä kuvatun kasvatusmenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi kasvatuksen yhteydessä jokaisen vanhan taulukon arvon uuteen taulukkoon. Jos taulukossa on esimerkiksi kaksi miljoonaa alkiota, kopiointi käy kaksi miljoonaa alkiota läpi.
  </p>

  <p>
    Menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon olemassaolon tarkastaminen
<% end %>

<p>
  Luodaan listalle seuraavaksi metodi <code>public boolean sisaltaa(T arvo)</code>, minkä avulla voidaan tarkistaa onko alkio listalla. Hyödynnetään tässä tietoa siitä, että jokainen Javan olio -- riippumatta sen tyypistä -- perii Object-luokan (tai on Object-tyyppinen). Tämän takia jokaisella oliolla on metodi <code>public boolean equals(Object object)</code>, jota voidaan käyttää yhtäsuuruuden tarkasteluun.
</p>

<p>
  Luokan <code>Lista</code> muuttuja <code>arvoja</code> sisältää tiedon arvojen tämän hetkisestä lukumäärästä. Voimme siis toteuttaa <code>sisaltaa</code>-metodin siten, että tarkastelemme vain ne listan indeksit, joissa on arvoja.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (this.arvot[i].equals(arvo)) {
  return true;
  }
  }
  
  return false;
  }
<% end %>

<p>
  Edellä esitetty menetelmä olettaa, että käyttäjä ei lisää listalle <code>null</code>-viitettä. Jos haluamme, että käyttäjä saa lisätä listalle <code>null</code>-viitteen (ja <code>null</code>-viitteen olemassaoloa saa myös hakea), tulee ohjelmaa muokata hieman. Tällöin <code>sisaltaa</code>-metodin eräs mahdollinen toteutus olisi seuraava.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  return true;
  }
  }
  
  return false;
  }
<% end %>

<p>
  <em>Yllä oleva esimerkki ei kuitenkaan toimi. Pohdi miksei ja mieti minkälaisella ratkaisulla saisit <code>null</code>-viitteiden käsittelyn toimimaan.
  </em>
</p>

<p>
  Ohjelmassa on nyt mahdollisuus listalla olevien alkioiden olemassaolon tarkasteluun.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>


<% partial 'partials/sample_output' do %>
  false
  true
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon poistaminen
<% end %>

<p>
  Toteuttamallemme listalle voi nyt lisätä arvoja, jonka lisäksi arvon olemassaolon voi tarkastaa. Toteutetaan vielä arvon poistaminen. Toteutetaan metodi <code>public void poista(T arvo)</code>, joka poistaa listalta <em>yhden</em> <code>arvo</code>-arvoisen alkion.
</p>

<p>
  Yksinkertainen toteutus olisi seuraava.
</p>


<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  this.arvot[i] = null;
  this.arvoja--;
  return true;
  }
  }
  
  return false;
  }
<% end %>

<p>
  Yllä oleva lähestymistapa on kuitenkin ongelmallinen, sillä se jättää listalle "tyhjiä" kohtia -- olettaen, että uudet arvot lisätään aina listan loppuun.
</p>

<p>
  Ongelman voi ratkaista useammalla tavalla, joista yksi on siirtää jokaista poistettua arvoa seuraavaa arvoa vasemmalle. Lisätään tämä toiminnallisuus ohjelmaan.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
  boolean loytyi = false;
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (loytyi) {
  this.arvot[i - 1] = this.arvot[i];
  } else if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  this.arvoja--;
  loytyi = true;
  }
  }
  }
<% end %>

<p>
  Emme ole kovin tyytyväisiä edelliseen ratkaisuun, sillä siinä tehdään monta asiaa samaan aikaan. Metodissa sekä etsitään alkiota että siirretään alkioita. Pilkotaan toiminnallisuus kahteen erilliseen metodiin: <code>private int arvonIndeksi(T arvo)</code>, joka etsii parametrina annetun arvon indeksin, sekä <code>private void siirraVasemmalle(int indeksista)</code>, joka siirtää annetusta indeksistä lähtien alkioita yhden vasemmalle.
</p>

<p>
  Toteutetaan ensin metodi <code>private int arvonIndeksi(T arvo)</code>, joka etsii annetun arvon indeksin. Metodi palauttaa negatiivisen luvun mikäli arvoa ei löydy.
</p>

<% partial 'partials/code_highlight' do %>
  private int arvonIndeksi(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  return i;
  }
  }

  return -1;
  }
<% end %>

<p>
  Toteutetaan tämän jälkeen metodi <code>private void siirraVasemmalle(int indeksistaLahtien)</code>, joka siirtää arvoja annetusta indeksistä lähtien vasemmalle.
</p>

<% partial 'partials/code_highlight' do %>
  private void siirraVasemmalle(int indeksistaLahtien) {
  for (int i = indeksistaLahtien; i &lt; this.arvoja - 1; i++) {
  this.arvot[i] = this.arvot[i + 1];
  }
  }
<% end %>

<p>
  Nyt metodi <code>poista</code> voidaan toteuttaa edellisten avulla hieman selkokielisemmäksi.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
  int arvonIndeksi = arvonIndeksi(arvo);
  if (arvonIndeksi &lt; 0) {
  return; // ei löydy
  }

  siirraVasemmalle(arvonIndeksi);
  this.arvoja--;
  }
<% end %>

<% partial 'partials/hint', locals: { name: 'Edellä kuvatun poistomenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi poiston yhteydessä jokaisen poistettua alkiota seuraavan alkion vasemmalle. Pohdi toteutuksen tehokkuutta tilanteessa, missä listaa käytetään jonona.
  </p>

  <p>
    Tämänkin menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>

<p>
  Luokassa lista on vieläkin vähän toistoa. Metodi <code>sisaltaa</code> on hyvin samankaltainen metodin <code>arvonIndeksi</code> kanssa. Muokataan vielä metodia <code>sisaltaa</code> siten, että se toteutetaan metodin <code>arvonIndeksi</code> avulla.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
  return arvonIndeksi(arvo) &gt;= 0;
  }
<% end %>

<p>
  Nyt käytössämme on lista, joka tarjoaa metodit <code>lisaa</code>, <code>sisaltaa</code>, ja <code>poista</code>. Lista myös kasvaa tarvittaessa. Listan toteutusta voisi toki vielä kehittää esimerkiksi lisäämällä toiminnallisuuden, mikä pienentää listan kokoa jos arvojen määrä pienenee hyvin pieneksi.
</p>


<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Kohdasta hakeminen
<% end %>

<p>
  Lisätään listalle vielä metodi <code>public T arvo(int indeksi)</code>, joka palauttaa listan tietyssä indeksissä sijaitsevan arvon. Mikäli ohjelmoija hakee arvoa listan ulkopuolelta, heitetään virhe <code>IndexOutOfBoundsException</code>. 
</p>

<% partial 'partials/code_highlight' do %>
  public T arvo(int indeksi) {
  if (indeksi &lt; 0 || indeksi &gt;= this.arvoja) {
  throw new ArrayIndexOutOfBoundsException("Indeksi " + indeksi + " alueen [0, " + this.arvoja + "[ ulkopuolella.");
  }

  return this.arvot[indeksi];
  }
<% end %>

<p>
  Metodi ei ole sellaisenaan kovin hyödyllinen, sillä ohjelmoijalla ei ole tietoa arvojen indekseistä. Muutetaan vielä metodi <code>arvonIndeksi(T arvo)</code> kaikkien käytettäväksi, eli vaihdetaan sen näkyvyysmääre <code>private</code> muotoon <code>public</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public int arvonIndeksi(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  return i;
  }
  }

  return -1;
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  int indeksi = lista.arvonIndeksi("hei");
  System.out.println(indeksi);
  System.out.println(lista.arvo(indeksi));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  0
  hei
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan koko
<% end %>

<p>
  Lisätään listalle vielä metodi listan koon tarkastamiseen. Listan koon saa selville muuttujasta <code>arvoja</code>. 
</p> 

<% partial 'partials/code_highlight' do %>
  public int koko() {
  return this.arvoja;
  }
<% end %>

<p>
  Nyt listan alkioiden läpikäynti onnistuu mm. for-lauseella.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");

  for(int i = 0; i &lt; lista.koko(); i++) {
  System.out.println(lista.arvo(i)); 
  }
<% end %>

<% partial 'partials/sample_output' do %>
  hei
  maailma
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hajautustaulu
<% end %>

<p>
  Hajautustaulu on toteutettu taulukkona, missä jokainen alkio sisältää listan. Listalle tallennetaan (avain,arvo)-pareja. Käyttäjä voi hakea hajautustaulusta arvoja avaimen perusteella, ja toisaalta käyttäjä voi lisätä hajautustauluun avain-arvo -pareja. Kukin avain voi esiintyä hajautustaulussa korkeintaan kerran.
</p>

<p>
  Hajautustaulun toiminta perustuu avaimen hajautusarvoon. Kun hajautustauluun lisätään (avain,arvo)-pari, lasketaan avaimeen liittyvä hajautusarvo. Hajautusarvo määrää hajautustaulun sisäisen taulukon indeksin, missä olevaan listaan (avain,arvo)-pari lisätään.
</p>

<p>
  Hahmotellaan hajautustaulun toimintaa.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Avain-arvo -pari
<% end %>

<p>
  Luodaan ensin avain-arvo -paria kuvaava luokka <code>Pari</code>. Haluamme tehdä hajautustaulusta mahdollisimman yleiskäyttöisen, joten avaimen ja arvon tyyppi määrätään ajonaikaisesti. Pari sisältää avaimen ja arvon sekä niihin liittyvät get- ja set-metodit.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;K, V&gt; {

  private K avain;
  private V arvo;

  public Pari(K avain, V arvo) {
  this.avain = avain;
  this.arvo = arvo;
  }

  public K getAvain() {
  return avain;
  }

  public void setAvain(K avain) {
  this.avain = avain;
  }

  public V getArvo() {
  return arvo;
  }

  public void setArvo(V arvo) {
  this.arvo = arvo;
  }

  }
<% end %>

<p>
  Avain-arvo -parien luominen on suoraviivaista.
</p>

<% partial 'partials/code_highlight' do %>
  Pari&lt;String, Integer&gt; pari = new Pari&lt;&gt;("yksi", 1);
  System.out.println(pari.getAvain() + " -&gt; " + pari.getArvo());
<% end %>


<% partial 'partials/sample_output' do %>
  yksi -&gt; 1
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustaulun luominen
<% end %>

<p>
  Hajautustaulu sisältää taulukon listoja. Jokainen listan arvo on edellä kuvattu pari, joka sisältää avain-arvo -parin. Hajautustaululla on lisäksi tieto arvojen lukumäärästä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Hajautustaulu&lt;K, V&gt; {

  private Lista&lt;Pari&lt;K, V&gt;&gt;[] arvot;
  private int arvoja;

  public Hajautustaulu() {
  this.arvot = new Lista[32];
  this.arvoja = 0;
  }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon hakeminen
<% end %>

<p>
  Toteutetaan ensin metodi <code>public V hae(K avain)</code>, jota käytetään arvon hakemiseen avaimen perusteella. Metodissa lasketaan ensin avaimen hajautusarvo ja päätellään sen perusteella hajautustaulun sisäisen taulukon indeksi, mistä arvoja haetaan. Mikäli kyseisessä indeksissä ei ole listaa, ei indeksiin ole lisätty vielä yhtäkään avain-arvo -paria, eikä avaimelle ole tallennettu arvoa. Tällöin palautetaan null. Muussa tapauksessa taulukon indeksissä oleva lista käydään läpi, ja avaimen yhtäsuuruutta vertaillaan jokaiseen listan avain-arvo -parin avaimeen. Mikäli joku listalla olevista avaimista vastaa avainta, jonka perusteella arvoa haetaan, palautetaan kyseinen arvo. Muulloin avainta (ja siihen liittyvää arvoa) ei löydy, ja palautetaan arvo null.
</p>

<% partial 'partials/code_highlight' do %>
  public V hae(K avain) {
  int hajautusArvo = Math.abs(avain.hashCode() % this.arvot.length);
  if (this.arvot[hajautusArvo] == null) {
  return null;
  }
  
  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = this.arvot[hajautusArvo];

  for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
  if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
  return arvotIndeksissa.arvo(i).getArvo();
  }
  }
  
  return null;
  }
<% end %>


<% partial 'partials/hint', locals: { name: 'Miksei hajautustaulua toteuteta listana?' } do %>

  <p>
    Hajautustaulun toimintaperiaate perustuu siihen, että avain-arvo -parit jaetaan hajautusarvon perusteella pieniin joukkoihin. Tällöin avaimen perusteella haettaessa käydään läpi vain hyvin pieni joukko avain-arvo -pareja -- olettaen toki, että hajautusarvo on järkevä.
  </p>

  <p>
    Jos hajautusarvo on aina sama -- esimerkiksi 1 -- vastaa hajautustaulun sisäinen toteutus listaa -- kaikki arvot ovat samalla listalla. Jos taas hajautusarvo on hyvin satunnainen, arvot hajautetaan mahdollisimman tasaisesti taulukon eri listoille.
  </p>

  <p>
    Hajautustaulu toimii lisäksi siten, että hajautustaulun käyttämää taulukkoa kasvatetaan mikäli arvojen määrä on tarpeeksi iso (tyypillisesti noin 75% taulukon koosta). Tyypillisesti miljoonia avain-arvo -pareja sisältävän hajautustaulun taulukon yhdessä indeksissä on vain muutama avain-arvo -pari. Tämä tarkoittaa käytännössä sitä, että avain-arvo -parin olemassaolon selvittämiseen tarvitaan vain hajautusarvon laskeminen sekä muutaman olion tarkastelu -- tämä on paljon nopeampaa kuin listan läpikäynti.
  </p>
  
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 1
<% end %>

<p>
  Toteutetaan hajautustauluun lisäämisen käytettävän metodin <code>public void lisaa(K avain, V arvo)</code> ensimmäinen versio. Ensimmäisessä versiossa hajautustaulun sisältämän taulukon kokoa ei kasvateta lisäyksen yhteydessä.
</p>

<p>
  Metodi laskee ensin avaimelle hajautusarvon ja päättelee hajautusarvon perusteella hajautustaulun sisäisen taulukon indeksin. Jos taulukon kyseisessä indeksissä ei ole arvoa, taulukon indeksiin lisätään lista. Tämän jälkeen taulukon indeksissä oleva lista käydään läpi ja sieltä etsitään avain-arvo -paria, jonka avain vastaa lisättävän avain-arvo -parin avainta. Mikäli vastaava avain löytyy, päivitetään olemassaolevan avain-arvo -parin arvo vastaamaan uutta avainta. Muulloin listaan lisätään uusi avain-arvo -pari -- tällöin myös hajautustaulussa olevien arvojen lukumäärää kasvatetaan yhdellä.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
  int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
  if (arvot[hajautusArvo] == null) {
  arvot[hajautusArvo] = new Lista<>();
  }

  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = arvot[hajautusArvo];

  int indeksi = -1;
  for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
  if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
  indeksi = i;
  break;
  }
  }

  if (indeksi &lt; 0) {
  arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
  this.arvoja++;
  } else {
  arvotIndeksissa.arvo(indeksi).setArvo(arvo);
  }
  }
<% end %>

<p>
  Metodi on melko monimutkainen. Pilkotaan se pienempiin osiin -- ensimmäisen osan vastuulla on avaimeen liittyvän listan hakeminen ja toisen osan vastuulla on avaimen indeksin etsiminen listalta.
</p>

<% partial 'partials/code_highlight' do %>
  private Lista&lt;Pari&lt;K, V&gt;&gt; haeAvaimeenLittyvaLista(K avain) {
  int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
  if (arvot[hajautusArvo] == null) {
  arvot[hajautusArvo] = new Lista&lt;&gt;();
  }

  return arvot[hajautusArvo];
  }
  
  private int haeAvaimenIndeksi(Lista&lt;Pari&lt;K, V&gt;&gt; lista, K avain) {
  for (int i = 0; i &lt; lista.koko(); i++) {
  if (lista.arvo(i).getAvain().equals(avain)) {
  return i;
  }
  }

  return -1;
  }
<% end %>

<p>
  Nyt metodi <code>public void lisaa(K avain, V arvo)</code> voidaan toteuttaa hieman selkeämmin.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
  int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);

  if (indeksi &lt; 0) {
  arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
  this.arvoja++;
  } else {
  arvotIndeksissa.arvo(indeksi).setArvo(arvo);
  }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 2
<% end %>

<p>
  Edellä kuvattu hajautustauluun lisääminen toimii osittain. Toiminnallisuuden suurin puute on se, että taulukon kokoa ei kasvateta kun arvojen määrä kasvaa liian suureksi. Lisätään ohjelmaan kasvatustoiminnallisuus, mikä tuplaa hajautustaulun sisäisen taulukon koon. Kasvatustoiminnallisuuden tulee myös sijoittaa jokainen hajautustaulussa olevan taulukon arvo uuteen taulukkoon.
</p>

<p>
  Hahmotellaan kasvatustoiminnallisuuden alku. Kasvatustoiminnallisuudessa luodaan uusi taulukko, jonka koko on edelliseen verrattuna kaksinkertainen. Tämän jälkeen alkuperäinen taulukko käydään indeksi indeksiltä läpi ja olemassaolevat avain-arvo -parit kopioidaan uuteen taulukkoon. Lopulta alkuperäinen taulukko korvataan uudella taulukolla.
</p>

<p>
  Alla on hahmoteltu metodin toimintaa. Kopiointia ei ole vielä toteutettu.
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
  // luodaan uusi taulukko
  Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

  for (int i = 0; i &lt; this.arvot.length; i++) {
  // kopioidaan vanhan taulukon arvot uuteen

  }

  // korvataan vanha taulukko uudella
  this.arvot = uusi;
<% end %>

<p>
  Hahmotellaan seuraavaksi metodia, joka kopioi alkuperäisen taulukon yhden indeksin sisältämän listan arvot uuteen taulukkoon. Kopioinnin yhteydessä jokaisen kopioitavan avain-arvo -parin sijainti taulukossa lasketaan uudelleen -- tämä tehdään, sillä taustalla olevan taulukon koko kasvaa ja avain-arvot -parit halutaan sijoittaa taulukkoon mahdollisimman tasaisesti.
</p>

<% partial 'partials/code_highlight' do %>
  private void kopioi(Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi, int indeksista) {
  for (int i = 0; i &lt; this.arvot[indeksista].koko(); i++) {
  Pari&lt;K, V&gt; arvo = this.arvot[indeksista].arvo(i);
  
  int hajautusarvo = Math.abs(arvo.getAvain().hashCode() % uusi.length);
  if(uusi[hajautusarvo] == null) {
  uusi[hajautusarvo] = new Lista&lt;&gt;();
  }
  
  uusi[hajautusarvo].lisaa(arvo);
  }
  }
<% end %>

<p>
  Nyt kopioi-metodia voidaan kutsua kasvata-metodista.
</p>


<% partial 'partials/code_highlight' do %>
  private void kasvata() {
  // luodaan uusi taulukko
  Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

  for (int i = 0; i &lt; this.arvot.length; i++) {
  // kopioidaan vanhan taulukon arvot uuteen
  kasvata(uusi, indeksista);
  }

  // korvataan vanha taulukko uudella
  this.arvot = uusi;
<% end %>

<p>
  <em>
    Metodissa on pieni virhe. Selvitä mistä virheessä on kyse ja korjaa se.
  </em>
</p>

<p>
  Lisätään lopuksi kasvatustoiminnallisuus osaksi lisäystoiminnallisuutta. Hajautustaulun kokoa kasvatetaan aina jos hajautustaulussa olevien avain-arvo -parien määrä on yli 75% taulukon koosta.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
  int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);

  if (indeksi &lt; 0) {
  arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
  this.arvoja++;
  } else {
  arvotIndeksissa.arvo(indeksi).setArvo(arvo);
  }

  if (1.0 * this.arvoja / this.arvot.length &gt; 0.75) {
  kasvata();
  }
  }
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Poistaminen
<% end %>

<p>
  Lisätään hajautustauluun vielä toiminnallisuus avain-arvo -parin poistamiseen avaimen perusteella. Poistotoiminnallisuus palauttaa null-arvon mikäli arvoa ei löydy, muuten metodi palauttaa poistettavaan avaimeen liittyvän arvon.
</p>

<p>
  Voimme hyödyntää valmiiksi toteuttamiamme metodeja poistotoiminnallisuudessa. Selitä itsellesi (ääneen) alla olevan metodin konkreettinen toiminta.
</p>


<% partial 'partials/code_highlight' do %>
  public V poista(K avain) {
  Lista&Lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
  if (arvotIndeksissa == null || arvotIndeksissa.koko() == 0) {
  return null;
  }

  int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
  if (indeksi &lt; 0) {
  return null;
  }

  Pari&lt;K, V&gt; pari = arvotIndeksissa.arvo(indeksi);
  arvotIndeksissa.poista(pari);
  return pari.getArvo();
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hakemisen tehokkuudesta
<% end %>

<p>
  Tarkastellaan vielä hakemisen tehokkuutta listasta ja hajautustaulusta. Tehokkuusmittauksia voi tehdä metodin <code>System.nanotime()</code> palauttaman nanosekunteja kuvaavan arvon avulla. Ohjelma luo ensin miljoona alkiota hajautustauluun ja listaan, jonka jälkeen hajautustaulusta ja listasta etsitään tuhatta satunnaista arvoa. Noin 50% arvoista löytyy listalta ja hajautustaulusta.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  Hajautustaulu&lt;String, String&gt; taulu = new Hajautustaulu&lt;&gt;();

  for (int i = 0; i &lt; 1000000; i++) {
  lista.lisaa("" + i);
  taulu.lisaa("" + i, "" + i);
  }

  Lista&lt;String&gt; haettavat = new Lista&lt;&gt;();
  Random arpoja = new Random();
  for (int i = 0; i &lt; 1000; i++) {
  haettavat.lisaa("" + arpoja.nextInt(2000000));
  }

  long listanHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
  lista.sisaltaa(haettavat.arvo(i));            
  }
  long listanHakuLopetus = System.nanoTime();
  
  long hajautustaulunHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
  taulu.hae(haettavat.arvo(i));            
  }
  long hajautustaulunHakuLopetus = System.nanoTime();

  
  long listanHaku = listanHakuLopetus - listanHakuAloitus;
  System.out.println("Lista: haku kesti noin " + listanHaku / 1000000 + " millisekuntia (" +
  listanHaku + " nanosekuntia.)");
  
  long hajautustaulunHaku = hajautustaulunHakuLopetus - hajautustaulunHakuAloitus;
  System.out.println("Hajautustaulu: haku kesti noin " + hajautustaulunHaku / 1000000 +
  " millisekuntia (" + hajautustaulunHaku + " nanosekuntia.)");
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista: haku kesti noin 6284 millisekuntia (6284420580 nanosekuntia.)
  Hajautustaulu: haku kesti noin 0 millisekuntia (805106 nanosekuntia.)
<% end %>

<p>
  <em>
    Edellä kuvatut ja kursseilla käyttämämme listat ja hajautustaulut poikkeavat toki sisäiseltä toteutukselta hieman toisistaan. Ohjelmointikielten tarjoamissa tietorakenteissa on hieman enemmän erilaisia optimointeja -- näihinkin palataan myöhemmillä kursseilla. Tämän kurssin puitteissa riittää em. tietorakenteiden käyttöosaaminen sekä jonkintasoinen ymmärrys niiden tehokkuuseroista sekä käyttötapauksista.
  </em>
</p>

<% partial 'partials/exercise', locals: { name: 'Lista ja hajautustaulu (11 osaa)' } do %>

  <p>
    Toteuta edellistä esimerkkiä noudattaen luokat Lista ja Hajautustaulu pakkaukseen <code>tietorakenteita</code>. Kohdat on pisteytetty askeleittain, jotka ovat seuraavat:
  </p>

  <ol>
    <li>
      Listan luominen
    </li>
    <li>
      Arvojen lisääminen listalle (osat 1 ja 2)
    </li>
    <li>
      Listalla olevan arvon olemassaolon tarkastaminen
    </li>
    <li>
      Listalla olevan arvon poistaminen
    </li>
    <li>
      Listan indeksistä hakeminen ja listan koko
    </li>
    <li>
      Avain-arvo -paria kuvaavan luokan toteutus
    </li>
    <li>
      Hajautustaulun luominen
    </li>
    <li>
      Arvon hakeminen hajautustaulusta
    </li>
    <li>
      Hajautustauluun lisääminen (ei kasvatusta)
    </li>
    <li>
      Hajautustaulun koon kasvattaminen tarvittaessa
    </li>
    <li>
      Hajautustaulusta poistaminen
    </li>
  </ol>
  
  <p>
    Sitä mukaa kun kehität listaa ja hajautustaulua, päivitä luokan Ohjelma metodia <code>osiaToteutettu</code> palauttamaan valmiiksi saamasi osan numero. Voit palauttaa tehtävän vaikket tekisikään kaikkia osia, jolloin saat pisteitä tehtävän niistä osista, jotka olet tehnyt.
  </p>

  <p>
    Esimerkiksi, kun olet saanut listan luomisen, arvojen lisäämisen ja arvon poistamisen toimimaan, olet vaiheessa 3, jolloin metodin <code>osiaToteutettu</code> tulisi palautta arvo <code>3</code>.
  </p>
  
<% end %>




<%= partial 'partials/quiz', locals: { id: '5a25a1ff1bbf3a0004538a89' } %>

<%= partial 'partials/quiz', locals: { id: '5a2d21331ffcd00004997916' } %>


