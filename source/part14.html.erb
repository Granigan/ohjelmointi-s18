---
  title: Osa 14
  exercise_page: true
  quiz_page: true
  published: false
---

<% partial 'partials/hint', locals: { name: 'Neljännentoista osan tavoitteet' } do %>

  <p>
    Osaa näyttää kuvia sekä soittaa äänitiedostoja. Luo suuremman ohjelman esimerkkiä noudattaen. Osaa tehdä graafista käyttöliittymää käyttävästä ohjelmasta paketin, jonka voi jakaa muille.
  </p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Matkavalokuvat (2 osaa)' } do %>

  <p>
    Matkailijat tykkäävät ottaa valokuvia. Usein kuvissa sattuu kuitenkin olemaan ärsyttävä turisti, joka on esimerkiksi kuvatun kohteen edessä. Harmitus kasvaa erityisesti, jos samainen turisti esiintyy jokaisessa kuvassa.
  </p>

  <p>
    Alla on kaksi kuvaa eräästä reissusta.
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-1.png"/>

  <p>&nbsp;</p>

  <img src="/img/exercises/06-19-matkavalokuvat-2.png"/>

  <p>&nbsp;</p>

  <p>
    Täydennetään ohjelmaa, mikä mahdollistaa kuvan katsomisen ilman turistia. Apunamme meillä on iso nippu samasta kohteesta otettuja kuvia (turisti on harmittavasti kylläkin jokaisessa niistä...)
  </p>

  <p>
    Tehtäväpohjassa on valmiina ohjelma, jolla voi tarkastella kuvia. Huomaat, että ohjelmassa käytetty kuvien näyttämistapa poikkeaa hieman edellisistä esimerkeistä -- kuten todettua, lähestymistapoja on useita. Kun ohjelma on käynnissä, painamalla numeronäppäintä saat näkyville kuvalistan tietyssä indeksissä olevan kuvan. Kun painat näppäintä "v", näet kuvan muodossa, missä jokaisen kuvan jokaisesta pikselistä on valittu vaaleimmat pikseliarvot.
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-vaalein.png"/>

  <p>&nbsp;</p>

  <h2>Tummimman värin valinta</h2>

  <p>
    Muokkaa sovellusta siten, että kun käyttäjä painaa näppäintä "t", ohjelma näyttää kuvan, missä näkyy yhdistettävien kuvien tummimmat pikselit. Toteuta tummimman värin valinta luokan Yhdistin metodiin <code>public WritableImage tummin(final ArrayList&lt;Image&gt; kuvat)</code> -- ota mallia metodista <code>vaalein</code>.
  </p>

  <p>
    Kun olet lisännyt tummennustoiminnallisuuden, tumman kuvan pitäisi näyttää kutakuinkin seuraavalta.
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-tummin.png"/>

  <p>&nbsp;</p>

  <h2>Värien mediaani</h2>

  <p>
    Noniin, hankkiudutaan turistista eroon.
  </p>

  <p>
    Muokkaa sovellusta siten, että kun käyttäjä painaa näppäintä "m", ohjelma näyttää kuvan, missä näkyy yhdistettävien kuvien väriarvojen mediaanit. Toteuta mediaanivärin valinta luokan Yhdistin metodiin <code>public WritableImage mediaani(final ArrayList&lt;Image&gt; kuvat)</code>.
  </p>

  <p>
    Mediaani on järjestettyjen lukujen keskimmäinen arvo. Esimerkiksi, jos viiden kuvan sinisten värien arvot ovat <code>211, 123, 17, 155, 8</code>, on niiden mediaani <code>123</code>. Saat mediaanin selville järjestämällä arvot, ja valitsemalla listan keskimmäisen arvon.
  </p>

  <p>
    Toteutuksen pitäisi poistaa ärsyttävä turisti:
  </p>

  <img src="/img/exercises/06-19-matkavalokuvat-mediaani.png"/>


  <p>
    <em>Tehtävän alkuperäinen versio: John Nicholson / Austin Peay State University</em>
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Sovelluksen käytettävyys
<% end %>

<p>
  Yksikkötestaus on vain osa ohjelmistojen testaamiseen liittyvää työtä. Tärkein sovelluksen testaamisen liittyvä ihmisryhmä on sovelluksen käyttäjät. Käyttäjät toimivat ohjelman parissa ja huomaavat toiminnassa esiintyviä puutteita.
</p>

<p>
  Sovelluksen käytettävyyteen liittyy useita erilaisia näkökulmia, joista osa on <a href="https://www.iso.org/standard/16883.html" target="_blank" rel="noopener">standardoitu</a>. Käytettävyyden kannalta oleellisia ominaisuuksia ovat muunmuassa:
</p>

<ul>
  <li>
    Tavoitteiden saavuttaminen. Ohjelmiston käyttäjillä on tavoitteita, joita ohjelmiston avulla halutaan saavuttaa. Miten hyvin ohjelmisto auttaa käyttäjiä saavuttamaan tavoitteensa? Miten tehokkaasti käyttäjät saavuttavat tavoitteensa? Joutuvatko he käyttämään liikaa aikaa tavoitteiden saavuttamiseen? Voisiko tätä helpottaa sovelluksen suunnittelussa?
  </li>
  <li>
    Tyytyväisyys sovelluksen toimintaan. Miten tyytyväisiä käyttäjät ovat sovelluksen toimintaan? Onko sovelluksen käyttö sujuvaa?
  </li>
  <li>
    Ohjelmiston käytön oppiminen. Kuinka nopeasti ohjelmiston käyttö on opittavissa? Minkälaisia ohjeita sovelluksen käyttö vaatii? Tarjoaako ohjelmisto näitä ohjeita? Kuinka hyvin käyttäjä muistaa miten sovellusta käytetään?
  </li>
  <li>
    Virhealttius. Kuinka paljon käyttäjä tekee virheitä sovellusta käyttäessään? Voisiko virheiden määrää vähentää?
  </li>
</ul>

<p>
  Käytettävyyden lisäksi sovelluksissa oleellista on myös saavutettavuus, millä tarkoitetaan erilaisten käyttäjäryhmien huomiointia sovelluksen rakentamisessa. Näitä käsitellään tarkemmin Human-Computer Interaction -teeman kursseilla (Ihmisen ja tietokoneen välinen vuorovaikutus).
</p>




<% partial 'partials/exercise', locals: { name: 'Matopeli (4 osaa)' } do %>

  <p>
    Tässä tehtävässä luodaan klassisen matopelin rakenteet, eli mato, omena sekä niitä hallinnoiva matopeli. Pelin graafinen käyttöliittymä on sovelluksessa toteutettu valmiina -- graafisesta käyttöliittymästä voi ottaa inspiraatiota omiin projekteihin. Kun olet toteuttanut tehtävän askeleet, poista kommentit luokasta MatopeliSovellus ja kokeile pelaamista.
  </p>

  <h2>Pala ja Omena</h2>

  <p>
    Luo pakkaukseen <code>matopeli.domain</code> luokka <code>Pala</code>. Luokalla <code>Pala</code> on konstruktori <code>public Pala(int x, int y)</code>, joka saa palan sijainnin parametrina. Lisäksi luokalla <code>Pala</code> on seuraavat metodit.
  </p>

  <ul>
    <li><code>public int getX()</code> palauttaa Palan konstruktorissa saadun x-koordinaatin.</li>
    <li><code>public int getY()</code> palauttaa Palan konstruktorissa saadun y-koordinaatin.</li>
    <li><code>public boolean osuu(Pala pala)</code> palauttaa true jos oliolla on sama x- ja y-koordinaatti kuin parametrina saadulla Pala-luokan ilmentymällä.</li>
    <li><code>public String toString()</code> palauttaa palan sijainnin muodossa <code>(x,y)</code>. Esim. <code>(5,2)</code> kun x-koordinaatin arvo on 5 ja y-koordinaatin arvo on 2.</li>
  </ul>

  <p>
    Toteuta pakkaukseen <code>matopeli.domain</code> myös luokka <code>Omena</code>. Peri luokalla Omena luokka <code>Pala</code>.
  </p>


  <h2>Mato</h2>

  <p>
    Toteuta pakkaukseen <code>matopeli.domain</code> luokka <code>Mato</code>. Luokalla <code>Mato</code> on konstruktori <code>public Mato(int alkuX, int alkuY, Suunta alkusuunta)</code>, joka luo uuden madon. Madon suunta on parametrina annettu <code>alkusuunta</code>. Mato koostuu listasta <code>Pala</code>-luokan ilmentymiä.
  </p>

  <p>
    Luokka <code>Suunta</code> löytyy valmiina pakkauksesta <code>Matopeli.domain</code>.
  </p>

  <p>
    Mato luodaan yhden palan pituisena, mutta madon "aikuispituus" on kolme. Madon tulee kasvaa yhdellä aina kun se liikkuu. Kun madon pituus on kolme, se kasvaa isommaksi vain syödessään.
  </p>

  <p>
    Toteuta madolle seuraavat metodit
  </p>

  <ul>
    <li><code>public Suunta getSuunta()</code> palauttaa madon suunnan.</li>
    <li><code>public void setSuunta(Suunta suunta)</code> asettaa madolle uuden suunnan. Mato liikkuu uuteen suuntaan kun metodia <code>liiku</code> kutsutaan seuraavan kerran.</li>
    <li><code>public int getPituus()</code> palauttaa madon pituuden. Madon pituuden tulee olla sama kuin <code>getPalat()</code>-metodikutsun palauttaman listan alkioiden määrä.</li>
    <li><code>public List&lt;Pala&gt; getPalat()</code> palauttaa listan pala-olioita, joista mato koostuu. Palat ovat listalla järjestyksessä, siten että pää sijaitsee listan lopussa.</li>
    <li><code>public void liiku()</code> liikuttaa matoa yhden palan verran eteenpäin.</li>
    <li><code>public void kasva()</code> kasvattaa madon kokoa yhdellä. Madon kasvaminen tapahtuu seuraavan <code>liiku</code>-metodikutsun yhteydessä. Sitä seuraaviin liiku-kutsuihin kasvaminen ei enää vaikuta. Jos madon pituus on 1 tai 2 kun metodia kutsutaan, ei kutsulla saa olla mitään vaikutusta matoon.</li>
    <li><code>public boolean osuu(Pala pala)</code> tarkistaa osuuko mato parametrina annettuun palaan. Jos mato osuu palaan, eli joku madon pala osuu metodille parametrina annettuun palaan, tulee metodin palauttaa arvo <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
    <li><code>public boolean osuuItseensa()</code> tarkistaa osuuko mato itseensä. Jos mato osuu itseensä, eli joku sen pala osuu johonkin toiseen sen palaan, metodi palauttaa arvon <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
  </ul>

  <p>
    Metodien <code>public void kasva()</code> ja <code>public void liiku()</code> toiminnallisuus tulee toteuttaa siten, että mato kasvaa vasta seuraavalla liikkumiskerralla.
  </p>

  <p>
    Liikkuminen kannattaa toteuttaa siten, että madolle luodaan liikkuessa aina uusi pala. Uuden palan sijainti riippuu madon kulkusuunnasta: vasemmalle mennessä uuden palan sijainti on edellisen pääpalan sijainnista yksi vasemmalle, eli sen x-koordinaatti on yhtä pienempi. Jos uuden palan sijainti on edellisen pääpalan alapuolella, eli madon suunta on alas, tulee uuden palan y-koordinaatin olla yhtä isompi kuin pääpalan y-koordinaatti (käytämme siis piirtämisestä tuttua koordinaattijärjestelmää, jossa y-akseli on kääntynyt).
  </p>

  <p>
    Liikkuessa uusi pala lisätään listan loppuun, ja poistetaan listan alussa oleva alkio. Uudesta palasta siis tulee madon "uusi pää" ja  jokaisen palan koordinaatteja ei tarvitse päivittää erikseen. Toteuta kasvaminen siten, että listan alussa olevaa palaa, eli "madon häntää" ei poisteta jos metodia <code>kasva</code> on juuri kutsuttu.
  </p>

  <p>
    Huom! Kasvata matoa aina sen liikkuessa jos sen pituus on pienempi kuin 3.
  </p>

  <% partial 'partials/code_highlight' do %>
    Mato mato = new Mato(5, 5, Suunta.OIKEA);
    System.out.println(mato.getPalat());
    mato.liiku();
    System.out.println(mato.getPalat());
    mato.liiku();
    System.out.println(mato.getPalat());
    mato.liiku();
    System.out.println(mato.getPalat());

    mato.kasva();
    System.out.println(mato.getPalat());
    mato.liiku();
    System.out.println(mato.getPalat());

    mato.setSuunta(Suunta.VASEN);
    System.out.println(mato.osuuItseensa());
    mato.liiku();
    System.out.println(mato.osuuItseensa());
  <% end %>

  <% partial 'partials/sample_output' do %>
    [(5,5)]
    [(5,5), (6,5)]
    [(5,5), (6,5), (7,5)]
    [(6,5), (7,5), (8,5)]
    [(6,5), (7,5), (8,5)]
    [(6,5), (7,5), (8,5), (9,5)]
    false
    true
  <% end %>


  <h2>Matopeli, osa 1</h2>

  <p>
    Matopeli tietää sekä madosta että omenasta. Se tarjoaa mahdollisuuden madon liikuttamiseen, hallinnoi mahdollista omenan syömistä, sekä arpoo uusia omenoita. Matopeli osaa myös kertoa jos peli on loppu, eli mato on törmännyt reunaan tai itseensä.
  </p>

  <p>
    Luo pakkaukseen <code>matopeli.domain</code> luokka <code>Matopeli</code>.
  </p>

  <p>
    Matopelillä on tieto pelin leveydestä ja korkeudesta sekä tieto siitä jatkuuko peli yhä. Lisäksi matopeli sisältää viitteen mato-olioon ja omenaan.
  </p>

  <p>
    Lisää luokalle Matopeli kaksiparametrinen konstruktori. Konstruktorin ensimmäisenä parametrina annetaan pelin leveys, toisena parametrina pelin korkeus. Leveys ja korkeus kerrotaan ruutujen lukumääränä.
  </p>

  <p>
    Täydennä konstruktorin toiminnallisuutta siten, että konstruktorissa luodaan myös peliin liittyvä <code>Mato</code>. Luo mato siten, että sijainti riippuu Matopeli-luokan konstruktorissa saaduista parametreista. Madon x-koordinaatin tulee olla <code>leveys / 2</code>, y-koordinaatin <code>korkeus / 2</code> ja suunnan <code>Suunta.ALAS</code>.
  </p>

  <p>
    Lisää matopeliin lisäksi seuraavat metodit
  </p>

  <ul>
    <li><code>public Mato getMato()</code> palauttaa matopelin madon.</li>
    <li><code>public void setMato(Mato mato)</code> asettaa matopeliin metodin parametrina olevan madon. Jos metodia <code>getMato</code> kutsutaan madon asetuksen jälkeen, tulee metodin <code>getMato</code> palauttaa viite <em>samaan</em> matoon.</li>
  </ul>


  <h2>Matopeli, osa 2</h2>


  <p>
    Lisää matopelin konstruktoriin omenan luominen.  Konstruktorissa luotavan omenan sijainnin tulee olla satunnainen, kuitenkin niin että omenan x-koordinaatti on aina välillä <code>[0, leveys[</code>, ja y-koordinaatti välillä <code>[0, korkeus[</code>. Tässä luokasta Random on hyötyä.
  </p>

  <p>
    Lisää matopelille myös seuraavat metodit:
  </p>

  <ul>
    <li><code>public Omena getOmena</code> palauttaa matopelin omenan.</li>
    <li><code>public void setOmena(Omena omena)</code> asettaa matopeliin metodin parametrina olevan omenan. Jos metodia <code>getOmena</code> kutsutaan omenan asetuksen jälkeen, tulee metodin <code>getOmena</code> palauttaa viite <em>samaan</em> omenaan.</li>
    <li><code>public boolean loppu()</code> kertoo onko matopeli päättynyt. Matopeli päättyy jos mato törmää itseensä tai seinään. </li>
  </ul>

  <p>
    Lisää tämän jälkeen luokalle Matopeli metodi <code>public void paivita()</code>. Muokkaa metodin <code>paivita</code>-toiminnallisuutta siten, että metodissa toteutetaan seuraavat askeleet annetussa järjestyksessä.
  </p>

  <ol>
    <li>Liikuta matoa</li>
    <li>Jos mato osuu omenaan, syö omena ja kutsu madon kasva-metodia. Arvo peliin uusi omena. Omena tulee arpoa niin, että se ei ole madon päällä (tai ulkona pelialueelta).</li>
    <li>Jos mato törmää itseensä tai seinään, matopelin tulee tietää siitä, että sen suoritus on loppunut (metodin loppu() tulee seuraavalla kerralla palauttaa arvo true).</li>
  </ol>

  <p>
    <em>
      Kokeile nyt poistaa luokasta MatopeliSovellus kommentit ja pelaa matopeliä. Löydät pelistä todennäköisesti vieläkin korjattavaa ja paranneltavaa. Esimerkiksi ennätyslista tai jonkinlainen pistelasku olisi hieno...
    </em>
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Sovellukset ohjelmointiympäristön ulkopuolella
<% end %>


<p>
  Sovelluksemme ovat tähän mennessä toimineet vain ohjelmointiympäristössä. Tämä ei kuitenkaan ole käytännössä totta, sillä ohjelman käynnistäminen ohjelmointiympäristössä vastaa melko vahvasti sen käynnistämistä ohjelmointiympäristön ulkopuolella. Voimme määritellä luokan, jossa olevaa metodia <code>public static void main</code> käytetään ohjelman käynnistämiseen. 
</p>

<p>
  Mavenia ja JavaFX:ää käyttävien projektien "paketointiin" löytyy valmis Maven-liitännäinen <a href="http://javafx-maven-plugin.github.io/" target="_blank">http://javafx-maven-plugin.github.io/</a>. Liitännäinen tarjoaa muunmuassa mahdollisuuden sovelluksen paketointiin jar-tiedostoksi, minkä voi suorittaa suoraan komentoriviltä.
</p>

<p>
  Liitännäisen käyttöönotto tapahtuu lisäämällä projektin <code>pom.xml</code>-tiedostoon tieto ohjelman käännöksen aikana suoritettavasta liitännäisestä. 
</p>

<% partial 'partials/xml_highlight' do %>
  &lt;build&gt;
    &lt;plugins&gt;
      
      &lt;plugin&gt;
        &lt;groupId&gt;com.zenjava&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;8.6.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;mainClass&gt;asteroids.AsteroidsSovellus&lt;/mainClass&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      
    &lt;/plugins&gt;
  &lt;/build&gt;
<% end %>

<p>
  Nyt kun sovelluksen paketoi erillisen <code>mvn jfx:jar</code>-kutsun avulla, projektista luodaan jar-tiedosto, jonka voi käynnistää komentoriviltä.
</p>

<p>
Kutsun voi antaa NetBeansissa klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Run Maven -&gt; Goals...". Tämän jälkeen avautuvaan ikkunaan syötetään kohtaan "Goals" merkkijono "jfx:jar". Kun tämän jälkeen painetaan ok, sovelluksesta luodaan valmis paketti.
</p>


<p>
  NetBeansin Output-välilehti antaa vinkkiä sovelluksen suorittamisesta.
</p>

<% partial 'partials/sample_output' do %>
  // ...
  --- javafx-maven-plugin:8.6.0:jar (default-cli) @ Osa13_04.Asteroids ---
  Building JavaFX JAR for application
  Adding 'deploy' directory to Mojo classpath: ...
<% end %>


<p>
  Jos kaikki menee hyvin, sovelluksen kansiosta <code>target</code> löytyy alikansio <code>jfx</code>. Tämän alla on kansio <code>app</code>, joka sisältää suoritettavan jar-päätteisen tiedoston.
</p>

<p>
  Nyt sovelluksen voi käynnistää komentoriviltä. Kun annamme komentorivillä komennon "java -jar" -- eli, käynnistä jar-paketoitu ohjelma Javalla, jota seuraa yllä luotu jar-tiedosto, käynnistyy ohjelma.
</p>

<pre>
$ java -jar "/<em>polku</em>/osa13/Osa13_04.Asteroids/target/jfx/app/Osa13_04.Asteroids-1.0-SNAPSHOT.jar"
</pre>

<% partial 'partials/hint', locals: { name: 'Asennettavan sovelluksen luominen' } do %>

  <p>
    Edellä kuvattu menetelmä paketoi sovelluksen suoritettavaan muotoon. Tietokoneiden normaalikäyttäjät eivät kuitenkaan ole tottuneet sovellusten käynnistämiseen komentoriviltä -- osalla heistä ei myöskään ole Javaa asennettuna, jonka edellinen komento vaatii.
  </p>

  <p>
    Sovellusten paketointiin ja tuotteistamiseen ym. syvennytään laajemmin mm. kursseilla ohjelmistotekniikan menetelmät ja ohjelmistotuotanto.
  </p>
  
<% end %>


<% partial 'partials/exercise', locals: { name: '2048 (5 osaa)' } do %>

  <p>
    <a href="https://en.wikipedia.org/wiki/2048_(video_game)" target="_blank" rel="noopener">2048</a> on suosittu peli. Peliä pelataan 4x4 -kokoisessa lukuja sisältävässä ruudukossa, ja siinä on neljä mahdollista siirtoa: (o)ikealle, (a)las, (v)asemmalle ja (y)lös. Jokainen siirto siirtää kaikkia ruudukossa olevia arvoja niin paljon haluttuun suuntaan kuin mahdollista. Jos kahdessa vierekkäisessä ruudussa on sama arvo, yhdistetään ruutujen arvot yhteen. Esimerkiksi:
  </p>

  <pre>

2 0 2 0
0 0 0 1
0 1 0 0
0 0 0 0
&gt; o

0 0 0 4
0 0 0 1
0 0 0 1
0 1 0 0
  </pre>

  <p>
    Aina kun pelaaja tekee siirron, satunnaiseen nolla-arvoiseen kohtaan arvotaan uusi luku. Peli loppuu kun yhdessä ruuduista on luku 2048 tai siirtäminen ei enää onnistu. Alla esimerkki pelin kulusta.
  </p>

  <pre>
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0

&gt; o
0 0 0 1
0 0 0 0
0 0 0 0
0 1 0 0

&gt; o
0 0 0 1
0 0 0 0
0 0 0 1
0 0 0 1

&gt; a
0 0 0 0
0 0 0 0
1 0 0 2
0 0 0 1

&gt; a
1 0 0 0
0 0 0 0
0 0 0 2
1 0 0 1

&gt; v
1 0 0 0
0 0 0 0
2 0 0 0
2 1 0 0

&gt; y
1 1 0 0
4 0 0 0
0 0 0 0
0 1 0 0

&gt; v
2 0 0 0
4 0 0 0
0 0 0 0
1 0 1 0

&gt; v
2 0 0 0
4 1 0 0
0 0 0 0
2 0 0 0

&gt;
  </pre>

  <p>
    Tässä tehtävässä rakennat pelin toimintaan tarvittua ydintoiminnallisuutta. Tehtävässä kerrataan myös toistolauseiden ja indeksien käyttöä.
  </p>

  <h2>Peliruudukko</h2>

  <p>
    Luo pakkaukseen sovellus luokka Peliruudukko. Luokalla tulee olla parametriton konstruktori, joka luo 4x4-kokoisen ruudukon, ja jonka vasemmassa yläkulmassa on arvo 1. Oleta, että kaksiulotteisen taulukon ensimmäinen indeksi kuvaa y-koordinaattia, ja toinen indeksi x-koordinaattia. Oleta lisäksi, että y-koordinaatti kasvaa alaspäin. Vasen yläkulma on siis kohdassa taulukko[0][0] ja vasen alakulma kohdassa taulukko[3][0] -- olettaen, että taulukon koko on 4.
  </p>

  <p>
    Lisää luokalle myös metodit public int[][] getTaulukko(), joka palauttaa pelin sisäisen tilan, ja public void setTaulukko(int[][] taulukko), jolla voi asettaa pelin sisäisen tilan.
  </p>

  <h2>Siirrä oikealle</h2>

  <p>
    Tee tämän jälkeen peliruudukolle metodi public void siirraOikealle(), joka siirtää jokaisen rivin palat oikealle. Metodi yhdistää tarvittaessa myös samanarvoiset muuttujat. Alla muutamia esimerkkeja.
  </p>

  <pre>
1 1 1 1
1 1 0 1
1 1 1 0
1 0 1 1

&gt; o
0 0 0 4
0 0 1 2
0 0 1 2
0 0 1 2
  </pre>

  <pre>
1 0 0 1
0 1 0 1
2 2 4 0
0 1 0 0

&gt; o
0 0 0 2
0 0 0 2
0 0 0 8
0 0 0 1
  </pre>

  <h2>Siirrä ylös ja siirrä alas</h2>

  <p>
    Tee seuraavaksi peliruudukolle metodit public void siirraYlos(), joka siirtää jokaisen rivin palat ylös, ja public void siirraAlas(), joka siirtää jokaisen rivin palat alas. Metodi yhdistää tarvittaessa myös samanarvoiset muuttujat.
  </p>

  <h2>Siirrä vasemmalle ja pelin loppuminen</h2>

  <p>
    Tee seuraavaksi peliruudukolle metodi public void siirraVasemmalle(), joka siirtää jokaisen rivin palat vasemmalle. Kun metodi siirraVasemmalle on valmis, toteuta sovellukseen metodi public boolean peliKaynnissa(), joka palauttaa tiedon pelin jatkumisesta.
  </p>

  <p>
    Peli jatkuu jos (1) pelissä on yksikin ruutu, jossa on arvo 0, tai (2) kaksi pelin vierekkaista (vaaka- tai pystytasossa) ruutua ovat samanarvoiset.
  </p>

  <h2>Tekstikayttoliittyma ja uuden luvun arpominen</h2>

  <p>
    Tee lopulta pelille tekstikäyttöliittymä. Pelin tulee käynnistyä kun luokassa Peli olevaa main-metodia kutsutaan. Pelaajalle tulee tarjota vaihtoehdot o, v, y, a, x, missä o on oikealle, v on vasemmalle, y on ylös, a on alas, ja x on lopeta. Jokaisen siirron -- paitsi pelin lopettavan x:n -- jälkeen taulukon satunnaiseen tyhjään kohtaan tulee lisätä luku 1. Alla on esimerkki tekstikäyttöliittymän toiminnasta.
  </p>

  <% partial 'partials/sample_output' do %>
    1 0 0 0
    0 0 0 0
    0 0 0 0
    0 0 0 0

    &gt; <font color="red">o</font>
    0 0 0 1
    0 0 0 0
    0 0 0 1
    0 0 0 0

    &gt; <font color="red">y</font>
    0 0 0 2
    1 0 0 0
    0 0 0 0
    0 0 0 0

    &gt; <font color="red">v</font>
    2 0 1 0
    1 0 0 0
    0 0 0 0
    0 0 0 0

    &gt; <font color="red">o</font>
    0 0 2 1
    0 0 0 1
    0 1 0 0
    0 0 0 0

    &gt; <font color="red">y</font>
    0 1 2 2
    0 0 0 0
    0 0 0 0
    0 0 1 0

    &gt; <font color="red">o</font>
    0 0 1 4
    0 0 0 0
    0 0 0 1
    0 0 0 1

    &gt; <font color="red">x</font>
  <% end %>

<% end %>



<% partial 'partials/hint', locals: { name: 'Mitä seuraavaksi?' } do %>

  <p>
    Tämän kurssin jälkeen on hyvä ottaa kurssit Tietokantojen perusteet sekä Tietorakenteet ja algoritmit. Kurssin tietokantojen perusteet jälkeen kannattaa ottaa kurssi Ohjelmistotekniikan menetelmät. Jos kurssia Tietokoneen toiminta ei ole vielä suorittanut, myös sen ottaminen on suositeltavaa. Muistathan, että kurssin Tietorakenteet ja algoritmit esitietovaatimuksena on kurssi Johdatus yliopistomatematiikkaan.
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  ArrayList ja Hajautustaulu
<% end %>

<p>
  ArrayList ja Hajautustaulu ovat ohjemoinnissa hyvin yleisesti käytettyjä tietorakenteita. Tarkastellaan tässä niiden todellista toteutusta -- alla rakennetaan askeleittain ensin ArrayListiä imitoiva tietorakenne <code>Lista</code>, jota hyödynnetään sitten tietorakenteen <code>Hajautustaulu</code> tekemisessä.
</p>

<% partial 'partials/material_sub_heading' do %>
  Geneerinen tyyppi
<% end %>


<p>
  Olemme listoihin tutustumisesta lähtien kertoneet erilaisille tietorakenteille niiden sisältämän arvon tyypin. Esimerkiksi String-tyyppisiä olioita sisältävä lista on esitelty muodossa <code>ArrayList&lt;String&gt;</code>. Tässä on kuitenkin ihmetyttänyt se, että miten ihmeessä listat ja muutkin tietorakenteet voivat sisältää erityyppisiä oliota.
</p>

<p>
  Geneerisyys (<em>generics</em>) liittyy olioita säilövien luokkien tapaan säilöä vapaavalintaisen tyyppisiä olioita. Vapaavalintaisuus perustuu luokkien määrittelyssä käytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan määritellä <em>olion luontivaiheessa</em> valittavia tyyppejä. Luokan geneerisyys määritellään antamalla luokan nimen jälkeen haluttu määrä luokan tyyppiparametreja pienempi kuin ja suurempi kuin -merkkien väliin. Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden minkälaisen tahansa olion.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;T&gt; {
  private T alkio;

  public void asetaArvo(T alkio) {
  this.alkio = alkio;
  }

  public T haeArvo() {
  return alkio;
  }
  }
<% end %>

<p>
  Määrittely <code>public class Lokero&lt;T&gt;</code> kertoo että luokalle <code>Lokero</code> tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun jälkeen kaikki olion sisäiset muuttujat tulevat olemaan kutsun yhteydessä annettua tyyppiä. Luodaan merkkijonon tallentava lokero.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;String&gt; merkkijono = new Lokero&lt;&gt;();
  merkkijono.asetaArvo(":)");

  System.out.println(merkkijono.haeArvo());<% end %>

<% partial 'partials/sample_output' do %>
  :)
<% end %>

<p>
  Yllä olevalla ohjelmalla merkkijono-nimisen <code>Lokero</code>-olion <em>ajonaikainen</em> toteutus on seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;String&gt; {
  private String alkio;

  public void asetaArvo(String alkio) {
  this.alkio = alkio;
  }

  public String haeArvo() {
  return alkio;
  }
  }
<% end %>

<p>
  Tyyppiparametria vaihtamalla voidaan luoda myös muuntyyppisiä olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;Integer&gt; luku = new Lokero&lt;&gt;();
  luku.asetaArvo(5);

  System.out.println(luku.haeArvo());<% end %>


<% partial 'partials/sample_output' do %>
  5
<% end %>

<p>
  Yllä olevalla esimerkillä <code>luku</code>-nimisen Lokeron toteutus olisi ajonaikaisesti taas seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;Integer&gt; {
  private Integer alkio;

  public void asetaArvo(Integer alkio) {
  this.alkio = alkio;
  }

  public Integer haeArvo() {
  return alkio;
  }
  }
<% end %>

<p>
  Samalla tavalla ohjelmoija voisi toteuttaa esimerkiksi luokan <code>Pari</code>, mihin voi laittaa kaksi halutun tyyppistä oliota.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;T, K&gt; {
  private T eka;
  private K toka;

  public void asetaArvot(T eka, K toka) {
  this.eka = eka;
  this.toka = toka;
  }

  public T haeEka() {
  return this.eka;
  }

  public K haeToka() {
  return this.toka;
  }
  }
<% end %>


<p>
  Huomattava osa Javan tietorakenteista mahdollistaa eri tyyppisten muuttujien käytön. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  Map&lt;String, String&gt; avainArvoParit = new HashMap&lt;&gt;();
<% end %>

<p>
  Jatkossa kun näet esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code> tiedät että sen sisäisessä rakenteessa on käytetty geneeristä tyyppiparametria. Sama periaate löytyy esimerkiksi rajapinnassa Comparable.
</p>


<% partial 'partials/material_sub_heading' do %>
  Listarakenne
<% end %>

<p>
  Tarkastellaan erästä tapaa Javan tarjoaman ArrayList-tietorakenteen toteuttamiseen. Javan ArrayList hyödyntää sisäisesti taulukkoa, mikä on määritelty generisen tyyppiseksi -- tämän takia listalle saa lisätä käytännössä minkä tyyppisiä arvoja tahansa. Lista tarjoaa useita metodeja, joista tämän esimerkin kannalta oleellisia ovat <code>add</code> eli lisääminen, <code>contains</code> eli olemassaolon tarkastaminen, <code>remove</code> eli poistaminen sekä <code>get</code>, eli tietystä indeksistä hakeminen.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.add("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.remove("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan luominen
<% end %>

<p>
  Luodaan luokka <code>Lista</code>. Listarakenne sisältää geneerisen taulukon -- eli taulukon, jonka alkioiden tyyppi määräytyy ajonaikaisesti tyyppiparametreista. Asetetaan taulukon alkukooksi <code>10</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {
  private T[] arvot;

  public Lista() {
  this.arvot = (T[]) new Object[10];
  }
  }
<% end %>

<p>
  Lista kapseloi taulukon. Alkutilanteessa jokainen taulukon indeksi sisältää <code>null</code>-viitteen.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle
<% end %>

<p>
  Lisätään luokalle metodi <code>public void lisaa(T arvo)</code>, mikä mahdollistaa arvojen lisäämisen listalle. Luodaan luokalle tätä varten erillinen kokonaislukumuuttuja, joka pitää kirjaa taulukon ensimmäisestä tyhjästä paikasta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {

  private T[] arvot;
  private int arvoja;

  public Lista() {
  this.arvot = (T[]) new Object[10];
  this.arvoja = 0;
  }

  public void lisaa(T arvo) {
  this.arvot[this.arvoja] = arvo;
  this.arvoja++;
  }
  }
<% end %>

<p>
  Nyt arvojen lisääminen listalle onnistuu -- tai, ainakin listan luominen ja metodin kutsuminen onnistuu -- emme vielä voi testata ovatko arvot todellisuudessa listalla.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle, osa 2
<% end %>

<p>
  Edellä kuvatussa <code>lisaa</code>-metodissa on pieni ongelma. Ongelma ilmenee kun seuraava ohjelmakoodi suoritetaan.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  for (int i = 0; i &lt; 11; i++) {
  lista.lisaa("hei");
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
  at tietorakenteita.Lista.lisaa(Lista.java:14)
  at tietorakenteita.Ohjelma.main(Ohjelma.java:8)
<% end %>

<p>
  Listan koko ei kasva. Eräs ArrayList-luokan oleellisimmista toiminnallisuuksista on se, että sen koko kasvaa aina tarvittaessa -- ohjelmoijan ei siis tarvitse varoa listan täyttymistä.
</p>

<p>
  Lisätään ohjelmaan listan koon kasvattamiseen liittyvä toiminnallisuus. Listan kokoa kasvatetaan aina jos täyteen listaan yritetään lisätä arvo. Kasvattaminen toteutetaan käytännössä siten, että luomme uuden taulukon, mihin vanhan taulukon arvot kopioidaan. Tämän jälkeen vanha taulukko jätetään heitteille, ja uudesta taulukosta tulee olion käyttämä taulukko.
</p>

<p>
  Javan kuudennessa versiossa uuden taulukon koko lasketaan kaavalla <code>vanhakoko * 3 / 2 + 1</code>. Hyödynnetään samaa kaavaa omassa toteutuksessamme. Luodaan kasvattamista varten erillinen metodi <code>kasvata</code>, joka on vain luokan omien metodien käytössä (eli sillä on <code>private</code>-näkyvyys).
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
  T[] uusi = (T[]) new Object[this.arvot.length * 3 / 2 + 1];
  for (int i = 0; i &lt; this.arvot.length; i++) {
  uusi[i] = this.arvot[i];
  }
  
  this.arvot = uusi;
  }
<% end %>

<p>
  Toteutus luo uuden taulukon, jonka koko on noin 1.5-kertainen vanhaan taulukkoon verrattuna. Tämän jälkeen kaikki vanhan taulukon alkiot kopioidaan uuteen taulukkoon ja lopulta olion <code>arvot</code>-muuttujan -- eli taulukon -- arvoksi asetetaan uusi taulukko.
</p>

<p>
  Muokataan vielä metodia <code>lisaa</code> siten, että taulukon kokoa kasvatetaan tarvittaessa.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(T arvo) {
  if(this.arvoja == this.arvot.length) {
  kasvata();
  }
  
  this.arvot[this.arvoja] = arvo;
  this.arvoja++;
  }
<% end %>

<p>
  Nyt arvoja voi lisätä listalle lähes rajattomasti.
</p>


<% partial 'partials/hint', locals: { name: 'Edellä kuvatun kasvatusmenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi kasvatuksen yhteydessä jokaisen vanhan taulukon arvon uuteen taulukkoon. Jos taulukossa on esimerkiksi kaksi miljoonaa alkiota, kopiointi käy kaksi miljoonaa alkiota läpi.
  </p>

  <p>
    Menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon olemassaolon tarkastaminen
<% end %>

<p>
  Luodaan listalle seuraavaksi metodi <code>public boolean sisaltaa(T arvo)</code>, minkä avulla voidaan tarkistaa onko alkio listalla. Hyödynnetään tässä tietoa siitä, että jokainen Javan olio -- riippumatta sen tyypistä -- perii Object-luokan (tai on Object-tyyppinen). Tämän takia jokaisella oliolla on metodi <code>public boolean equals(Object object)</code>, jota voidaan käyttää yhtäsuuruuden tarkasteluun.
</p>

<p>
  Luokan <code>Lista</code> muuttuja <code>arvoja</code> sisältää tiedon arvojen tämän hetkisestä lukumäärästä. Voimme siis toteuttaa <code>sisaltaa</code>-metodin siten, että tarkastelemme vain ne listan indeksit, joissa on arvoja.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (this.arvot[i].equals(arvo)) {
  return true;
  }
  }
  
  return false;
  }
<% end %>

<p>
  Edellä esitetty menetelmä olettaa, että käyttäjä ei lisää listalle <code>null</code>-viitettä. Jos haluamme, että käyttäjä saa lisätä listalle <code>null</code>-viitteen (ja <code>null</code>-viitteen olemassaoloa saa myös hakea), tulee ohjelmaa muokata hieman. Tällöin <code>sisaltaa</code>-metodin eräs mahdollinen toteutus olisi seuraava.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  return true;
  }
  }
  
  return false;
  }
<% end %>

<p>
  <em>Yllä oleva esimerkki ei kuitenkaan toimi. Pohdi miksei ja mieti minkälaisella ratkaisulla saisit <code>null</code>-viitteiden käsittelyn toimimaan.
  </em>
</p>

<p>
  Ohjelmassa on nyt mahdollisuus listalla olevien alkioiden olemassaolon tarkasteluun.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>


<% partial 'partials/sample_output' do %>
  false
  true
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon poistaminen
<% end %>

<p>
  Toteuttamallemme listalle voi nyt lisätä arvoja, jonka lisäksi arvon olemassaolon voi tarkastaa. Toteutetaan vielä arvon poistaminen. Toteutetaan metodi <code>public void poista(T arvo)</code>, joka poistaa listalta <em>yhden</em> <code>arvo</code>-arvoisen alkion.
</p>

<p>
  Yksinkertainen toteutus olisi seuraava.
</p>


<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  this.arvot[i] = null;
  this.arvoja--;
  return true;
  }
  }
  
  return false;
  }
<% end %>

<p>
  Yllä oleva lähestymistapa on kuitenkin ongelmallinen, sillä se jättää listalle "tyhjiä" kohtia -- olettaen, että uudet arvot lisätään aina listan loppuun.
</p>

<p>
  Ongelman voi ratkaista useammalla tavalla, joista yksi on siirtää jokaista poistettua arvoa seuraavaa arvoa vasemmalle. Lisätään tämä toiminnallisuus ohjelmaan.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
  boolean loytyi = false;
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (loytyi) {
  this.arvot[i - 1] = this.arvot[i];
  } else if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  this.arvoja--;
  loytyi = true;
  }
  }
  }
<% end %>

<p>
  Emme ole kovin tyytyväisiä edelliseen ratkaisuun, sillä siinä tehdään monta asiaa samaan aikaan. Metodissa sekä etsitään alkiota että siirretään alkioita. Pilkotaan toiminnallisuus kahteen erilliseen metodiin: <code>private int arvonIndeksi(T arvo)</code>, joka etsii parametrina annetun arvon indeksin, sekä <code>private void siirraVasemmalle(int indeksista)</code>, joka siirtää annetusta indeksistä lähtien alkioita yhden vasemmalle.
</p>

<p>
  Toteutetaan ensin metodi <code>private int arvonIndeksi(T arvo)</code>, joka etsii annetun arvon indeksin. Metodi palauttaa negatiivisen luvun mikäli arvoa ei löydy.
</p>

<% partial 'partials/code_highlight' do %>
  private int arvonIndeksi(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  return i;
  }
  }

  return -1;
  }
<% end %>

<p>
  Toteutetaan tämän jälkeen metodi <code>private void siirraVasemmalle(int indeksistaLahtien)</code>, joka siirtää arvoja annetusta indeksistä lähtien vasemmalle.
</p>

<% partial 'partials/code_highlight' do %>
  private void siirraVasemmalle(int indeksistaLahtien) {
  for (int i = indeksistaLahtien; i &lt; this.arvoja - 1; i++) {
  this.arvot[i] = this.arvot[i + 1];
  }
  }
<% end %>

<p>
  Nyt metodi <code>poista</code> voidaan toteuttaa edellisten avulla hieman selkokielisemmäksi.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
  int arvonIndeksi = arvonIndeksi(arvo);
  if (arvonIndeksi &lt; 0) {
  return; // ei löydy
  }

  siirraVasemmalle(arvonIndeksi);
  this.arvoja--;
  }
<% end %>

<% partial 'partials/hint', locals: { name: 'Edellä kuvatun poistomenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi poiston yhteydessä jokaisen poistettua alkiota seuraavan alkion vasemmalle. Pohdi toteutuksen tehokkuutta tilanteessa, missä listaa käytetään jonona.
  </p>

  <p>
    Tämänkin menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>

<p>
  Luokassa lista on vieläkin vähän toistoa. Metodi <code>sisaltaa</code> on hyvin samankaltainen metodin <code>arvonIndeksi</code> kanssa. Muokataan vielä metodia <code>sisaltaa</code> siten, että se toteutetaan metodin <code>arvonIndeksi</code> avulla.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
  return arvonIndeksi(arvo) &gt;= 0;
  }
<% end %>

<p>
  Nyt käytössämme on lista, joka tarjoaa metodit <code>lisaa</code>, <code>sisaltaa</code>, ja <code>poista</code>. Lista myös kasvaa tarvittaessa. Listan toteutusta voisi toki vielä kehittää esimerkiksi lisäämällä toiminnallisuuden, mikä pienentää listan kokoa jos arvojen määrä pienenee hyvin pieneksi.
</p>


<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Kohdasta hakeminen
<% end %>

<p>
  Lisätään listalle vielä metodi <code>public T arvo(int indeksi)</code>, joka palauttaa listan tietyssä indeksissä sijaitsevan arvon. Mikäli ohjelmoija hakee arvoa listan ulkopuolelta, heitetään virhe <code>IndexOutOfBoundsException</code>. 
</p>

<% partial 'partials/code_highlight' do %>
  public T arvo(int indeksi) {
  if (indeksi &lt; 0 || indeksi &gt;= this.arvoja) {
  throw new ArrayIndexOutOfBoundsException("Indeksi " + indeksi + " alueen [0, " + this.arvoja + "[ ulkopuolella.");
  }

  return this.arvot[indeksi];
  }
<% end %>

<p>
  Metodi ei ole sellaisenaan kovin hyödyllinen, sillä ohjelmoijalla ei ole tietoa arvojen indekseistä. Muutetaan vielä metodi <code>arvonIndeksi(T arvo)</code> kaikkien käytettäväksi, eli vaihdetaan sen näkyvyysmääre <code>private</code> muotoon <code>public</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public int arvonIndeksi(T arvo) {
  for (int i = 0; i &lt; this.arvoja; i++) {
  if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
  return i;
  }
  }

  return -1;
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  int indeksi = lista.arvonIndeksi("hei");
  System.out.println(indeksi);
  System.out.println(lista.arvo(indeksi));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  0
  hei
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan koko
<% end %>

<p>
  Lisätään listalle vielä metodi listan koon tarkastamiseen. Listan koon saa selville muuttujasta <code>arvoja</code>. 
</p> 

<% partial 'partials/code_highlight' do %>
  public int koko() {
  return this.arvoja;
  }
<% end %>

<p>
  Nyt listan alkioiden läpikäynti onnistuu mm. for-lauseella.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");

  for(int i = 0; i &lt; lista.koko(); i++) {
  System.out.println(lista.arvo(i)); 
  }
<% end %>

<% partial 'partials/sample_output' do %>
  hei
  maailma
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hajautustaulu
<% end %>

<p>
  Hajautustaulu on toteutettu taulukkona, missä jokainen alkio sisältää listan. Listalle tallennetaan (avain,arvo)-pareja. Käyttäjä voi hakea hajautustaulusta arvoja avaimen perusteella, ja toisaalta käyttäjä voi lisätä hajautustauluun avain-arvo -pareja. Kukin avain voi esiintyä hajautustaulussa korkeintaan kerran.
</p>

<p>
  Hajautustaulun toiminta perustuu avaimen hajautusarvoon. Kun hajautustauluun lisätään (avain,arvo)-pari, lasketaan avaimeen liittyvä hajautusarvo. Hajautusarvo määrää hajautustaulun sisäisen taulukon indeksin, missä olevaan listaan (avain,arvo)-pari lisätään.
</p>

<p>
  Hahmotellaan hajautustaulun toimintaa.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Avain-arvo -pari
<% end %>

<p>
  Luodaan ensin avain-arvo -paria kuvaava luokka <code>Pari</code>. Haluamme tehdä hajautustaulusta mahdollisimman yleiskäyttöisen, joten avaimen ja arvon tyyppi määrätään ajonaikaisesti. Pari sisältää avaimen ja arvon sekä niihin liittyvät get- ja set-metodit.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;K, V&gt; {

  private K avain;
  private V arvo;

  public Pari(K avain, V arvo) {
  this.avain = avain;
  this.arvo = arvo;
  }

  public K getAvain() {
  return avain;
  }

  public void setAvain(K avain) {
  this.avain = avain;
  }

  public V getArvo() {
  return arvo;
  }

  public void setArvo(V arvo) {
  this.arvo = arvo;
  }

  }
<% end %>

<p>
  Avain-arvo -parien luominen on suoraviivaista.
</p>

<% partial 'partials/code_highlight' do %>
  Pari&lt;String, Integer&gt; pari = new Pari&lt;&gt;("yksi", 1);
  System.out.println(pari.getAvain() + " -&gt; " + pari.getArvo());
<% end %>


<% partial 'partials/sample_output' do %>
  yksi -&gt; 1
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustaulun luominen
<% end %>

<p>
  Hajautustaulu sisältää taulukon listoja. Jokainen listan arvo on edellä kuvattu pari, joka sisältää avain-arvo -parin. Hajautustaululla on lisäksi tieto arvojen lukumäärästä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Hajautustaulu&lt;K, V&gt; {

  private Lista&lt;Pari&lt;K, V&gt;&gt;[] arvot;
  private int arvoja;

  public Hajautustaulu() {
  this.arvot = new Lista[32];
  this.arvoja = 0;
  }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon hakeminen
<% end %>

<p>
  Toteutetaan ensin metodi <code>public V hae(K avain)</code>, jota käytetään arvon hakemiseen avaimen perusteella. Metodissa lasketaan ensin avaimen hajautusarvo ja päätellään sen perusteella hajautustaulun sisäisen taulukon indeksi, mistä arvoja haetaan. Mikäli kyseisessä indeksissä ei ole listaa, ei indeksiin ole lisätty vielä yhtäkään avain-arvo -paria, eikä avaimelle ole tallennettu arvoa. Tällöin palautetaan null. Muussa tapauksessa taulukon indeksissä oleva lista käydään läpi, ja avaimen yhtäsuuruutta vertaillaan jokaiseen listan avain-arvo -parin avaimeen. Mikäli joku listalla olevista avaimista vastaa avainta, jonka perusteella arvoa haetaan, palautetaan kyseinen arvo. Muulloin avainta (ja siihen liittyvää arvoa) ei löydy, ja palautetaan arvo null.
</p>

<% partial 'partials/code_highlight' do %>
  public V hae(K avain) {
  int hajautusArvo = Math.abs(avain.hashCode() % this.arvot.length);
  if (this.arvot[hajautusArvo] == null) {
  return null;
  }
  
  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = this.arvot[hajautusArvo];

  for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
  if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
  return arvotIndeksissa.arvo(i).getArvo();
  }
  }
  
  return null;
  }
<% end %>


<% partial 'partials/hint', locals: { name: 'Miksei hajautustaulua toteuteta listana?' } do %>

  <p>
    Hajautustaulun toimintaperiaate perustuu siihen, että avain-arvo -parit jaetaan hajautusarvon perusteella pieniin joukkoihin. Tällöin avaimen perusteella haettaessa käydään läpi vain hyvin pieni joukko avain-arvo -pareja -- olettaen toki, että hajautusarvo on järkevä.
  </p>

  <p>
    Jos hajautusarvo on aina sama -- esimerkiksi 1 -- vastaa hajautustaulun sisäinen toteutus listaa -- kaikki arvot ovat samalla listalla. Jos taas hajautusarvo on hyvin satunnainen, arvot hajautetaan mahdollisimman tasaisesti taulukon eri listoille.
  </p>

  <p>
    Hajautustaulu toimii lisäksi siten, että hajautustaulun käyttämää taulukkoa kasvatetaan mikäli arvojen määrä on tarpeeksi iso (tyypillisesti noin 75% taulukon koosta). Tyypillisesti miljoonia avain-arvo -pareja sisältävän hajautustaulun taulukon yhdessä indeksissä on vain muutama avain-arvo -pari. Tämä tarkoittaa käytännössä sitä, että avain-arvo -parin olemassaolon selvittämiseen tarvitaan vain hajautusarvon laskeminen sekä muutaman olion tarkastelu -- tämä on paljon nopeampaa kuin listan läpikäynti.
  </p>
  
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 1
<% end %>

<p>
  Toteutetaan hajautustauluun lisäämisen käytettävän metodin <code>public void lisaa(K avain, V arvo)</code> ensimmäinen versio. Ensimmäisessä versiossa hajautustaulun sisältämän taulukon kokoa ei kasvateta lisäyksen yhteydessä.
</p>

<p>
  Metodi laskee ensin avaimelle hajautusarvon ja päättelee hajautusarvon perusteella hajautustaulun sisäisen taulukon indeksin. Jos taulukon kyseisessä indeksissä ei ole arvoa, taulukon indeksiin lisätään lista. Tämän jälkeen taulukon indeksissä oleva lista käydään läpi ja sieltä etsitään avain-arvo -paria, jonka avain vastaa lisättävän avain-arvo -parin avainta. Mikäli vastaava avain löytyy, päivitetään olemassaolevan avain-arvo -parin arvo vastaamaan uutta avainta. Muulloin listaan lisätään uusi avain-arvo -pari -- tällöin myös hajautustaulussa olevien arvojen lukumäärää kasvatetaan yhdellä.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
  int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
  if (arvot[hajautusArvo] == null) {
  arvot[hajautusArvo] = new Lista<>();
  }

  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = arvot[hajautusArvo];

  int indeksi = -1;
  for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
  if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
  indeksi = i;
  break;
  }
  }

  if (indeksi &lt; 0) {
  arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
  this.arvoja++;
  } else {
  arvotIndeksissa.arvo(indeksi).setArvo(arvo);
  }
  }
<% end %>

<p>
  Metodi on melko monimutkainen. Pilkotaan se pienempiin osiin -- ensimmäisen osan vastuulla on avaimeen liittyvän listan hakeminen ja toisen osan vastuulla on avaimen indeksin etsiminen listalta.
</p>

<% partial 'partials/code_highlight' do %>
  private Lista&lt;Pari&lt;K, V&gt;&gt; haeAvaimeenLittyvaLista(K avain) {
  int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
  if (arvot[hajautusArvo] == null) {
  arvot[hajautusArvo] = new Lista&lt;&gt;();
  }

  return arvot[hajautusArvo];
  }
  
  private int haeAvaimenIndeksi(Lista&lt;Pari&lt;K, V&gt;&gt; lista, K avain) {
  for (int i = 0; i &lt; lista.koko(); i++) {
  if (lista.arvo(i).getAvain().equals(avain)) {
  return i;
  }
  }

  return -1;
  }
<% end %>

<p>
  Nyt metodi <code>public void lisaa(K avain, V arvo)</code> voidaan toteuttaa hieman selkeämmin.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
  int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);

  if (indeksi &lt; 0) {
  arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
  this.arvoja++;
  } else {
  arvotIndeksissa.arvo(indeksi).setArvo(arvo);
  }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 2
<% end %>

<p>
  Edellä kuvattu hajautustauluun lisääminen toimii osittain. Toiminnallisuuden suurin puute on se, että taulukon kokoa ei kasvateta kun arvojen määrä kasvaa liian suureksi. Lisätään ohjelmaan kasvatustoiminnallisuus, mikä tuplaa hajautustaulun sisäisen taulukon koon. Kasvatustoiminnallisuuden tulee myös sijoittaa jokainen hajautustaulussa olevan taulukon arvo uuteen taulukkoon.
</p>

<p>
  Hahmotellaan kasvatustoiminnallisuuden alku. Kasvatustoiminnallisuudessa luodaan uusi taulukko, jonka koko on edelliseen verrattuna kaksinkertainen. Tämän jälkeen alkuperäinen taulukko käydään indeksi indeksiltä läpi ja olemassaolevat avain-arvo -parit kopioidaan uuteen taulukkoon. Lopulta alkuperäinen taulukko korvataan uudella taulukolla.
</p>

<p>
  Alla on hahmoteltu metodin toimintaa. Kopiointia ei ole vielä toteutettu.
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
  // luodaan uusi taulukko
  Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

  for (int i = 0; i &lt; this.arvot.length; i++) {
  // kopioidaan vanhan taulukon arvot uuteen

  }

  // korvataan vanha taulukko uudella
  this.arvot = uusi;
<% end %>

<p>
  Hahmotellaan seuraavaksi metodia, joka kopioi alkuperäisen taulukon yhden indeksin sisältämän listan arvot uuteen taulukkoon. Kopioinnin yhteydessä jokaisen kopioitavan avain-arvo -parin sijainti taulukossa lasketaan uudelleen -- tämä tehdään, sillä taustalla olevan taulukon koko kasvaa ja avain-arvot -parit halutaan sijoittaa taulukkoon mahdollisimman tasaisesti.
</p>

<% partial 'partials/code_highlight' do %>
  private void kopioi(Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi, int indeksista) {
  for (int i = 0; i &lt; this.arvot[indeksista].koko(); i++) {
  Pari&lt;K, V&gt; arvo = this.arvot[indeksista].arvo(i);
  
  int hajautusarvo = Math.abs(arvo.getAvain().hashCode() % uusi.length);
  if(uusi[hajautusarvo] == null) {
  uusi[hajautusarvo] = new Lista&lt;&gt;();
  }
  
  uusi[hajautusarvo].lisaa(arvo);
  }
  }
<% end %>

<p>
  Nyt kopioi-metodia voidaan kutsua kasvata-metodista.
</p>


<% partial 'partials/code_highlight' do %>
  private void kasvata() {
  // luodaan uusi taulukko
  Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

  for (int i = 0; i &lt; this.arvot.length; i++) {
  // kopioidaan vanhan taulukon arvot uuteen
  kasvata(uusi, indeksista);
  }

  // korvataan vanha taulukko uudella
  this.arvot = uusi;
<% end %>

<p>
  <em>
    Metodissa on pieni virhe. Selvitä mistä virheessä on kyse ja korjaa se.
  </em>
</p>

<p>
  Lisätään lopuksi kasvatustoiminnallisuus osaksi lisäystoiminnallisuutta. Hajautustaulun kokoa kasvatetaan aina jos hajautustaulussa olevien avain-arvo -parien määrä on yli 75% taulukon koosta.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
  Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
  int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);

  if (indeksi &lt; 0) {
  arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
  this.arvoja++;
  } else {
  arvotIndeksissa.arvo(indeksi).setArvo(arvo);
  }

  if (1.0 * this.arvoja / this.arvot.length &gt; 0.75) {
  kasvata();
  }
  }
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Poistaminen
<% end %>

<p>
  Lisätään hajautustauluun vielä toiminnallisuus avain-arvo -parin poistamiseen avaimen perusteella. Poistotoiminnallisuus palauttaa null-arvon mikäli arvoa ei löydy, muuten metodi palauttaa poistettavaan avaimeen liittyvän arvon.
</p>

<p>
  Voimme hyödyntää valmiiksi toteuttamiamme metodeja poistotoiminnallisuudessa. Selitä itsellesi (ääneen) alla olevan metodin konkreettinen toiminta.
</p>


<% partial 'partials/code_highlight' do %>
  public V poista(K avain) {
  Lista&Lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
  if (arvotIndeksissa == null || arvotIndeksissa.koko() == 0) {
  return null;
  }

  int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
  if (indeksi &lt; 0) {
  return null;
  }

  Pari&lt;K, V&gt; pari = arvotIndeksissa.arvo(indeksi);
  arvotIndeksissa.poista(pari);
  return pari.getArvo();
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hakemisen tehokkuudesta
<% end %>

<p>
  Tarkastellaan vielä hakemisen tehokkuutta listasta ja hajautustaulusta. Tehokkuusmittauksia voi tehdä metodin <code>System.nanotime()</code> palauttaman nanosekunteja kuvaavan arvon avulla. Ohjelma luo ensin miljoona alkiota hajautustauluun ja listaan, jonka jälkeen hajautustaulusta ja listasta etsitään tuhatta satunnaista arvoa. Noin 50% arvoista löytyy listalta ja hajautustaulusta.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  Hajautustaulu&lt;String, String&gt; taulu = new Hajautustaulu&lt;&gt;();

  for (int i = 0; i &lt; 1000000; i++) {
  lista.lisaa("" + i);
  taulu.lisaa("" + i, "" + i);
  }

  Lista&lt;String&gt; haettavat = new Lista&lt;&gt;();
  Random arpoja = new Random();
  for (int i = 0; i &lt; 1000; i++) {
  haettavat.lisaa("" + arpoja.nextInt(2000000));
  }

  long listanHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
  lista.sisaltaa(haettavat.arvo(i));            
  }
  long listanHakuLopetus = System.nanoTime();
  
  long hajautustaulunHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
  taulu.hae(haettavat.arvo(i));            
  }
  long hajautustaulunHakuLopetus = System.nanoTime();

  
  long listanHaku = listanHakuLopetus - listanHakuAloitus;
  System.out.println("Lista: haku kesti noin " + listanHaku / 1000000 + " millisekuntia (" +
  listanHaku + " nanosekuntia.)");
  
  long hajautustaulunHaku = hajautustaulunHakuLopetus - hajautustaulunHakuAloitus;
  System.out.println("Hajautustaulu: haku kesti noin " + hajautustaulunHaku / 1000000 +
  " millisekuntia (" + hajautustaulunHaku + " nanosekuntia.)");
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista: haku kesti noin 6284 millisekuntia (6284420580 nanosekuntia.)
  Hajautustaulu: haku kesti noin 0 millisekuntia (805106 nanosekuntia.)
<% end %>

<p>
  <em>
    Edellä kuvatut ja kursseilla käyttämämme listat ja hajautustaulut poikkeavat toki sisäiseltä toteutukselta hieman toisistaan. Ohjelmointikielten tarjoamissa tietorakenteissa on hieman enemmän erilaisia optimointeja -- näihinkin palataan myöhemmillä kursseilla. Tämän kurssin puitteissa riittää em. tietorakenteiden käyttöosaaminen sekä jonkintasoinen ymmärrys niiden tehokkuuseroista sekä käyttötapauksista.
  </em>
</p>

<% partial 'partials/exercise', locals: { name: 'Lista ja hajautustaulu (11 osaa)' } do %>

  <p>
    Toteuta edellistä esimerkkiä noudattaen luokat Lista ja Hajautustaulu pakkaukseen <code>tietorakenteita</code>. Kohdat on pisteytetty askeleittain, jotka ovat seuraavat:
  </p>

  <ol>
    <li>
      Listan luominen
    </li>
    <li>
      Arvojen lisääminen listalle (osat 1 ja 2)
    </li>
    <li>
      Listalla olevan arvon olemassaolon tarkastaminen
    </li>
    <li>
      Listalla olevan arvon poistaminen
    </li>
    <li>
      Listan indeksistä hakeminen ja listan koko
    </li>
    <li>
      Avain-arvo -paria kuvaavan luokan toteutus
    </li>
    <li>
      Hajautustaulun luominen
    </li>
    <li>
      Arvon hakeminen hajautustaulusta
    </li>
    <li>
      Hajautustauluun lisääminen (ei kasvatusta)
    </li>
    <li>
      Hajautustaulun koon kasvattaminen tarvittaessa
    </li>
    <li>
      Hajautustaulusta poistaminen
    </li>
  </ol>
  
  <p>
    Sitä mukaa kun kehität listaa ja hajautustaulua, päivitä luokan Ohjelma metodia <code>osiaToteutettu</code> palauttamaan valmiiksi saamasi osan numero. Voit palauttaa tehtävän vaikket tekisikään kaikkia osia, jolloin saat pisteitä tehtävän niistä osista, jotka olet tehnyt.
  </p>

  <p>
    Esimerkiksi, kun olet saanut listan luomisen, arvojen lisäämisen ja arvon poistamisen toimimaan, olet vaiheessa 3, jolloin metodin <code>osiaToteutettu</code> tulisi palautta arvo <code>3</code>.
  </p>
  
<% end %>




<%= partial 'partials/quiz', locals: { id: '5a25a1ff1bbf3a0004538a89' } %>

<%= partial 'partials/quiz', locals: { id: '5a2d21331ffcd00004997916' } %>


