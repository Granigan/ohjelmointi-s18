---
  title: Osa 5
  exercise_page: true
  quiz_page: true
  published: false
---



<% partial 'partials/hint', locals: { name: 'Viidennen osan tavoitteet' } do %>

  <p>
    
    
    Tietää olio-ohjelmoinnin perusperiaatteet ja luo luokkia, jotka kuvaavat annettua ongelma-aluetta. Tunnistaa käsitteet alkeis- ja viittaustyyppinen muuttuja. Osaa määritellä olioita, jotka sisältävät olioita. Osaa käyttää olioita metodin parametrina sekä luoda metodeja, jotka palauttavat olioita. Tuntee listarakenteen ja osaa lisätä ja poistaa listalla olevia alkioita. Tuntee käsitteen indeksi ja osaa käydä listan läpi while-toistolauseen avulla.
    
    Ymmärtää alkeis- ja viittaustyyppisten muuttujien erot. Osaa käsitellä olioita listarakenteessa sekä käyttää listaa oliomuuttujana. Ymmärtää automaattisen testaamisen periaatteet ja osaa luoda yksinkertaisen luokan toimintaa testaavia automaattisia testejä. 
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Oliot ja viitteet
<% end %>


<p>
  Oletetaan, että käytössämme on alla oleva luokka.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {

  private String nimi;
  private int ika;
  private int paino;
  private int pituus;

  public Henkilo(String nimi) {
  this.nimi = nimi;
  this.ika = 0;
  this.paino = 0;
  this.pituus = 0;
  }

  // muita konstruktoreja ja metodeja
  
  public String getNimi() {
  return this.nimi;
  }
  
  public int getIka() {
  return this.ika;
  }
  
  public void vanhene() {
  this.ika++;
  }
  
  public void setPituus(int uusiPituus) {
  this.pituus = uusiPituus;
  }
  
  public void setPaino(int uusiPaino) {
  this.paino = uusiPaino;
  }
  
  public double painoIndeksi() {
  double pituusPerSata = this.pituus / 100.0;
  return this.paino / (pituusPerSata * pituusPerSata);
  }
  
  @Override
  public String toString() {
  return this.nimi + ", ikä " + this.ika + " vuotta";
  }
  }
<% end %>

<p>
  Mitä oikein tapahtuu kun olio luodaan?
</p>


<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
<% end %>

<p>
  Konstruktorikutsun <code>new</code> yhteydessä tapahtuu monta asiaa. Ensin tietokoneen muistista varataan tila oliomuuttujille. Tämän jälkeen oliomuuttujiin asetetaan oletus- tai alkuarvot (esimerkiksi int-tyyppisten muuttujien arvoksi tulee 0). Lopulta suoritetaan konstruktorissa oleva lähdekoodi.
</p>

<p>
  Konstruktorikutsu palauttaa viitteen olioon. <strong>Viite</strong> on tieto olioon liittyvien tietojen paikasta.
</p>

<img src="/img/drawings/olio-joan.png"/>

<p>
  Muuttujan arvoksi asetetaan siis viite, eli tieto olioon liittyvien tietojen paikasta. Yllä oleva kuva paljastaa myös sen, että nimi -- tai tarkemmin merkkijonot -- ovat myös olioita.
</p>

<% partial 'partials/material_sub_heading' do %>
  Muuttujan arvon asettaminen kopioi viitteen
<% end %>


<p>
  Lisätään ohjelmaan <code>Henkilo</code>-tyyppinen muuttuja <code>ball</code> ja annetaan sille alkuarvoksi <code>joan</code>. Mitä nyt tapahtuu?
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
<% end %>

<p>
  Lause <code>Henkilo ball = joan;</code> luo uuden henkilömuuttujan, jonka arvoksi kopioidaan muuttujan <code>joan</code> arvo. Tämä saa aikaan sen, että <code>ball</code> viittaa samaan olioon kuin <code>joan</code>.
</p>

<img src="/img/drawings/olio-joan-ja-ball.png"/>

<p>
  Tarkastellan samaa esimerkkiä hieman pidemmälle.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);
<% end %>

<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  Joan Ball, ikä 2 vuotta
<% end %>


<p>
  Joan Ball -- eli henkilöolio, johon viite muuttujassa <code>joan</code> osoittaa -- on alussa 0-vuotias. Tämän jälkeen muuttujaan <code>ball</code> asetetaan (eli <strong>kopioidaan</strong>) muuttujan <code>joan</code> arvo. Henkilöoliota <code>ball</code> vanhennetaan kaksi vuotta ja sen seurauksena Joan Ball vanhenee!
</p>

<p>
  Olion sisäinen tila ei kopioidu muuttujan arvoa asetettaessa. Lauseessa <code>Henkilo ball = joan;</code> ei siis luoda henkilöä -- muuttujan ball arvoksi asetetaan kopio muuttujan joan arvosta, eli viite olioon.
</p>

<img src="/img/drawings/olio-joan-ja-ball-2.png"/>

<p>
  Seuraavassa esimerkkiä on jatkettu siten, että <code>joan</code>-muuttujaa varten luodaan uusi olio, jonka viite asetetaan muuttujan arvoksi. Muuttuja <code>ball</code> viittaa yhä aiemmin luotuun olioon.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);

  joan = new Henkilo("Joan B.");
  System.out.println(joan);
<% end %>

<p>
  Tulostuu:
</p>

<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  Joan Ball, ikä 2 vuotta
  Joan B., ikä 0 vuotta
<% end %>

<p>
  Muuttujassa <code>joan</code> on siis alussa viite yhteen olioon, mutta lopussa sen arvoksi on kopioitu toisen muuttujan viite. Seuraavassa kuva tilanteesta viimeisen koodirivin jälkeen.
</p>

<img src="/img/drawings/olio-joan-ja-ball-3.png"/>


<% partial 'partials/material_sub_heading' do %>
  Muuttujan arvo <code>null</code>
<% end %>


<p>
  Jatketaan vielä esimerkkiä asettamalla muuttujan <code>ball</code> arvoksi <code>null</code>, eli viite "ei mihinkään".
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);

  joan = new Henkilo("Joan B.");
  System.out.println(joan);

  ball = null;
<% end %>

<p>
  Viimeisen rivin jälkeen ohjelman tila on seuraavanlainen.
</p>

<img src="/img/drawings/olio-joan-ja-ball-null.png"/>

<p>
  Olioon, jonka nimi on Joan Ball, ei enää viittaa kukaan. Oliosta on siis tullut "roska". Java-ohjelmointikielessä ohjelmoijan ei tarvitse huolehtia ohjelman käyttämästä muistista. Javan automaattinen roskienkerääjä käy siivoamassa roskaksi joutuneet oliot aika ajoin. Jos automaattista roskien keruuta ei tapahtuisi, jäisivät roskaksi joutuneet oliot varaamaan muistia ohjelman suorituksen loppuun asti.
</p>

<p>
  Kokeillaan vielä mitä käy kun yritämme tulostaa muuttujaa, jonka arvona on viite "ei mihinkään" eli <code>null</code>.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);

  joan = new Henkilo("Joan B.");
  System.out.println(joan);

  ball = null;
  System.out.println(ball);
<% end %>


<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  Joan Ball, ikä 2 vuotta
  Joan B., ikä 0 vuotta
  null
<% end %>

<p>
  Viitteen <code>null</code> tulostus tulostaa "null". Entäpä jos yritämme kutsua ei mihinkään viittaavan olion metodia, esimerkiksi metodia <code>vanhene</code>:
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  joan = null;
  joan.vanhene();
<% end %>


<p>
  Tulos:
</p>

<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  <font color="red">Exception in thread "main" java.lang.NullPointerException
    at Main.main(Main.java:(rivi))
    Java Result: 1</font>
<% end %>

<p>
  Käy huonosti. Tämä on ehkä ensimmäinen kerta kun näet tekstin <strong>NullPointerException</strong>. Ohjelmassa tapahtuu virhe, joka liittyy siihen, että olemme kutsuneet ei mihinkään viittaavan muuttujan metodia.
</p>

<p>
  Voimme luvata, että tulet näkemään edellisen virheen vielä uudelleen. Tällöin ensimmäinen askel on etsiä muuttujia, joiden arvona saattaisi olla <code>null</code>. Virheilmoitus on onneksi myös hyödyllinen: se kertoo millä rivillä virhe tapahtuu. Kokeile vaikka itse!
</p>


<% partial 'partials/exercise', locals: { name: 'NullPointerException' } do %>

  <p>
    Toteuta ohjelma, jonka suorittaminen aiheuttaa virheen NullPointerException. Virheen tulee tapahtua heti kun ohjelma suoritetaan -- älä siis esimerkiksi lue käyttäjältä syötettä.
  </p>

<% end %>

<p>&nbsp;</p>

<% partial 'partials/material_sub_heading' do %>
  Olio oliomuuttujana
<% end %>


<p>
  Oliot voivat sisältää viitteitä olioihin.
</p>

<p>
  Jatketaan <code>Henkilo</code>-luokan parissa ja lisätään henkilölle syntymäpäivä. Syntymäpäivä on luonnollista esittää <code>Paivays</code>-olion avulla:
</p>


<% partial 'partials/code_highlight' do %>
  public class Paivays {
  private int paiva;
  private int kuukausi;
  private int vuosi;

  public Paivays(int paiva, int kuukausi, int vuosi) {
  this.paiva = paiva;
  this.kuukausi = kuukausi;
  this.vuosi = vuosi;
  }

  public int getPaiva() {
  return this.paiva;
  }

  public int getKuukausi() {
  return this.kuukausi;
  }

  public int getVuosi() {
  return this.vuosi;
  }

  @Override
  public String toString() {
  return this.paiva + "." + this.kuukausi + "." + this.vuosi;
  }
  }
<% end %>

<p>
  Koska tiedämme syntymäpäivän, henkilön ikää ei enää tarvitse säilöä. Se on pääteltävissä syntymäpäivästä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
  private String nimi;
  private Paivays syntymaPaiva;
  private int paino = 0;
  private int pituus = 0;

  // ...
<% end %>

<p>
  Tehdään henkilölle uusi konstruktori, joka mahdollistaa syntymäpäivän asettamisen:
</p>

<% partial 'partials/code_highlight' do %>
  public Henkilo(String nimi, int paiva, int kuukausi, int vuosi) {
  this.nimi = nimi;
  this.syntymaPaiva = new Paivays(paiva, kuukausi, vuosi);
  this.paino = 0;
  this.pituus = 0;
  }
<% end %>


<p>
  Konstruktorin parametrina annetaan erikseen päiväyksen osat (päivä, kuukausi, vuosi), niistä luodaan päiväysolio, ja lopulta päiväysolion viite kopioidaan oliomuuttujan <code>syntymaPaiva</code> arvoksi.
</p>

<p>
  Muokataan Henkilo-luokassa olevaa <code>toString</code>-metodia siten, että metodi palauttaa iän sijaan syntymäpäivän:
</p>

<% partial 'partials/code_highlight' do %>
  public String toString() {
  return this.nimi + ", syntynyt " + this.syntymaPaiva;
  }
<% end %>

<p>
  Kokeillaan miten uusittu Henkilöluokka toimii.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo muhammad = new Henkilo("Muhammad ibn Musa al-Khwarizmi", 1, 1, 780);
  Henkilo pascal = new Henkilo("Blaise Pascal", 19, 6, 1623);

  System.out.println(muhammad);
  System.out.println(pascal);
<% end %>


<% partial 'partials/sample_output' do %>
  Muhammad ibn Musa al-Khwarizmi, syntynyt 1.1.870
  Blaise Pascal, syntynyt 19.6.1623
<% end %>


<p>
  Henkilöoliolla on nyt oliomuuttujat <code>nimi</code> ja <code>syntymaPaiva</code>. Muuttuja <code>nimi</code> on merkkijono, joka sekin on siis olio, ja muuttuja <code>syntymaPaiva</code> on Päiväysolio.
</p>

<p>
  Molemmat muuttujat sisältävät arvon olioon. Henkilöolio sisältää siis kaksi viitettä.
</p>


<img src="/img/drawings/muhammad-ja-pascal.png"/>

<p>&nbsp;</p>

<p>
  Pääohjelmalla on nyt siis langan päässä kaksi Henkilö-olioa. Henkilöllä on nimi ja syntymäpäivä. Koska molemmat ovat olioita, ovat ne henkilöllä langan päässä.
</p>

<p>
  Syntymäpäivä vaikuttaa hyvältä laajennukselta Henkilö-luokkaan. Totesimme aiemmin, että oliomuuttuja <code>ika</code> voidaan laskea syntymäpäivästä, joten siitä hankkiuduttiin eroon.
</p>

<p>
  Javassa nykyinen päivä selviää seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  import java.time.LocalDate;
  // ...
  
  LocalDate nyt = LocalDate.now();
  int vuosi = nyt.getYear();
  int kuukausi = nyt.getMonthValue();
  int paiva = nyt.getDayOfMonth();
  
  System.out.println("tänään on " + paiva + "." + kuukausi + "." + vuosi);
  // ...
<% end %>


<% partial 'partials/exercise', locals: { name: 'Ikä vuosina' } do %>

  <p>
    Tehtäväpohjassa tulee mukana edellä nähdyt luokat Henkilo ja Paivays. Täydennä luokan Henkilo metodia <code>public int ikaVuosina()</code> siten, että se laskee ja palauttaa henkilön tämän hetkisen iän vuosina.
  </p>

  <p>
    Voit olettaa, että jokaisessa vuodessa on tasan 360 päivää.
  </p>

  <p>
    <strong>Vinkki!</strong> Näppärä lähestymistapa on laskea päivien summa vuosien, kuukausien ja päivien perusteella. Erottamalla "nykypäivää" vastaavan päivien summan syntymäpäivän päivien summasta saat elettyjen päivien määrän. Eletyt päivät saa muunnettua takaisin vuosiksi jakolaskulla.
  </p>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Kellosta olio' } do %>

  <p>
    Teimme aiemmin luokan <code>YlhaaltaRajoitettuLaskuri</code> ja rakennettiin laskurien avulla pääohjelmaan kello. Tehdään tässä tehtävässä kellostakin oma olio -- kello sisältää kolme viisaria, jotka jokainen esitetään ylhäältä rajoitetun laskurin avulla. Luokan kello runko näyttää seuraavalta:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kello {
    private YlhaaltaRajoitettuLaskuri tunnit;
    private YlhaaltaRajoitettuLaskuri minuutit;
    private YlhaaltaRajoitettuLaskuri sekunnit;

    public Kello(int tunnitAlussa, int minuutitAlussa, int sekunnitAlussa) {
    // laskurit tunneille, minuuteille ja sekunneille;
    // laskurien arvot tulee asettaa parametreina saatuun aikaan
    }

    public void etene() {
    // kello etenee sekunnilla
    }

    public String toString() {
    // palauttaa kellon merkkijonoesityksen
    }
    }
  <% end %>

  <p>
    Luokkaan YlhaaltaRajoitettuLaskuri on kopioitu eräs ratkaisu viime osan tehtävään. Toteuta luokan <code>Kello</code> konstruktori ja puuttuvat metodit kolmea ylhäältä rajoitettua laskuria hyödyntäen.
  </p>

  <p>
    Voit testata kelloasi seuraavalla pääohjelmalla:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
    public static void main(String[] args) {
    Kello kello = new Kello(23, 59, 50);

    int i = 0;
    while (i &lt; 20) {
    System.out.println(kello);
    kello.etene();
    i++;
    }
    }
    }
  <% end %>

  <p>
    Tulostuksen tulisi edetä seuraavasti:
  </p>

  <% partial 'partials/sample_output' do %>
    23:59:50
    23:59:51
    23:59:52
    23:59:53
    23:59:54
    23:59:55
    23:59:56
    23:59:57
    23:59:58
    23:59:59
    00:00:00
    00:00:01
    ...
  <% end %>

<% end %>




<% partial 'partials/hint', locals: { name: 'Algoritmi -- al-Khwarizmi' } do %>

  <p>
    Ensimmäiset korkeakulttuurit syntyivät (laajemman) lähi-idän alueelle, mikä nopeutti siellä myös henkistä kasvua. Lähi-idässä oltiin merkittävästi muuta maailmaa edellä muunmuassa matematiikassa ja tähtitieteessä -- esimerkiksi Euroopassa 1500-luvulla tapahtunut murros tähtitieteessä (maa kiertääkin aurinkoa eikä toisin päin), tapahtui laajemman lähi-idän vaikutuspiirissä olleessa kreikassa jo noin 300 vuotta ennen ajanlaskumme alkua.
  </p>

  <p>
    Nimi al-Khwarizmi viittaa oikeastaan alueeseen, tai hieman laajemmin, etuosa al- viittaa usein henkilön synty- tai kotipaikkaan. <a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi" target="_blank" rel="noopener">Muhammad ibn Musa al-Khwarizmi</a> -- tai hänen isänsä tai esi-isänsä -- tulivat keskiaasiasta alueelta, joka tunnetaan nykyään suomen kielessä nimellä Harezm. Nykyään käytetty termi algoritmi on siis sekä hatunnosto Muhammad ibn Musa al-Khwarizmille, että laajemmin hänen syntyperälleen.
  </p>

  <p>
    Merkittävä osa al-Khwarizmin työstä tapahtui Baghdadissa sijaitsevassa Viisauden talossa, joka paikallisen hallinnon tukemana keräsi tiedemiehiä eri puolilta maailmaa yhteen. Tavoitteena oli "pienimuotoisesti" kerätä kaikki maailman tieto yhteen paikkaan ja kääntää se arabian kielelle, jota sitten jaettiin eteenpäin. Tätä kautta tietoa valui myös eurooppaan: esimerkiksi al-Khwarizmin kirja intialaisilla numeroilla laskemisesta (latinaksi "Algoritmi de numero Indorum") toi arabialaisten numeroiden käytön eurooppaan.
  </p>

  <p>
    Tämä terminologia näkyy yhä esimerkikiksi espanjan kielessä. Espanjankielinen sana guarismo -- eli suomeksi luku -- tulee ilmeisesti juurikin al-Khwarizmin nimestä.
  </p>

  <p>
    Vaikka Muhammad ibn Musa al-Khwarizmi kytketään nykyään -- ainakin tietojenkäsittelytieteilijöiden parissa -- ensisijaisesti algoritmeihin, on hän ennen kaikkea vaikuttanut merkittävästi algebran kehitykseen. Hänen työnsä tuolla alueella kontribuoi mm. ensimmäisen ja toisen asteen yhtälöiden ratkaisemiseen. Työn keskiössä olivat konkreettiset esimerkit sekä selkokieliset askeleittaiset ratkaisut  -- numeroita tuossa työssä ei esiintynyt.
  </p>


<% end %>



<% partial 'partials/material_sub_heading' do %>
  Olio metodin parametrina
<% end %>


<p>
  Olemme nähneet että metodien parametrina voi olla esimerkiksi <code>int</code> tai <code>String</code> tyyppisiä muuttujia. Kuten arvata saattaa, metodin parametriksi voi määritellä minkä tahansa tyyppisen olion. Demonstroidaan tätä esimerkillä.
</p>

<p>
  Painonvartijoihin hyväksytään jäseniksi henkilöitä, joiden painoindeksi ylittää annetun rajan. Kaikissa painonvartijayhdistyksissä raja ei ole sama. Tehdään painonvartijayhdistystä vastaava luokka. Olioa luotaessa konstruktorille annetaan parametriksi pienin painoindeksi, jolla yhdistyksen jäseneksi pääsee.
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
  private double alinPainoindeksi;

  public PainonvartijaYhdistys(double indeksiRaja) {
  this.alinPainoindeksi = indeksiRaja;
  }
  }
<% end %>

<p>
  Tehdään seuraavaksi metodi, jonka avulla voidaan tarkastaa hyväksytäänkö tietty henkilö yhdistyksen jäseneksi, eli onko henkilön painoindeksi tarpeeksi suuri. Metodi palauttaa <code>true</code> jos parametrina annettu henkilö hyväksytään, <code>false</code> jos ei.
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
  private double alinPainoindeksi;

  public PainonvartijaYhdistys(double indeksiRaja) {
  this.alinPainoindeksi = indeksiRaja;
  }

  public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
  if (henkilo.painoIndeksi() &lt; this.alinPainoindeksi) {
  return false;
  }

  return true;
  }
  }
<% end %>

<p>
  Painonvartijayhdistys-olion metodille <code>hyvaksytaanJaseneksi</code> annetaan siis parametrina <code>Henkilo</code>-olio. Kuten aiemmin, muuttujan arvo -- eli tässä viite -- kopioituu metodin käyttöön. Metodissa käsitellään kopioitua viitettä ja kutsutaan parametrina saadun henkilön metodia <code>painoIndeksi</code>.
</p>

<p>
  Seuraavassa testipääohjelma jossa painonvartijayhdistyksen metodille annetaan ensin parametriksi henkilöolio <code>matti</code> ja sen jälkeen henkilöolio <code>juhana</code>:
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo matti = new Henkilo("Matti");
  matti.setPaino(86);
  matti.setPituus(180);

  Henkilo juhana = new Henkilo("Juhana");
  juhana.setPaino(64);
  juhana.setPituus(172);

  PainonvartijaYhdistys kumpulanPaino = new PainonvartijaYhdistys(25);

  if (kumpulanPaino.hyvaksytaanJaseneksi(matti)) {
  System.out.println(matti.getNimi() + " pääsee jäseneksi");
  } else {
  System.out.println(matti.getNimi() + " ei pääse jäseneksi");
  }

  if (kumpulanPaino.hyvaksytaanJaseneksi(juhana)) {
  System.out.println(juhana.getNimi() + " pääsee jäseneksi");
  } else {
  System.out.println(juhana.getNimi() + " ei pääse jäseneksi");
  }
<% end %>

<p> Ohjelma tulostaa: </p>

<% partial 'partials/sample_output' do %>
  Matti pääsee jäseneksi
  Juhana ei pääse jäseneksi
<% end %>




<% partial 'partials/hint', locals: { name: 'Konstruktorien, getterien ja setterien automaattinen generointi' } do %>

  <p>
    Ohjelmointiympäristöt osaavat auttaa ohjelmoijaa. Jos luokalle on määriteltynä oliomuuttujat, onnistuu konstruktorien, getterien ja setterien generointi automaattisesti.
  </p>

  <p>
    Mene luokan koodilohkon sisäpuolelle mutta kaikkien metodien ulkopuolelle ja paina yhtä aikaa ctrl ja välilyönti. Jos luokallasi on esim. oliomuuttuja <code>saldo</code>, tarjoaa NetBeans mahdollisuuden generoida oliomuuttujalle getteri- ja setterimetodit sekä konstruktorin joka asettaa oliomuuttujalle alkuarvon.
  </p>

  <p>
    Joillain Linux-koneilla, kuten Kumpulassa olevilla koneilla, tämä saadaan aikaan painamalla yhtä aikaa ctrl, alt ja välilyönti.
  </p>

<% end %>

<!-- CAST2 -->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=aSFT6UnyvE0" height="300" target="_blank" rel="noopener"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<p>&nbsp;</p>

<% partial 'partials/exercise', locals: { name: 'Kasvatuslaitos (3 osaa)' } do %>

  <p>
    Tehtäväpohjassasi on valmiina jo tutuksi tullut luokka <code>Henkilo</code> sekä runko luokalle <code>Kasvatuslaitos</code>. Kasvatuslaitosoliot käsittelevät ihmisiä eri tavalla, esim. punnitsevat ja syöttävät ihmisiä. Rakennamme tässä tehtävässä kasvatuslaitoksen. Luokan Henkilö koodiin ei tehtävässä ole tarkoitus koskea!
  </p>

  <h2>Henkilöiden punnitseminen</h2>

  <p>
    Kasvatuslaitoksen luokkarungossa on valmiina runko metodille <code>punnitse</code>:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kasvatuslaitos {

    public int punnitse(Henkilo henkilo) {
    // palautetaan parametrina annetun henkilön paino
    return -1;
    }
    }
  <% end %>

  <p>
    Metodi saa parametrina henkilön ja metodin on tarkoitus palauttaa kutsujalleen parametrina olevan henkilön paino. Paino selviää kutsumalla parametrina olevan henkilön <code>henkilo</code> sopivaa metodia. <strong>Eli täydennä metodin koodi!</strong>
  </p>

  <p>
    Seuraavassa on pääohjelma jossa kasvatuslaitos punnitsee kaksi henkilöä:
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
    // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
    }
  <% end %>

  <p>
    Tulostuksen pitäisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Eero paino: 7 kiloa
    Pekka paino: 85 kiloa
  <% end %>

  <h2>Syöttäminen</h2>

  <p>
    Parametrina olevan olion tilaa on mahdollista muuttaa. Tee kasvatuslaitokselle metodi <code>public void syota(Henkilo henkilo)</code> joka kasvattaa parametrina olevan henkilön painoa yhdellä.
  </p>

  <p>
    Seuraavassa esimerkki, jossa henkilöt ensin punnitaan, ja tämän jälkeen neuvolassa syötetään eeroa kolme kertaa. Tämän jälkeen henkilöt taas punnitaan:
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");

    haaganNeuvola.syota(eero);
    haaganNeuvola.syota(eero);
    haaganNeuvola.syota(eero);

    System.out.println("");

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
    }
  <% end %>

  <p>
    Tulostuksen pitäisi paljastaa että Eeron paino on noussut kolmella:
  </p>

  <% partial 'partials/sample_output' do %>
    Eero paino: 7 kiloa
    Pekka paino: 85 kiloa

    Eero paino: 10 kiloa
    Pekka paino: 85 kiloa
  <% end %>

  <h2>Punnitusten laskeminen</h2>

  <p>
    Tee kasvatuslaitokselle metodi <code>public int punnitukset()</code> joka kertoo kuinka monta punnitusta kasvatuslaitos on ylipäätään tehnyt. Testipääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
    // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println("punnituksia tehty " + haaganNeuvola.punnitukset());

    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(pekka);

    System.out.println("punnituksia tehty " + haaganNeuvola.punnitukset());

    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);

    System.out.println("punnituksia tehty " + haaganNeuvola.punnitukset());
    }
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    punnituksia tehty 0
    punnituksia tehty 2
    punnituksia tehty 6
  <% end %>
<% end %>



<% partial 'partials/exercise', locals: { name: 'Maksukortti ja Kassapääte (4 osaa)' } do %>

  <h2>"Tyhmä" Maksukortti</h2>

  <p>
    Teimme viime viikolla luokan Maksukortti. Kortilla oli metodit edullisesti ja maukkaasti syömistä sekä rahan lataamista varten.
  </p>

  <p>
    Viime viikon tyylillä tehdyssä Maksukortti-luokassa oli kuitenkin ongelma. Kortti tiesi lounaiden hinnan ja osasi sen ansiosta vähentää saldoa oikean määrän. Entä kun hinnat nousevat? Tai jos myyntivalikoimaan tulee uusia tuotteita? Hintojen muuttaminen tarkoittaisi, että kaikki jo käytössä olevat kortit pitäisi korvata uusilla, uudet hinnat tuntevilla korteilla.
  </p>

  <p>
    Parempi ratkaisu on tehdä kortit "tyhmiksi", hinnoista ja myytävistä tuotteista tietämättömiksi pelkän saldon säilyttäjiksi. Kaikki äly kannattaakin laittaa erillisiin olioihin, kassapäätteisiin.
  </p>

  <p>
    Toteutetaan ensin Maksukortista "tyhmä" versio. Kortilla on ainoastaan metodit saldon kysymiseen, rahan lataamiseen ja rahan ottamiseen. Täydennä alla (ja tehtäväpohjassa) olevaan luokkaan metodin <code>public boolean otaRahaa(double maara)</code> ohjeen mukaan:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Maksukortti {
    private double saldo;

    public Maksukortti(double saldo) {
    this.saldo = saldo;
    }

    public double saldo() {
    return this.saldo;
    }

    public void lataaRahaa(double lisays) {
    this.saldo += lisays;
    }

    public boolean otaRahaa(double maara) {
    // toteuta metodi siten että se ottaa kortilta rahaa vain jos saldo on vähintään maara
    // onnistuessaan metodi palauttaa true ja muuten false
    }
    }
  <% end %>

  <p>
    Testipääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
    public static void main(String[] args) {
    Maksukortti pekanKortti = new Maksukortti(10);

    System.out.println("rahaa " + pekanKortti.saldo());
    boolean onnistuiko = pekanKortti.otaRahaa(8);
    System.out.println("onnistuiko otto: " + onnistuiko);
    System.out.println("rahaa " + pekanKortti.saldo());

    onnistuiko = pekanKortti.otaRahaa(4);
    System.out.println("onnistuiko otto: " + onnistuiko);
    System.out.println("rahaa " + pekanKortti.saldo());
    }
    }
  <% end %>

  <p>
    Tulostuksen kuuluisi olla seuraavanlainen
  </p>

  <% partial 'partials/sample_output' do %>
    rahaa 10.0
    onnistuiko otto: true
    rahaa 2.0
    onnistuiko otto: false
    rahaa 2.0
  <% end %>

  
  <h2>Kassapääte ja käteiskauppa</h2>

  <p>
    Unicafessa asioidessa asiakas maksaa joko käteisellä tai maksukortilla. Myyjä käyttää kassapäätettä kortin velottamiseen ja käteismaksujen hoitamiseen. Tehdään ensin kassapäätteestä käteismaksuihin sopiva versio.
  </p>

  <p>
    Kassapäätteen runko. Metodien kommentit kertovat halutun toiminnallisuuden:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kassapaate {
    private double rahaa;  // kassassa olevan käteisen määrä
    private int edulliset; // myytyjen edullisten lounaiden määrä
    private int maukkaat;  // myytyjen maukkaiden lounaiden määrä

    public Kassapaate() {
    // kassassa on aluksi 1000 euroa rahaa
    }

    public double syoEdullisesti(double maksu) {
    // edullinen lounas maksaa 2.50 euroa.
    // kasvatetaan kassan rahamäärää edullisen lounaan hinnalla ja palautetaan vaihtorahat
    // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
    }

    public double syoMaukkaasti(double maksu) {
    // maukas lounas maksaa 4.30 euroa.
    // kasvatetaan kassan rahamäärää maukkaan lounaan hinnalla ja palautetaan vaihtorahat
    // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
    }

    public String toString() {
    return "kassassa rahaa " + rahaa + " edullisia lounaita myyty " + edulliset + " maukkaita lounaita myyty " + maukkaat;
    }
    }
  <% end %>

  <p>
    Kassapäätteessä on aluksi rahaa 1000 euroa. Toteuta yllä olevan rungon metodit ohjeen ja alla olevan pääohjelman esimerkkitulosteen mukaan toimiviksi.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
    public static void main(String[] args) {
    Kassapaate unicafeExactum = new Kassapaate();

    double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
    System.out.println("vaihtorahaa jäi " + vaihtorahaa);

    vaihtorahaa = unicafeExactum.syoEdullisesti(5);
    System.out.println("vaihtorahaa jäi " + vaihtorahaa);

    vaihtorahaa = unicafeExactum.syoMaukkaasti(4.3);
    System.out.println("vaihtorahaa jäi " + vaihtorahaa);

    System.out.println(unicafeExactum);
    }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    vaihtorahaa jäi 7.5
    vaihtorahaa jäi 2.5
    vaihtorahaa jäi 0.0
    kassassa rahaa 1009.3 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
  <% end %>

  
  <h2>Kortilla maksaminen</h2>

  <p>
    Laajennetaan kassapäätettä siten että myös kortilla voi maksaa. Teemme kassapäätteelle siis metodit joiden parametrina kassapääte saa maksukortin jolta se vähentää valitun lounaan hinnan. Seuraavassa uusien metodien rungot ja ohje niiden toteuttamiseksi:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kassapaate {
    // ...

    public boolean syoEdullisesti(Maksukortti kortti) {
    // edullinen lounas maksaa 2.50 euroa.
    // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
    // muuten palautetaan false
    }

    public boolean syoMaukkaasti(Maksukortti kortti) {
    // maukas lounas maksaa 4.30 euroa.
    // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
    // muuten palautetaan false
    }

    // ...
    }
  <% end %>

  <p>
    <b>Huom:</b> kortilla maksaminen ei lisää kassapäätteessä olevan käteisen määrää.
  </p>

  <p>
    Seuraavassa testipääohjelma ja haluttu tulostus:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
    public static void main(String[] args) {
    Kassapaate unicafeExactum = new Kassapaate();

    double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
    System.out.println("vaihtorahaa jäi " + vaihtorahaa);

    Maksukortti antinKortti = new Maksukortti(7);

    boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
    System.out.println("riittikö raha: " + onnistuiko);
    onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
    System.out.println("riittikö raha: " + onnistuiko);
    onnistuiko = unicafeExactum.syoEdullisesti(antinKortti);
    System.out.println("riittikö raha: " + onnistuiko);

    System.out.println(unicafeExactum);
    }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    vaihtorahaa jäi 7.5
    riittikö raha: true
    riittikö raha: false
    riittikö raha: true
    kassassa rahaa 1002.5 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
  <% end %>

  
  <h2>Rahan lataaminen</h2>

  <p>
    Lisätään vielä kassapäätteelle metodi jonka avulla kortille voidaan ladata lisää rahaa. Muista, että rahan lataamisen yhteydessä ladattava summa viedään kassapäätteeseen. Metodin runko:
  </p>

  <% partial 'partials/code_highlight' do %>
    public void lataaRahaaKortille(Maksukortti kortti, double summa) {
    // ...
    }
  <% end %>

  <p>
    Testipääohjelma ja esimerkkisyöte:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
    public static void main(String[] args) {
    Kassapaate unicafeExactum = new Kassapaate();
    System.out.println(unicafeExactum);

    Maksukortti antinKortti = new Maksukortti(2);

    System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");

    boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
    System.out.println("riittikö raha: " + onnistuiko);

    unicafeExactum.lataaRahaaKortille(antinKortti, 100);

    onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
    System.out.println("riittikö raha: " + onnistuiko);

    System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");

    System.out.println(unicafeExactum);
    }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    kassassa rahaa 1000.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 0
    kortilla rahaa 2.0 euroa
    riittikö raha: false
    riittikö raha: true
    kortilla rahaa 97.7 euroa
    kassassa rahaa 1100.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 1
  <% end %>
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Samantyyppinen olio metodin parametrina
<% end %>

<p>
  Jatkamme edelleen luokan <code>Henkilo</code> parissa. Kuten muistamme, henkilöt tietävät syntymäpäivänsä:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {

  private String nimi;
  private Paivays syntymaPaiva;
  private int pituus;
  private int paino;

  // ...
  }
<% end %>


<p>
  Haluamme vertailla kahden henkilön ikää. Vertailu voidaan hoitaa usealla tavalla. Voisimme käyttää esimerkiksi aiemmassa tehtävässä toteutettua metodia <code>ikaVuosina()</code>, jolloin kahden henkilön iän vertailu tapauhtuisi tällöin seuraavasti:
</p>


<% partial 'partials/code_highlight' do %>
  Henkilo muhammad = new Henkilo("Muhammad ibn Musa al-Khwarizmi", 1, 1, 780);
  Henkilo pascal = new Henkilo("Blaise Pascal", 19, 6, 1623);

  if (muhammad.ikaVuosina() &gt; pascal.ikaVuosina()) {
  System.out.println(muhammad.getNimi() + " on vanhempi kuin " + pascal.getNimi());
  }
<% end %>

<p>
  Harjoittelemme nyt hieman "oliohenkisemmän" tavan kahden henkilön ikävertailun tekemiseen.
</p>

<p>
  Teemme Henkilöluokalle metodin <code>boolean vanhempiKuin(Henkilo verrattava)</code> jonka avulla tiettyä henkilö-olioa voi verrata parametrina annettuun henkilöön iän perusteella.
</p>

<p>
  Metodia on tarkoitus käyttää seuraavaan tyyliin:
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo muhammad = new Henkilo("Muhammad ibn Musa al-Khwarizmi", 1, 1, 780);
  Henkilo pascal = new Henkilo("Blaise Pascal", 19, 6, 1623);

  if (muhammad.vanhempiKuin(pascal)) {  //  sama kun muhammad.vanhempiKuin(pascal)==true
  System.out.println(muhammad.getNimi() + " on vanhempi kuin " + pascal.getNimi());
  } else {
  System.out.println(muhammad.getNimi() + " ei ole vanhempi kuin " + pascal.getNimi());
  }
<% end %>

<p>
  Tässä siis kysytään onko al-Khwarizmi Pascalia vanhempi "jos A on vanhempi kuin B". Metodi <code>vanhempiKuin</code> palauttaa arvon <code>true</code> jos olio jonka kohdalla metodia kutsutaan (<code>olio.vanhempiKuin(parametrinaAnnettavaOlio)</code>) on vanhempi kuin parametrina annettava olio, ja <code>false</code> muuten.
</p>

<p>
  Käytännössä yllä kutsutaan "Muhammad ibn Musa al-Khwarizmia" vastaavan olion, johon muuttuja <code>muhammad</code> viittaa, metodia <code>vanhempiKuin</code>, jolle annetaan parametriksi "Blaise Pascal" vastaavan olion viite <code>pascal</code>.
</p>

<p>
  Ohjelma tulostaa:
</p>

<% partial 'partials/sample_output' do %>
  Muhammad ibn Musa al-Khwarizmi on vanhempi kuin Blaise Pascal
<% end %>

<p>
  Metodille <code>vanhempiKuin</code> annetaan parametrina henkilöolio. Tarkemmin sanottuna metodin parametriksi määriteltyyn muuttujaan kopioituu parametrina annettavan muuttujan sisältämä arvo, eli viite olioon.
</p>

<p>
  Metodin toteutus näyttää seuraavalta. Huomaa, että metodi voi palauttaa arvon useammasta kohtaa -- alla vertailu on pilkottu useampaan osaan:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
  // ...

  public boolean vanhempiKuin(Henkilo verrattava) {
  // toteutus
  if (this.getSyntymaPaiva().getVuosi() &lt; verrattava.getSyntymaPaiva().getVuosi()) {
  return true;
  }

  if (this.getSyntymaPaiva().getVuosi() == verrattava.getSyntymaPaiva().getVuosi()
  && this.getSyntymaPaiva().getKuukausi() &lt; verrattava.getSyntymaPaiva().getKuukausi()) {
  return true;
  }

  if (this.getSyntymaPaiva().getVuosi() == verrattava.getSyntymaPaiva().getVuosi()
  && this.getSyntymaPaiva().getKuukausi() == verrattava.getSyntymaPaiva().getKuukausi()
  && this.getSyntymaPaiva().getPaiva() &lt; verrattava.getSyntymaPaiva().getPaiva()) {
  return true;
  }

  return false;
  }
  }<% end %>


<p>
  Mietitään hieman olio-ohjelmoinnin periatteiden abstrahointia. Abstrahoinnin ajatuksena on käsitteellistää ohjelmakoodia siten, että kullakin käsitteellä on omat selkeät vastuunsa. Kun pohdimme yllä esitettyä ratkaisua, huomaamme, että päivämäärien vertailutoiminnallisuus kuuluisi mielummin luokkaan <code>Paivays</code> luokan <code>Henkilo</code>-sijaan.
</p>

<p>
  Luodaan luokalle <code>Paivays</code> metodi <code>public boolean aiemmin(Paivays verrattava)</code>. Metodi palauttaa arvon <code>true</code>, jos metodille parametrina annettu päiväys on kyseisen olion päiväyksen jälkeen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Paivays {
  private int paiva;
  private int kuukausi;
  private int vuosi;

  public Paivays(int paiva, int kuukausi, int vuosi) {
  this.paiva = paiva;
  this.kuukausi = kuukausi;
  this.vuosi = vuosi;
  }

  public String toString() {
  return this.paiva + "." + this.kuukausi + "." + this.vuosi;
  }

  // metodilla tarkistetaan onko tämä päiväysolio (<code>this</code>) ennen
  // parametrina annettavaa päiväysoliota (<code>verrattava</code>)
  public boolean aiemmin(Paivays verrattava) {
  // ensin verrataan vuosia
  if (this.vuosi &lt; verrattava.vuosi) {
  return true;
  }

  // jos vuodet ovat samat, verrataan kuukausia
  if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi) {
  return true;
  }

  // vuodet ja kuukaudet samoja, verrataan päivää
  if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
  this.paiva &lt; verrattava.paiva) {
  return true;
  }

  return false;
  }
  }
<% end %>

<p>
  Vaikka oliomuuttujat <code>vuosi</code>, <code>kuukausi</code> ja <code>paiva</code> ovat olion kapseloimia (<code>private</code>) oliomuuttujia, pystymme lukemaan niiden arvon kirjoittamalla <code>verrattava.<em>muuttujanNimi</em></code>. Tämä johtuu siitä, että <code>private</code>-muuttujat ovat luettavissa kaikissa metodeissa, jotka kyseinen luokka sisältää. Huomaa, että syntaksi (kirjoitusasu) vastaa tässä jonkin olion metodin kutsumista. Toisin kuin metodia kutsuttaessa, viittaamme olion kenttään, jolloin metodikutsun osoittavia sulkeita ei kirjoiteta.
</p>

<p>
  Metodin käyttöesimerkki:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
  Paivays p1 = new Paivays(14, 2, 2011);
  Paivays p2 = new Paivays(21, 2, 2011);
  Paivays p3 = new Paivays(1, 3, 2011);
  Paivays p4 = new Paivays(31, 12, 2010);

  System.out.println(p1 + " aiemmin kuin " + p2 + ": " + p1.aiemmin(p2));
  System.out.println(p2 + " aiemmin kuin " + p1 + ": " + p2.aiemmin(p1));

  System.out.println(p2 + " aiemmin kuin " + p3 + ": " + p2.aiemmin(p3));
  System.out.println(p3 + " aiemmin kuin " + p2 + ": " + p3.aiemmin(p2));

  System.out.println(p4 + " aiemmin kuin " + p1 + ": " + p4.aiemmin(p1));
  System.out.println(p1 + " aiemmin kuin " + p4 + ": " + p1.aiemmin(p4));
  }
<% end %>

<% partial 'partials/sample_output' do %>
  14.2.2011 aiemmin kuin 21.2.2011: true
  21.2.2011 aiemmin kuin 14.2.2011: false
  21.2.2011 aiemmin kuin 1.3.2011: true
  1.3.2011 aiemmin kuin 21.2.2011: false
  31.12.2010 aiemmin kuin 14.2.2011: true
  14.2.2011 aiemmin kuin 31.12.2010: false
<% end %>

<p>
  Muunnetaan vielä henkilön metodia vanhempiKuin siten, että hyödynnämme jatkossa päivämäärän tarjoamaa vertailutoiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
  // ...

  public boolean vanhempiKuin(Henkilo verrattava) {
  if (this.syntymaPaiva.aiemmin(verrattava.getSyntymaPaiva())) {
  return true;
  }

  return false;
  }
  }
<% end %>

<p>
  Nyt päivämäärän konkreettinen vertailu on toteutettu luokassa, johon se loogisesti (luokkien nimien perusteella) kuuluukin.
</p>

<% partial 'partials/exercise', locals: { name: 'Asuntovertailu (3 osaa)' } do %>

  <p>
    Asuntovälitystoimiston tietojärjestelmässä myynnissä olevaa asuntoa kuvataan seuraavan luokan olioilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Asunto {
    private int huoneita;
    private int nelioita;
    private int neliohinta;

    public Asunto(int huoneita, int nelioita, int neliohinta) {
    this.huoneita = huoneita;
    this.nelioita = nelioita;
    this.neliohinta = neliohinta;
    }
    }
  <% end %>

  <p>
    Tehtävänä on toteuttaa muutama metodi, joiden avulla myynnissä olevia asuntoja voidaan vertailla.
  </p>

  <h2>Onko asunto suurempi</h2>

  <p>
    Tee metodi <code>public boolean suurempi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on suurempi kuin verrattavana oleva asunto-olio.
  </p>

  <p>
    Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Asunto eiraYksio = new Asunto(1, 16, 5500);
    Asunto kallioKaksio = new Asunto(2, 38, 4200);
    Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

    System.out.println(eiraYksio.suurempi(kallioKaksio));       // false
    System.out.println(jakomakiKolmio.suurempi(kallioKaksio));  // true
  <% end %>

  <h2>Asuntojen hintaero</h2>

  <p>
    Tee metodi <code>public int hintaero(Asunto verrattava)</code> joka palauttaa asunto-olion jolle metodia kutsuttiin ja parametrina olevan asunto-olion hintaeron. Hintaero on asuntojen hintojen (=neliöhinta*neliöt) itseisarvo.
  </p>

  <p>
    Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Asunto eiraYksio = new Asunto(1, 16, 5500);
    Asunto kallioKaksio = new Asunto(2, 38, 4200);
    Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

    System.out.println(eiraYksio.hintaero(kallioKaksio));        // 71600
    System.out.println(jakomakiKolmio.hintaero(kallioKaksio));   // 35400
  <% end %>

  <h2>Onko asunto kalliimpi</h2>

  <p>
    Tee metodi <code>public boolean kalliimpi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on kalliimpi kuin verrattavana oleva asunto-olio.
  </p>

  <p>
    Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Asunto eiraYksio = new Asunto(1, 16, 5500);
    Asunto kallioKaksio = new Asunto(2, 38, 4200);
    Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

    System.out.println(eiraYksio.kalliimpi(kallioKaksio));       // false
    System.out.println(jakomakiKolmio.kalliimpi(kallioKaksio));   // true
  <% end %>
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Olioiden yhtäsuuruuden vertailu
<% end %>

<p>
  Opimme merkkijonojen käsittelyn yhteydessä, että merkkijonojen vertailu tulee toteuttaa <code>equals</code>-metodin avullla. Tämä tapahtuu seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);

  System.out.println("Syötä kaksi sanaa, kumpikin omalle rivilleen.")
  String eka = lukija.nextLine();
  String toka = lukija.nextLine();

  if (eka.equals(toka)) {
  System.out.println("Sanat olivat samat.");
  } else {
  System.out.println("Sanat eivät olleet samat.");
  }
<% end %>

<p>
  Alkeistyyppisten muuttujien kuten <code>int</code> kanssa muuttujien vertailu on mahdollista kahden yhtäsuuruusmerkin avulla. Tämä johtuu siitä, että alkeistyyppisten muuttujien arvo sijaitsee "muuttujan lokerossa". Viittaustyyppisten muuttujien arvo on taas osoite viitattavaan olioon, eli viittaustyyppisten muuttujien "lokerossa" on viite muistipaikkaan. Kahden yhtäsuuruusmerkin avulla verrataan "muuttujan lokeron" sisällön yhtäsuuruutta -- viittaustyyppisillä muuttujilla vertailu tarkastelisi siis muuttujien osoitteita.
</p>

<p>
  Metodi <code>equals</code> taas tarkastelee muuttujaan liittyvän olion sisältöä. Jos haluamme pystyä vertailemaan kahta itse toteuttamaamme oliota equals-metodilla, tulee metodi määritellä luokkaan. Metodi equals määritellään luokkaan boolean-tyyppisen arvon palauttavana metodina -- boolean-muuttujan arvo kertoo ovatko oliot samat.
</p>

<p>
  Metodi <code>equals</code> toteutetaan siten, että sen avulla voidaan vertailla nykyistä oliota mihin tahansa muuhun olioon. Metodi saa parametrinaan Object-tyyppisen olion -- kaikki oliot ovat oman tyyppinsä lisäksi Object-tyyppisiä. Metodissa ensin vertaillaan ovatko osoitteet samat: jos kyllä, oliot ovat samat. Tämän jälkeen tarkastellaan ovatko olion tyypit samat: jos ei, oliot eivät ole samat. Tämän jälkeen parametrina saatu Object-olio muunnetaan tyyppimuunnoksella tarkasteltavan olion muotoiseksi, ja oliomuuttujien arvoja vertaillaan. Alla vertailu on toteutettu Paivays-oliolle.
</p>



<% partial 'partials/code_highlight' do %>
  public class Paivays {
  private int paiva;
  private int kuukausi;
  private int vuosi;

  public Paivays(int paiva, int kuukausi, int vuosi) {
  this.paiva = paiva;
  this.kuukausi = kuukausi;
  this.vuosi = vuosi;
  }

  public int getPaiva() {
  return this.paiva;
  }

  public int getKuukausi() {
  return this.kuukausi;
  }

  public int getVuosi() {
  return this.vuosi;
  }

  public boolean equals(Object verrattava) {
  // jos muuttujat sijaitsevat samassa paikassa, ovat ne samat
  if (this == verrattava) {
  return true;
  }

  // jos verrattava olio ei ole Paivays-tyyppinen, oliot eivät ole samat
  if (!(verrattava instanceof Paivays)) {
  return false;
  }

  // muunnetaan oli Paivays-olioksi
  Paivays verrattavaPaivays = (Paivays) verrattava;

  // jos olioiden oliomuuttujien arvot ovat samat, ovat oliot samat
  if (this.paiva == verrattavaPaivays.paiva &&
  this.kuukausi == verrattavaPaivays.kuukausi &&
  this.vuosi == verrattavaPaivays.vuosi) {
  return true;
  }

  // muulloin oliot eivät ole samat
  return false;
  }
  
  @Override
  public String toString() {
  return this.paiva + "." + this.kuukausi + "." + this.vuosi;
  }
  }
<% end %>

<p>
  Vastaavan vertailutoiminnallisuuden rakentaminen onnistuu myös Henkilö-olioille. Alla vertailu on toteutettu Henkilo-oliolle, jolla ei ole erillista Paivays-oliota. Huomaa, että henkilöiden nimet ovat merkijonoja (eli olioita), joten niiden vertailussa käytetään equals-metodia.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {

  private String nimi;
  private int ika;
  private int paino;
  private int pituus;

  // konstruktorit ja metodit


  public boolean equals(Object verrattava) {
  // jos muuttujat sijaitsevat samassa paikassa, ovat ne samat
  if (this == verrattava) {
  return true;
  }

  // jos verrattava olio ei ole Henkilo-tyyppinen, oliot eivät ole samat
  if (!(verrattava instanceof Henkilo)) {
  return false;
  }

  // muunnetaan olio Henkilo-olioksi
  Henkilo verrattavaHenkilo = (Henkilo) verrattava;

  // jos olioiden oliomuuttujien arvot ovat samat, ovat oliot samat
  if (this.nimi.equals(verrattavaHenkilo.nimi) && 
  this.ika == verrattavaHenkilo.ika &&
  this.paino == verrattavaHenkilo.paino &&
  this.pituus == verrattavaHenkilo.pituus) {
  return true;
  }

  // muulloin oliot eivät ole samat
  return false;
  }

  // .. metodeja
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Kappale' } do %>
  
  <p>
    Tehtäväpohjassa on luokka <code>Kappale</code>, jonka perusteella voidaan luoda musiikkikappaleita esittäviä olioita. Lisää luokkaan kappale metodi <code>equals</code>, jonka avulla voidaan tarkastella musiikkikappaleiden samankaltaisuutta.
  </p>
  
  <% partial 'partials/code_highlight' do %>
    Kappale jackSparrow = new Kappale("The Lonely Island", "Jack Sparrow", 196);
    Kappale toinenSparrow = new Kappale("The Lonely Island", "Jack Sparrow", 196);

    if (jackSparrow.equals(toinenSparrow)) {
    System.out.println("Kappaleet olivat samat.");
    }

    if (jackSparrow.equals("Toinen olio")) {
    System.out.println("Nyt on jotain hassua.");
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kappaleet olivat samat.
  <% end %>
<% end %>


<% partial 'partials/exercise', locals: { name: 'Henkilön vertailu' } do %>
  
  <p>
    Tehtäväpohjassa on luokka <code>Henkilo</code>, johon liittyy <code>Paivays</code>-olio. Lisää luokalle Henkilo metodi <code>public boolean equals(Object verrattava)</code>, jonka avulla voidaan verrata henkilöiden samuutta. Vertailussa tulee verrata kaikkien henkilön muuttujien yhtäsuuruutta (ml. syntymäpäivä).
  </p>

  <p>
    Tehtäväpohjassa ei ole testejä. Keksi erilaisia esimerkkikoodeja, joilla voit testata ohjelman toimintaa. Alla pari esimerkkiä.
  </p>

  <% partial 'partials/code_highlight' do %>
    Paivays pvm = new Paivays(24, 2, 2017);
    Paivays pvm2 = new Paivays(23, 7, 2017);

    Henkilo leevi = new Henkilo("Leevi", pvm, 62, 9);
    Henkilo lilja = new Henkilo("Lilja", pvm2, 65, 8);

    if (leevi.equals(lilja)) {
    System.out.println("Meniköhän nyt ihan oikein?");
    } 

    Henkilo leeviEriPainolla = new Henkilo("Leevi", pvm, 62, 10);

    if (leevi.equals(leeviEriPainolla)) {
    System.out.println("Meniköhän nyt ihan oikein?");
    } 

  <% end %>
  
<% end %>


<% partial 'partials/hint', locals: { name: 'Mikä ihmeen Object?' } do %>

  <p>
    Olio-ohjelmoinnin periaatteissa todettiin seuraavaa: <em>Olio-ohjelmoinnissa on mahdollista luoda luokkia, jotka perivät toisen luokan ominaisuuksia (eli oliomuuttujat ja metodit). Tällöin luokasta tehdyt oliot ovat samalla myös perityn luokan ilmentymiä, jolloin oliot voivat esiintyä useampina erilaisina olioina käyttötarpeesta riippuen.</em>
  </p>

  <p>
    Jokainen luomamme luokka (ja Javan valmis luokka) perii luokan Object, vaikkei sitä erikseen ohjelmakoodissa näy. Tämän takia mistä tahansa luokasta tehty ilmentymä voidaan asettaa parametriksi metodiin, joka saa parametrina Object-tyyppisen muuttujan. Object-luokan periminen näkyy myös muissa asioissa: esimerkiksi metodi <code>toString</code> on olemassa vaikkei sitä erikseen toteuteta, aivan samalla tavalla kuin metodi <code>equals</code>.
  </p>

  <p>
    Esimerkiksi seuraava lähdekoodi siis "toimii" oikein, vaikkei toiminta ehkä olekaan haluttua.
  </p>
  
  <% partial 'partials/code_highlight' do %>
    public class Lintu {
    private String nimi;

    public Lintu(String nimi) {
    this.nimi = nimi;
    } 
    }
  <% end %>


  <% partial 'partials/code_highlight' do %>
    Lintu red = new Lintu("Red");
    System.out.println(red);

    Lintu chuck = new Lintu("Chuck");
    System.out.println(chuck);

    if (red.equals(chuck)) {
    System.out.println(red + " on sama kuin " + chuck);
    }
  <% end %>

  <p>
    Vaikka ohjelma on syntaktisesti oikein, ei lopputulos liene kuitenkaan toivottu.
  </p>
  
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Olio metodin paluuarvona
<% end %>


<p>
  Olemme nähneet metodeja jotka palauttavat totuusarvoja, lukuja ja merkkijonoja. On helppoa arvata, että metodi voi palauttaa minkä tahansa tyyppisen olion.
</p>

<p>
  Seuraavassa esimerkissä on yksinkertainen laskuri, jolla on metodi <code>kloonaa</code>. Metodin avulla laskurista voidaan tehdä klooni, eli uusi laskurio-olio, jolla on luomishetkellä sama arvo kuin kloonattavalla laskurilla:
</p>

<% partial 'partials/code_highlight' do %>
  public Laskuri {
  private int arvo;

  public Laskuri() {
  this(0);
  }

  public Laskuri(int alkuarvo) {
  this.arvo = alkuarvo;
  }

  public void kasvata() {
  this.arvo++;
  }

  public String toString() {
  return "arvo: " + arvo;
  }

  public Laskuri kloonaa() {
  // luodaan uusi laskuriolio, joka saa alkuarvokseen kloonattavan laskurin arvon
  Laskuri klooni = new Laskuri(this.arvo);

  // palautetaan klooni kutsujalle
  return klooni;
  }
  }
<% end %>

<p>
  Seuraavassa käyttöesimerkki:
</p>

<% partial 'partials/code_highlight' do %>
  Laskuri laskuri = new Laskuri();
  laskuri.kasvata();
  laskuri.kasvata();

  System.out.println(laskuri);         // tulostuu 2

  Laskuri klooni = laskuri.kloonaa();

  System.out.println(laskuri);         // tulostuu 2
  System.out.println(klooni);          // tulostuu 2

  laskuri.kasvata();
  laskuri.kasvata();
  laskuri.kasvata();
  laskuri.kasvata();

  System.out.println(laskuri);         // tulostuu 6
  System.out.println(klooni);          // tulostuu 2

  klooni.kasvata();

  System.out.println(laskuri);         // tulostuu 6
  System.out.println(klooni);          // tulostuu 3
<% end %>

<p>
  Kloonattavan ja kloonin sisältämä arvo on kloonauksen tapahduttua sama. Kyseessä on kuitenkin kaksi erillistä olioa, eli kun toista laskureista kasvatetaan, ei kasvatus vaikuta toisen arvoon millään tavalla.
</p>

<p>
  Vastaavasti myös <code>Tehdas</code>-olio voisi luoda ja palauttaa uusia <code>Auto</code>-olioita. Alla on hahmoteltu tehtaan runkoa -- tehdas tietää myös luotavien autojen merkin.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tehdas {
  private String merkki;

  public Tehdas(String merkki) {
  this.merkki = merkki;
  }

  public Auto tuotaAuto() {
  return new Auto(this.merkki);
  }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Päiväys (3 osaa)' } do %>

  <p>
    Tehtäväpohjan mukana tulee aiemmin esitelty luokka <code>Paivays</code>, jossa päivämäärä talletetaan oliomuuttujien <code>vuosi</code>, <code>kuukausi</code>, ja <code>paiva</code> avulla:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paivays {
    private int paiva;
    private int kuukausi;
    private int vuosi;

    public Paivays(int paiva, int kuukausi, int vuosi) {
    this.paiva = paiva;
    this.kuukausi = kuukausi;
    this.vuosi = vuosi;
    }

    public String toString() {
    return this.paiva + "." + this.kuukausi + "." + this.vuosi;
    }

    public boolean aiemmin(Paivays verrattava) {
    // ensin verrataan vuosia
    if (this.vuosi &lt; verrattava.vuosi) {
    return true;
    }

    // jos vuodet ovat samat, verrataan kuukausia
    if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi) {
    return true;
    }

    // vuodet ja kuukaudet samoja, verrataan päivää
    if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
    this.paiva &lt; verrattava.paiva) {
    return true;
    }

    return false;
    }
    }
  <% end %>

  <p>
    Tässä tehtäväsarjassa laajennetaan luokkaa.
  </p>

  
  <h2>Seuraava päivä</h2>

  <p>
    Toteuta metodi <code>public void etene()</code>, joka siirtää päiväystä yhdellä päivällä. Tässä tehtävässä oletetaan, että jokaisessa kuukaudessa on 30 päivää. Huom! Sinun tulee <em>tietyissä</em> tilanteissa muuttaa kuukauden ja vuoden arvoa.
  </p>

  
  <h2>Tietty määrä päiviä eteenpäin</h2>

  <p>
    Toteuta metodi <code>public void etene(int montakoPaivaa)</code>, joka siirtää päiväystä annetun päivien määrän verran. Käytä apuna edellisessä tehtävässä toteutettua metodia <code>etene()</code>.
  </p>

  
  <h2>Ajan kuluminen</h2>

  <p>
    Lisätään <code>Paivays</code>-olioon mahdollisuus edistää aikaa. Tee oliolle metodi <code>Paivays paivienPaasta(int paivia)</code>, joka luo <strong>uuden</strong> <code>Paivays</code>-olion, jonka päiväys on annetun päivien lukumäärän verran suurempi kuin oliolla, jolle sitä kutsuttiin. Voit edelleen olettaa, että jokaisessa kuukaudessa on 30 päivää. Huomaa, että vanhan päiväysolion on pysyttävä muuttumattomana!
  </p>

  <p>
    Koska metodissa on luotava <strong>uusi olio</strong>, tulee rungon olla suunnilleen seuraavanlainen:
  </p>

  <% partial 'partials/code_highlight' do %>
    public Paivays paivienPaasta(int paivia) {
    Paivays uusiPaivays = new Paivays( ... );

    // tehdään jotain...

    return uusiPaivays;
    }
  <% end %>

  <p>
    Ohessa on esimerkki metodin toiminnasta.
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
    Paivays pvm = new Paivays(13, 2, 2015);
    System.out.println("Tarkistellun viikon perjantai on " + pvm);

    Paivays uusiPvm = pvm.paivienPaasta(7);
    int vk = 1;
    while (vk &lt;= 7) {
    System.out.println("Perjantai " + vk + " viikon kuluttua on " + uusiPvm);
    uusiPvm = uusiPvm.paivienPaasta(7);

    vk++;
    }


    System.out.println("Päivämäärä 790:n päivän päästä tarkistellusta perjantaista on ... kokeile itse!");
    //    System.out.println("Kokeile " + pvm.paivienPaasta(790));
    }
  <% end %>

  <p>
    Ohjelma tulostaa:
  </p>

  <% partial 'partials/sample_output' do %>
    Tarkistellun viikon perjantai on 13.2.2015
    Perjantai 1 viikon kuluttua on 20.2.2015
    Perjantai 2 viikon kuluttua on 27.2.2015
    Perjantai 3 viikon kuluttua on 4.3.2015
    Perjantai 4 viikon kuluttua on 11.3.2015
    Perjantai 5 viikon kuluttua on 18.3.2015
    Perjantai 6 viikon kuluttua on 25.3.2015
    Perjantai 7 viikon kuluttua on 2.4.2015
    Päivämäärä 790:n päivän päästä tarkistellusta perjantaista on ... kokeile itse!
  <% end %>

  <p>
    <strong>Huom!</strong> Sen sijaan, että muuttaisimme vanhan olion tilaa palautamme uuden olion. Kuvitellaan, että <code>Paivays</code>-luokalle on olemassa metodi <code>edista</code>, joka toimii vastaavasti kuin ohjelmoimamme metodi, mutta se muuttaa vanhan olion tilaa. Tällöin seuraava koodin pätkä tuottaisi ongelmia.
  </p>

  <% partial 'partials/code_highlight' do %>
    Paivays nyt = new Paivays(13, 2, 2015);
    Paivays viikonPaasta = nyt;
    viikonPaasta.edista(7);

    System.out.println("Nyt: " + nyt);
    System.out.println("Viikon päästä: " + viikonPaasta);
  <% end %>

  <p>
    Ohjelman tulostus olisi seuraavanlainen:
  </p>

  <% partial 'partials/sample_output' do %>
    Nyt 20.2.2015
    Viikon päästä 20.2.2015
  <% end %>

  <p>
    Tämä johtuu siitä, että tavallinen sijoitus kopioi ainoastaan viitteen olioon. Siis itse asiassa ohjelman oliot <code>nyt</code> ja <code>viikonPaasta</code> viittavaat <strong>yhteen ja samaan</strong> <code>Paivays</code>-olioon.
  </p>
  
<% end %>



<% partial 'partials/exercise', locals: { name: 'Raha (3 osaa)' } do %>

  <p>
    Maksukortti-tehtävässä käytimme rahamäärän tallettamiseen double-tyyppistä oliomuuttujaa. Todellisissa sovelluksissa näin ei kannata tehdä, sillä kuten jo olemme nähneet, doubleilla laskenta ei ole tarkkaa. Onkin järkevämpää toteuttaa rahamäärän käsittely oman luokkansa avulla. Seuraavassa on luokan runko:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Raha {

    private final int euroa;
    private final int senttia;

    public Raha(int euroa, int senttia) {
    this.euroa = euroa;
    this.senttia = senttia;
    }

    public int eurot() {
    return euroa;
    }

    public int sentit() {
    return senttia;
    }

    public String toString() {
    String nolla = "";
    if (senttia &lt;= 10) {
    nolla = "0";
    }

    return euroa + "." + nolla + senttia + "e";
    }
    }
  <% end %>

  <p>
    Määrittelyssä pistää silmään oliomuuttujien määrittelyn yhteydessä käytetty sana <code>final</code>, tällä saadaan aikaan se, että oliomuuttujien arvoa ei pystytä muuttamaan sen jälkeen kun ne on konstruktorissa asetettu. Raha-luokan oliot ovatkin muuttumattomia eli <em>immutaabeleita</em>, eli jos halutaan esim. kasvattaa rahamäärää, on luotava uusi olio, joka kuvaa kasvatettua rahasummaa.
  </p>

  <p>
    Luomme seuraavassa muutaman operaation rahojen käsittelyyn.
  </p>


  <h2>Plus</h2>

  <p>
    Tee ensin metodi <code>public Raha plus(Raha lisattava)</code>, joka palauttaa uuden raha-olion, joka on arvoltaan yhtä suuri kuin se olio jolle metodia kutsuttiin ja parametrina oleva olio yhteensä.
  </p>

  <p>
    Metodin runko on seuraavanlainen:
  </p>

  <% partial 'partials/code_highlight' do %>
    public Raha plus(Raha lisattava) {
    Raha uusi = new Raha(...); // luodaan uusi Raha-olio jolla on oikea arvo

    // palautetaan uusi Raha-olio
    return uusi;
    }
  <% end %>

  <p>
    Seuraavassa esimerkkejä metodin toiminnasta
  </p>

  <% partial 'partials/code_highlight' do %>
    Raha a = new Raha(10,0);
    Raha b = new Raha(5,0);

    Raha c = a.plus(b);

    System.out.println(a);  // 10.00e
    System.out.println(b);  // 5.00e
    System.out.println(c);  // 15.00e

    a = a.plus(c);          // HUOM: tässä syntyy uusi Raha-olio, joka laitataan "a:n langan päähän"
    //       vanha a:n langan päässä ollut 10 euroa häviää ja Javan roskien kerääjä korjaa sen pois

    System.out.println(a);  // 25.00e
    System.out.println(b);  // 5.00e
    System.out.println(c);  // 15.00e
  <% end %>

  
  <h2>Vähemmän</h2>

  <p>
    Tee metodi <code>public boolean vahemman(Raha verrattava)</code>, joka palauttaa true jos raha-olio jolle metodia kutsutaan on arvoltaan pienempi kuin raha-olio, joka on metodin parametrina.
  </p>

  <% partial 'partials/code_highlight' do %>
    Raha a = new Raha(10, 0);
    Raha b = new Raha(3, 0);
    Raha c = new Raha(5, 0);

    System.out.println(a.vahemman(b));  // false
    System.out.println(b.vahemman(c));  // true
  <% end %>

  
  <h2>Miinus</h2>

  <p>
    Tee metodi <code>public Raha miinus(Raha vahentaja)</code>, joka palauttaa uuden raha-olion, jonka arvoksi tulee sen olion jolle metodia kutsuttiin ja parametrina olevan olion arvojen erotus. Jos erotus olisi negatiivinen, tulee luotavan raha-olion arvoksi 0.
  </p>

  <p>
    Seuraavassa esimerkkejä metodin toiminnasta
  </p>

  <% partial 'partials/code_highlight' do %>
    Raha a = new Raha(10, 0);
    Raha b = new Raha(3, 50);

    Raha c = a.miinus(b);

    System.out.println(a);  // 10.00e
    System.out.println(b);  // 3.50e
    System.out.println(c);  // 6.50e

    c = c.miinus(a);        // HUOM: tässä syntyy uusi Raha-olio, joka laitataan "c:n langan päähän"
    //       vanha c:n langan päässä ollut 6.5 euroa häviää ja Javan roskien kerääjä korjaa sen pois

    System.out.println(a);  // 10.00e
    System.out.println(b);  // 3.50e
    System.out.println(c);  // 0.00e
  <% end %>

<% end %>




<% partial 'partials/material_heading' do %>
  Alkeis- ja viittaustyyppiset muuttujat
<% end %>

<p>
  Javan muuttujat voi jakaa alkeis- ja viittaustyyppisiin muuttujiin. Alkeistyyppisten muuttujien sisältämä tieto on tallennettu muuttujan arvoksi, kun taas viittaustyyppisten muuttujien arvona on viite muuttujaan liittyvään tietoon. Tarkastellaan näitä muuttujatyyppejä kahden esimerkin kautta.
</p>


<% partial 'partials/code_highlight' do %>
  int arvo = 10;
  System.out.println(arvo);  
<% end %>

<% partial 'partials/sample_output' do %>
  10
<% end %>


<% partial 'partials/code_highlight' do %>
  Nimi leevi = new Nimi("Leevi");
  System.out.println(leevi);
<% end %>


<% partial 'partials/sample_output' do %>
  Nimi@4aa298b7
<% end %>

<p>
  Ensimmäisessä esimerkissä luodaan alkeistyyppinen <code>int</code>-muuttuja, jonka arvoksi kopioidaan luku 10. Kun muuttuja annetaan System.out.println-metodille tulostettavaksi, tulostuu arvo 10. Toisessa esimerkissä taas luodaan viittaustyyppinen Nimi-muuttuja, jonka arvoksi kopioidaan Nimi-luokassa määritellyn konstruktorin kutsun palauttama viite olioon. Kun muuttuja annetaan System.out.println-metodille tulostettavaksi, tulostuu merkkijono Nimi@4aa298b7. Mistä tässä oikein on kyse?
</p>

<p>
  Metodikutsu System.out.println tulostaa muuttujan arvon. Alkeistyyppiset muuttujat sisältävät konkreettisen arvon, joka tulostuu tulostuskutsun yhteydessä. Myös viittaustyyppiset muuttujat sisältävät konkreettisen arvon, mutta viittaustyyppisten muuttujien arvo on viite paikkaan, missä olion tiedot ovat. Voidaan ajatella, että merkkijono <code>Nimi@4aa298b7</code> kertoo, että kyse on <code>Nimi</code>-tyyppisestä muuttujasta paikassa <code>4aa298b7</code>.
</p>

<p>
  Tutustutaan näihin muuttujatyyppeihin tarkemmin.
</p>


<% partial 'partials/material_sub_heading' do %>
  Alkeistyyppiset muuttujat
<% end %>

<p>
  Javassa on yhteensä kahdeksan erilaista alkeistyyppistä muuttujaa. Nämä ovat <code>boolean</code> (totuusarvo), <code>byte</code> (8 bittiä sisältävä tavu), <code>char</code> (yhtä merkkiä kuvaava 16-bittiä sisältävä kirjainarvo), <code>short</code> (pientä lukua kuvaava 16 bittiä sisältävä arvo), <code>int</code> (keskikokoista lukua kuvaava 32 bittiä sisältävä arvo), <code>long</code> (isohkoa lukua kuvaava 64 bittiä sisältävä arvo), <code>float</code> (32-bittiä sisältävä liukuluku) ja <code>double</code> (64-bittiä sisältävä liukuluku).
</p>

<p>
  Olemme käyttäneet näistä ensisijaisesti totuusarvomuuttujia (<code>boolean</code>), kokonaislukumuuttujia (<code>int</code>), ja liukulukumuuttujia (<code>double</code>).
</p>


<% partial 'partials/code_highlight' do %>
  boolean totuusarvo = false;
  int kokonaisluku = 42;
  double liukuluku = 4.2;

  System.out.println(totuusarvo);
  System.out.println(kokonaisluku);
  System.out.println(liukuluku);
<% end %>


<% partial 'partials/sample_output' do %>
  false
  42
  4.2
<% end %>


<% partial 'partials/hint', locals: { name: 'Bitit ja binääriluvut' } do %>

  <p>
    Tietokoneen muisti on käytännössä taulukko, missä jokainen taulukon lokero sisältää joko luvun 0 tai 1. Näitä yksittäisiä lukuja kutsutaan biteiksi (lyhenne sanasta binary digit). Koneen käyttämät luvut kuvataan bittien avulla binäärilukuna: esimerkiksi <code>short</code>-tyyppinen muuttuja sisältää 16 bittiä ja <code>int</code>-tyyppinen muuttuja 32 bittiä.
  </p>

  <p>
    Tarkastellaan miten binääriluvut toimivat. Alla on kuvattuna 8 bittiä pitkä alue tietokoneen muistista, missä jokainen bitin arvo on 0. 
  </p>

  <table border="1">
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </table>

  <br/>
  
  <p>
    Binäärilukukujen avulla jokainen luku voidaan esittää luvun 2 potensseina. Esimerkiksi yllä olevan kahdeksan bitin luvun arvo kymmenjärjestelmässä on: 0 * 2<sup>0</sup> + 0 * 2<sup>1</sup> + ... + 0 * 2<sup>7</sup>. Laskeminen aloitetaan tyypillisesti luvun oikeasta laidasta. Alla on kuvattuna toinen esimerkki.
  </p>
  
  <table border="1">
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </table>

  <br/>
  
  <p>
    Yllä kuvattu binääriluku on kymmenjärjestelmässä: 1 * 2<sup>0</sup> + 0 * 2<sup>1</sup> + 1 * 2<sup>2</sup> + 0 * 2<sup>3</sup> + ... + 0 * 2<sup>7</sup> = 5. 
  </p>

  <p>
    Vastaavasti toiseen suuntaan siirryttäessä luku 3 voidaan ilmaista binäärilukuna "11", ja esimerkiksi luku 256 binäärilukuna "100000000". Binäärilukujen avulla kuvataan lukujen lisäksi käytännössä kaikki tietokoneen tallentama tieto. Tähän teemaan tutustutaan tarkemmin kurssilla Tietokoneen toiminta (TKT-10005). 
  </p>

<% end %>

<p>
  Alkeistyyppisillä muuttujilla muuttujan esittely varaa muistipaikan, johon kopioidaan arvo. Alla olevassa esimerkissä luodaan kolme muuttujaa. Jokaisella muuttujalla on erillinen muistipaikka, johon asetettava arvo kopioidaan.
</p>


<% partial 'partials/code_highlight' do %>
  int eka = 10;
  int toka = eka;
  int kolmas = toka;
  System.out.println(eka + " " + toka + " " + kolmas);
  toka = 5;
  System.out.println(eka + " " + toka + " " + kolmas);
<% end %>


<% partial 'partials/code_highlight' do %>
  10 10 10
  10 5 10
<% end %>


<p>
  Muuttujan arvon asetus yhtäsuuruusmerkillä aiheuttaa muuttujan arvon kopioimisen. Esimerkiksi lause <code>int eka = 10</code> luo int-tyyppisen muuttujan nimeltä eka, jonka arvoksi kopioidaan luku 10. Vastaavasti lause <code>int toka = eka;</code> luo int-tyyppisen muuttujan nimeltä toka, jonka arvoksi kopioidaan muuttujan eka arvo.
</p>

<p>
  Muuttujien arvot kopioituvat myös metodikutsujen yhteydessä. Käytännössä tämä tarkoittaa sitä, että metodikutsun yhteydessä metodin parametriksi annetun muuttujan arvo ei muutu metodia kutsuvassa metodissa. Alla olevassa esimerkissä main-metodissa esitellään muuttuja luku, jonka arvo kopioidaan metodin kutsu parametriksi. Metodissa kutsu parametrina saatu arvo tulostetaan, jonka jälkeen arvoa kasvatetaan yhdellä, jonka jälkeen arvo tulostetaan vielä kerran. Lopulta metodin kutsu suoritus loppuu, ja palataan main-metodiin, missä luku-muuttujan arvo ei ole muuttunut. 
</p>

<div class="code-states-visualizer-widget" data-input='{"code":"public class Esimerkki {\n    public static void main(String[] args) {\n        int luku = 1;\n        kutsu(luku);\n       \n        System.out.println(\"Luku vieläkin: \" + luku);\n    }\n   \n    public static void kutsu(int luku) {\n        System.out.println(\"Luku aluksi: \" + luku);\n        luku++;\n        System.out.println(\"Luku lopuksi: \" + luku);\n    }\n}","stdin":"","trace":[{"stdout":"","event":"call","line":3,"stack_to_render":[{"func_name":"main:3","encoded_locals":{},"ordered_varnames":[],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"1","frame_id":1}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"","event":"step_line","line":3,"stack_to_render":[{"func_name":"main:3","encoded_locals":{},"ordered_varnames":[],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"2","frame_id":2}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"","event":"step_line","line":4,"stack_to_render":[{"func_name":"main:4","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"4","frame_id":4}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"","event":"call","line":10,"stack_to_render":[{"func_name":"kutsu:10","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"7","frame_id":7},{"func_name":"main:4","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":false,"is_zombie":false,"is_parent":false,"unique_hash":"8","frame_id":8}],"globals":{},"ordered_globals":[],"func_name":"kutsu","heap":{}},{"stdout":"","event":"step_line","line":10,"stack_to_render":[{"func_name":"kutsu:10","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"9","frame_id":9},{"func_name":"main:4","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":false,"is_zombie":false,"is_parent":false,"unique_hash":"10","frame_id":10}],"globals":{},"ordered_globals":[],"func_name":"kutsu","heap":{}},{"stdout":"Luku aluksi: 1\n","event":"step_line","line":11,"stack_to_render":[{"func_name":"kutsu:11","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"15","frame_id":15},{"func_name":"main:4","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":false,"is_zombie":false,"is_parent":false,"unique_hash":"16","frame_id":16}],"globals":{},"ordered_globals":[],"func_name":"kutsu","heap":{}},{"stdout":"Luku aluksi: 1\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"kutsu:12","encoded_locals":{"luku":2},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"17","frame_id":17},{"func_name":"main:4","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":false,"is_zombie":false,"is_parent":false,"unique_hash":"18","frame_id":18}],"globals":{},"ordered_globals":[],"func_name":"kutsu","heap":{}},{"stdout":"Luku aluksi: 1\nLuku lopuksi: 2\n","event":"step_line","line":13,"stack_to_render":[{"func_name":"kutsu:13","encoded_locals":{"luku":2},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"27","frame_id":27},{"func_name":"main:4","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":false,"is_zombie":false,"is_parent":false,"unique_hash":"28","frame_id":28}],"globals":{},"ordered_globals":[],"func_name":"kutsu","heap":{}},{"stdout":"Luku aluksi: 1\nLuku lopuksi: 2\n","event":"return","line":13,"stack_to_render":[{"func_name":"kutsu:13","encoded_locals":{"luku":2,"__return__":["VOID"]},"ordered_varnames":["luku","__return__"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"29","frame_id":29},{"func_name":"main:4","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":false,"is_zombie":false,"is_parent":false,"unique_hash":"30","frame_id":30}],"globals":{},"ordered_globals":[],"func_name":"kutsu","heap":{}},{"stdout":"Luku aluksi: 1\nLuku lopuksi: 2\n","event":"step_line","line":6,"stack_to_render":[{"func_name":"main:6","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"31","frame_id":31}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"Luku aluksi: 1\nLuku lopuksi: 2\nLuku vieläkin: 1\n","event":"step_line","line":7,"stack_to_render":[{"func_name":"main:7","encoded_locals":{"luku":1},"ordered_varnames":["luku"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"36","frame_id":36}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"Luku aluksi: 1\nLuku lopuksi: 2\nLuku vieläkin: 1\n","event":"return","line":7,"stack_to_render":[{"func_name":"main:7","encoded_locals":{"luku":1,"__return__":["VOID"]},"ordered_varnames":["luku","__return__"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"37","frame_id":37}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}}],"userlog":"Debugger VM maxMemory: 455M\n"}'></div>



<% partial 'partials/material_sub_heading' do %>
  Viittaustyyppiset muuttujat
<% end %>

<p>
  Lähes kaikki Javan muuttujat ovat viittaustyyppisiä, ja ohjelmoija voi luoda Javaan myös uusia viittaustyypin muuttujatyyppejä. Käytännössä jokainen annetusta luokasta luotu olio on viittaustyyppinen muuttuja.
</p>

<p>
  Tarkastellaan alussa ollutta esimerkkiä, missä luotiin Nimi-tyyppinen muuttuja leevi.
</p>

<% partial 'partials/code_highlight' do %>
  Nimi leevi = new Nimi("Leevi");
<% end %>

<p>
  Kutsun osat ovat seuravat:
</p>

<ul>

  <li>
    Mitä tahansa uutta muuttujaa esiteltäessä tulee ensin kertoa esiteltävän muuttujan tyyppi. Alla esitellään muuttuja, jonka tyyppi on <code>Nimi</code>. Jotta ohjelman suorittaminen onnistuu, tulee ohjelmassa olla luokka nimeltä <code>Nimi</code>.
    
    <% partial 'partials/code_highlight' do %>
      <strong>Nimi</strong> leevi = new Nimi("Leevi");
    <% end %>
    
  </li>

  <li>

    Muuttujan esittelyn yhteydessä kerrotaan myös muuttujan nimi. Muuttujan arvoon voi myöhemmin viitata muuttujan nimen perusteella. Alla muuttujan nimeksi tulee leevi.
    
    <% partial 'partials/code_highlight' do %>
      Nimi <strong>leevi</strong> = new Nimi("Leevi");
    <% end %>
    
  </li>

  <li>

    Muuttujaan halutaan asettaa arvo. Luokista luodaan olioita kutsumalla niiden konstruktoria, joka määrittelee luotavan olion muuttujiin asetettavat arvot. Alla oletetaan, että luokassa <code>Nimi</code> on konstruktori, joka saa parametrikseen merkkijonon.
    
    <% partial 'partials/code_highlight' do %>
      Nimi leevi = <strong>new Nimi("Leevi");</strong>
    <% end %>
    
  </li>

  <li>

    Konstruktorikutsu palauttaa arvon, joka on viite luotuun olioon. Yhtäsuuruusmerkki kertoo ohjelmalle, että yhtäsuuruusmerkin oikealla puolella olevan lausekkeen arvo tulee kopioida yhtäsuuruusmerkin vasemmalla puolella olevan muuttujan arvoksi.
    
    <% partial 'partials/code_highlight' do %>
      Nimi leevi <strong>=</strong> new Nimi("Leevi");
    <% end %>

  </li>
</ul>

<p>
  On mahdollista, että Nimi-luokalle on määritelty metodeja, joiden avulla Nimi-luokasta tehtyjen olioiden sisäistä tilaa voidaan muuttaa.
</p>

<p>
  Suurin ero alkeis- ja viittaustyyppisten muuttujien välillä on se, että alkeistyyppiset muuttujat (jotka ovat lähes poikkeuksetta numeroita) ovat muuttumattomia, kun taas viittaustyyppiset muuttujat voivat muuttua. Tämä ilmiö liittyy siihen, että alkeistyyppisten muuttujien arvo on tallennettu suoraan muuttujaan, kun taas viittaustyyppisten muuttujien arvo on viite muuttujan tietoihin.
</p>

<p>
  Alkeistyyppisille muuttujille löytyy laskuoperaatioita kuten plus, miinus, kerto jne -- nämä operaatiot eivät muuta alkuperäisten muuttujien arvoja. Laskuoperaatioiden avulla voidaan luodaan uusia arvoja, jotka varastoidaan muuttujiin tarvittaessa. Toisaalta, viittaustyyppisten muuttujien arvoa ei voi muuttaa plus, miinus, kerto ym. laskuoperaatioiden avulla.
</p>

<p>
  Viittaustyyppisen muuttujan arvo -- eli viite -- osoittaa paikkaan muistissa, mistä löytyy viittaustyyppiseen muuttujaan liittyvät tiedot. Oletetaan, että käytössä on luokka Henkilo, jossa on määritelty oliomuuttujaksi ika. Jos luokasta on luotu henkilöolio, voi henkilöolion viitettä seuraamalla päästä käsiksi muuttujaan ika, jonka arvoa voi tarvittaessa muuttaa. 
</p>


<% partial 'partials/material_sub_heading' do %>
  Muuttujat ja tietokoneen muisti
<% end %>

<p>
  Totesimme aiemmin, että alkeistyyppisten muuttujien arvo on tallennettuna suoraan muuttujaan, kun taas viittaustyyppisten muuttujien arvo sisältää viitteen olioon. Totesimme myös, että muuttujan arvon asettaminen yhtäsuuruusmerkillä kopioi oikealla olevan (muuttujan) arvon vasemmalla olevan muuttujan arvoksi. Vastaava toiminnallisuus on myös metodikutsujen yhteydessä -- metodikutsun yhteydessä parametrina annettava arvo kopioidaan metodin käyttöön.
</p>

<p>
  Tarkastellaan tätä käytännössä. Oletetaan, että käytössämme on seuraava luokka <code>Henkilo</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int syntymavuosi;

      public Henkilo(String nimi) {
          this.nimi = nimi;
          this.syntymavuosi = 1970;
      }

      public int getSyntymavuosi() {
          return this.syntymavuosi;
      }
  
      public void setSyntymavuosi(int syntymavuosi) {
          this.syntymavuosi = syntymavuosi;
      }

      public String toString() {
          return this.nimi + " (" + this.syntymavuosi + ")";
      }
  }
<% end %>

<p>
  Tarkastellaan seuraavan ohjelman toimintaa askeleittain.
</p>

<% partial 'partials/code_highlight' do %>
  public class Esimerkki {
      public static void main(String[] args) {
          Henkilo eka = new Henkilo("Eka");
  
          System.out.println(eka);
          nuorenna(eka);
          System.out.println(eka);
  
          Henkilo toka = eka;
          nuorenna(toka);
  
          System.out.println(eka);
      }
  
      public static void nuorenna(Henkilo henkilo) {
          henkilo.setSyntymavuosi(henkilo.getSyntymavuosi() + 1);
      }
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Eka (1970)
  Eka (1971)
  Eka (1972)
<% end %>

<p>
  Ohjelman suoritus alkaa main-metodin ensimmäiseltä riviltä. Main-metodin ensimmäisellä rivillä esitellään Henkilo-tyyppinen muuttuja eka, johon kopioidaan Henkilo-luokan konstruktorin palauttama arvo. Konstruktorissa luodaan olio, jonka syntymävuodeksi asetetaan 1970 ja jonka nimeksi asetetaan parametrina saatu arvo. Konstruktori palauttaa viitteen. Rivin suorituksen jälkeen ohjelman tilanne on seuraava -- ohjelman muistiin on luotu Henkilo-olio, johon on viittaus main-metodissa määritellystä eka-muuttujasta.
</p>


<img src="/img/drawings/eka-1.png"/>

<p>
  Main-metodin kolmannella rivillä tulostetaan muuttujan eka arvo. Metodikutsu System.out.println etsii sille parametrina annetulta viittaustyyppiseltä muuttujalta toString-metodia. Henkilo-luokalla on metodi toString, joten metodia kutsutaan eka-muuttujan osoittamalle oliolle. Oliossa olevan muuttujan nimi arvo on "Eka" ja syntymävuoden arvo on 1970. Tulostukseksi tulee "Eka (1970)".
</p>

<p>
  Neljännellä rivillä kutsutaan nuorenna-metodia, jolle annetaan parametriksi muuttuja eka. Metodia kutsuttaessa parametriksi annetun muuttujan arvo kopioituu metodin parametriksi. Koska muuttuja eka on viittaustyyppinen, kopioituu metodin käyttöön aiemmin luotu viite. Metodin suorituksen lopussa tilanne on seuraava -- metodi kasvattaa parametrina saamansa olion syntymävuotta yhdellä.
</p>

<img src="/img/drawings/eka-2.png"/>

<p>
  Kun metodin nuorenna suoritus loppuu, palataan takaisin main-metodiin. Nuorenna-metodin suoritukseen liittyvät tiedot katoavat kutsupinosta. 
</p>

<img src="/img/drawings/eka-3.png"/>

<p>
  Metodikutsusta palaamisen jälkeen suoritetaan taas muuttujan eka arvon tulostaminen. Tällä kertaa muuttujan eka osoittama olio on muuttunut hieman -- edellisen metodikutsun yhteydessä viitatun olion syntymäpäivä-muuttujaa kasvatettiin yhdellä. Tulostukseksi tulee lopulta "Eka (1971)".
</p>

<p>
  Tämän jälkeen ohjelmassa esitellään uusi Henkilo-tyyppinen muuttuja toka. Muuttujaan toka kopioidaan muuttujan eka arvo, eli muuttujan toka arvoksi tulee viite jo olemassaolevaan Henkilo-olioon.
</p>

<img src="/img/drawings/eka-4.png"/>

<p>
  Tämän jälkeen kutsutaan metodia nuorenna, jolle annetaan parametriksi muuttuja toka. Metodia kutsuttaessa parametriksi annetun muuttujan arvo kopioituu metodin arvoksi. Metodi saa siis käyttöönsä muuttujan toka sisältämän viitteen. Metodin suorituksen lopuksi metodin viittaaman olion syntymävuosi on kasvanut yhdellä.
</p>

<img src="/img/drawings/eka-5.png"/>

<p>
  Lopulta metodin suoritus päättyy, ja ohjelman suoritus palaa takaisin main-metodiin. Main-metodissa tulostetaan vielä kerran muuttujan eka arvo. Tulostukseksi tulee lopulta "Eka (1972)".
</p>


<%= partial 'partials/quiz', locals: { id: '59d2aa2945370b0004080777' } %>



<%= partial 'partials/quiz', locals: { id: '59d2ab9045370b000408077b' } %>



<% partial 'partials/material_heading' do %>
  Listat ja oliot
<% end %>

<p>
  Edellisessä osassa tutuksi tulleet listat ovat olioita, joihin pystyy lisäämään arvoja. Listalle lisättyjä arvoja voidaan tarkastella indeksin perusteella, ja listalla olevia arvoja voidaan etsiä ja poistaa. Kaikkia listan tarjoamia toimintoja käytetään listan tarjoamien metodien kautta.
</p>

<p>
  Listalle lisättävien muuttujien tyyppi määrätään listan luomisen yhteydessä annettavan tyyppiparametrin avulla. Esimerkiksi <code>ArrayList&lt;String&gt;</code> sisältää merkkijonoja, <code>ArrayList&lt;Integer&gt;</code> sisältää kokonaislukuja, ja <code>ArrayList&lt;Double&gt;</code> sisältää liukulukuja.
</p>

<p>
  Alla olevassa esimerkissä lisätään ensin merkkijonoja listalle, jonka jälkeen listalla olevat merkkijonot tulostetaan yksitellen.
</p>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;String&gt; nimet = new ArrayList&lt;&gt;();

  // merkkijono voidaan ensin muuttujaan
  String nimi = "Betty Jennings";
  // ja sitten lisätä se listalle
  nimet.add(nimi);

  // merkkijono voidaan myös lisätä suoraan listalle:
  nimet.add("Betty Snyder");
  nimet.add("Frances Spence");
  nimet.add("Kay McNulty");
  nimet.add("Marlyn Wescoff");
  nimet.add("Ruth Lichterman");

  // listan alkioiden läpikäynti onnistuu toistolauseen avulla
  int indeksi = 0;
  while (indeksi &lt; nimet.size()) {
      System.out.println(nimet.get(indeksi));
      indeksi++;
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Betty Jennings
  Betty Snyder
  Frances Spence
  Kay McNulty
  Marlyn Wescoff
  Ruth Lichterman
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Olioita listalla
<% end %>

<p>
  Edellisessä osassa lisäsimme listalle muunmuassa merkkijonoja. Merkkijonot ovat olioita, joten ei liene yllätys että listalla voi olla olioita. Tarkastellaan seuraavaksi listan ja olioiden yhteistoimintaa tarkemmin.
</p>

<p>
  Oletetaan, että käytössämme on alla oleva luokka.
</p>


<% partial 'partials/code_highlight' do %>
  public class Henkilo {

      private String nimi;
      private int ika;
      private int paino;
      private int pituus;

      public Henkilo(String nimi) {
          this.nimi = nimi;
          this.ika = 0;
          this.paino = 0;
          this.pituus = 0;
      }

      // muita konstruktoreja ja metodeja

      public String getNimi() {
          return this.nimi;
      }

      public int getIka() {
          return this.ika;
      }

      public void vanhene() {
          this.ika++;
      }

      public void setPituus(int uusiPituus) {
          this.pituus = uusiPituus;
      }

      public void setPaino(int uusiPaino) {
          this.paino = uusiPaino;
      }

      public double painoIndeksi() {
          double pituusPerSata = this.pituus / 100.0;
          return this.paino / (pituusPerSata * pituusPerSata);
      }

      @Override
      public String toString() {
          return this.nimi + ", ikä " + this.ika + " vuotta";
      }
  }
<% end %>

<p>
  Olioiden käsittely listalla ei oikeastaan poikkea aiemmin näkemästämme listan käytöstä millään tavalla. Oleellista on vain listalle lisättävien olioiden tyypin määrittely listan luomisen yhteydessä.
</p>

<p>
  Alla olevassa esimerkissä luodaan ensin Henkilo-tyyppisille olioille tarkoitettu lista, jonka jälkeen listalle lisätään henkilöolioita. Lopulta henkilöoliot tulostetaan yksitellen.
</p>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  // henkilöolio voidaan ensin luoda
  Henkilo juhana = new Henkilo("Juhana");
  // ja sitten lisätä se listalle
  henkilot.add(juhana);

  // henkilöolio voidaan myös lisätä listalle "samassa lauseessa"
  henkilot.add(new Henkilo("Matti"));
  henkilot.add(new Henkilo("Martin"));

  int indeksi = 0;
  while (indeksi &lt; henkilot.size()) {
      System.out.println(henkilot.get(indeksi));
      indeksi++;
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Juhana, ikä 0 vuotta
  Matti, ikä 0 vuotta
  Martin, ikä 0 vuotta
<% end %>

<p>
  Aiemmin käyttämämme rakenne syötteiden lukemiseen on yhä varsin käytännöllinen.
</p>

<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);
  ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  while (true) {
      System.out.print("Kirjoita nimi, tyhjä lopettaa: ");
      String nimi = lukija.nextLine();
      if (nimi.isEmpty()) {
          break;
      }

      henkilot.add(new Henkilo(nimi));
  }

  System.out.println();
  System.out.println("Henkilöitä yhteensä: " + henkilot.size());
  System.out.println("Henkilöt: ");

  int indeksi = 0;
  while (indeksi &lt; henkilot.size()) {
      Henkilo henkilo = henkilot.get(indeksi);
      System.out.println(henkilo);
      // tai: System.out.println(henkilot.get(indeksi));

      indeksi++;
  }
<% end %>

<p>
  Listalla olevia olioita voidaan myös tarkastella listan läpikäynnin yhteydessä. Alla olevassa esimerkissä tulostetaan vain täysi-ikäiset henkilöt.
</p>

<% partial 'partials/code_highlight' do %>
  // ..
  int indeksi = 0;
  while (indeksi &lt; henkilot.size()) {
      Henkilo henkilo = henkilot.get(indeksi);

      if (henkilo.getIka() &gt;= 18) {
          System.out.println(henkilo);
      }

      indeksi++;
  }
<% end %>

<p>
  Ikärajan voi kysyä myös käyttäjältä.
</p>

<% partial 'partials/code_highlight' do %>
  // ..
  System.out.print("Mikä ikäraja? ");
  int ikaraja = Integer.parseInt(lukija.nextLine());

  int indeksi = 0;
  while (indeksi &lt; henkilot.size()) {
      Henkilo henkilo = henkilot.get(indeksi);

      if (henkilo.getIka() &gt;= ikaraja) {
          System.out.println(henkilo);
      }

      indeksi++;
  }
<% end %>



<% partial 'partials/exercise', locals: { name: 'Televisio-ohjelmat' } do %>

  <p>
    Tehtäväpohjassa on valmiina televisio-ohjelmaa kuvaava luokka Ohjelma. Luokalla Ohjelma on oliomuuttujat nimi ja pituus, konstruktori, ja muutamia metodeja.
  </p>

  <p>
    Toteuta ohjelma, joka ensin lukee käyttäjältä televisio-ohjelmia. Kun käyttäjä syöttää tyhjän ohjelman nimen, televisio-ohjelmien lukeminen lopetetaan.
  </p>

  <p>
    Tämän jälkeen käyttäjältä kysytään ohjelman maksimipituutta. Kun käyttäjä on syöttänyt ohjelman maksimipituuden, tulostetaan kaikki ne ohjelmat, joiden pituus on pienempi tai yhtäsuuri kuin haluttu maksimipituus.
  </p>

  <% partial 'partials/sample_output' do %>
    Nimi: <font color="red">Salatut elämät</font>
    Pituus: <font color="red">30</font>
    Nimi: <font color="red">Miehen puolikkaat</font>
    Pituus: <font color="red">30</font>
    Nimi: <font color="red">Remppa vai muutto</font>
    Pituus: <font color="red">60</font>
    Nimi: <font color="red">House</font>
    Pituus: <font color="red">60</font>

    Ohjelman maksimipituus? <font color="red">30</font>
    Salatut elämät, 30 minuuttia
    Miehen puolikkaat, 30 minuuttia
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Kirjat (2 osaa)' } do %>

  <p>
    Toteuta ohjelma, joka ensin lukee kirjojen tietoja käyttäjältä. Jokaisesta kirjasta tulee lukea kirjan nimi, sivujen lukumäärä sekä kirjoitusvuosi. Kirjojen lukeminen lopetetaan kun käyttäjä syöttää tyhjän kirjan nimen.
  </p>

  <p>
    Tämän jälkeen käyttäjältä kysytään mitä tulostetaan. Jos käyttäjä syöttää merkkijonon "kaikki", tulostetaan kirjojen nimet, sivujen lukumäärät sekä kirjoitusvuodet. Jos taas käyttäjä syöttää merkkijonon "nimi", tulostetaan vain kirjojen nimet.
  </p>

  <p>
    Ohjelmaa varten kannattanee toteuttaa Kirjaa kuvaava luokka. Vaikka tehtävässä on todellisuudessa vain yksi osa, on se kahden osan arvoinen.
  </p>

  <% partial 'partials/sample_output' do %>
    Nimi: <font color="red">Minä en sitten muutu</font>
    Sivuja: <font color="red">201</font>
    Kirjoitusvuosi: <font color="red">2010</font>
    Nimi: <font color="red">Nalle Puh ja elämisen taito</font>
    Sivuja: <font color="red">100</font>
    Kirjoitusvuosi: <font color="red">2005</font>
    Nimi: <font color="red">Beautiful Code</font>
    Sivuja: <font color="red">593</font>
    Kirjoitusvuosi: <font color="red">2007</font>
    Nimi: <font color="red">KonMari</font>
    Sivuja: <font color="red">222</font>
    Kirjoitusvuosi: <font color="red">2011</font>

    Mitä tulostetaan? <font color="red">kaikki</font>
    Minä en sitten muutu, 201 sivua, 2010
    Nalle Puh ja elämisen taito, 100 sivua, 2005
    Beautiful Code, 593 sivua, 2007
    KonMari, 222 sivua, 2011
  <% end %>

  <% partial 'partials/sample_output' do %>
    Nimi: <font color="red">Minä en sitten muutu</font>
    Sivuja: <font color="red">201</font>
    Kirjoitusvuosi: <font color="red">2010</font>
    Nimi: <font color="red">Nalle Puh ja elämisen taito</font>
    Sivuja: <font color="red">100</font>
    Kirjoitusvuosi: <font color="red">2005</font>
    Nimi: <font color="red">Beautiful Code</font>
    Sivuja: <font color="red">593</font>
    Kirjoitusvuosi: <font color="red">2007</font>
    Nimi: <font color="red">KonMari</font>
    Sivuja: <font color="red">222</font>
    Kirjoitusvuosi: <font color="red">2011</font>

    Mitä tulostetaan? <font color="red">nimi</font>
    Minä en sitten muutu
    Nalle Puh ja elämisen taito
    Beautiful Code
    KonMari
  <% end %>
<% end %>




<% partial 'partials/material_sub_heading' do %>
  Listakin sisältää viitteitä
<% end %>

<p>
  Kun olio lisätään listalle, listalle kopioidaan viite. Kuten aiemmin, olion sisäisestä tilasta ei luoda kopiota, vaan listalle lisätään viite olemassa olevaan olioon.
</p>

<p>
  Alla olevassa esimerkissä luodaan ensin olio <code>juhana</code>, joka lisätään listalle. Tämän jälkeen listalle lisätään kaksi muuta oliota. Seuraavaksi <code>juhana</code>-olion metodia <code>vanhene</code> kutsutaan. Lopulta jokaista listalla olevaa oliota vanhennetaan.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  Henkilo juhana = new Henkilo("Juhana");
  henkilot.add(juhana);

  henkilot.add(new Henkilo("Matti"));
  henkilot.add(new Henkilo("Martin"));

  // juhana vanhenee 2 vuotta
  juhana.vanhene();
  juhana.vanhene();

  // jokainen listalla oleva henkilöolio vanhenee vuoden
  int indeksi = 0;
  while (indeksi &lt; henkilot.size()) {
      Henkilo henkilo = henkilot.get(indeksi);
      henkilo.vanhene();
      indeksi++;
  }

  // tulostetaan henkilöt
  indeksi = 0;
  while (indeksi &lt; henkilot.size()) {
      Henkilo henkilo = henkilot.get(indeksi);
      System.out.println(henkilo);

      // tai: System.out.println(henkilot.get(indeksi));

      indeksi++;
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Juhana, ikä 3 vuotta
  Matti, ikä 1 vuotta
  Martin, ikä 1 vuotta
<% end %>

<p>
  Listalle on kopioituna viitteet olioihin. Yllä olevassa esimerkissä muuttujan <code>juhana</code> arvona on sama viite kuin listalla, joten "Juhanan" ikä muuttuu myös jos hän vanhenee listan ulkopuolella.
</p>

<img src="/img/drawings/henkilot-ja-juhana.png"/>

<p>
  &nbsp;
</p>


<% partial 'partials/material_sub_heading' do %>
  Lista oliomuuttujana
<% end %>

<p>
  Listat ovat olioita, joten oliomuuttujaksi voi asettaa listan. Tarkastellaan tätä seuraavaksi.
</p>

<p>
  Olemme aiemmin huomanneet, että listat ovat esimerkiksi näppäriä silloin, silloin kun haluamme pitää kirjaa useammasta erillisestä asiasta. Alla olevassa esimerkissä käsitteelle soittolista on luotu luokka. Soittolista sisältää kappaleita.
</p>

<% partial 'partials/code_highlight' do %>
  // importit

  public class Soittolista {
      private ArrayList&lt;String&gt; kappaleet;

      public Soittolista() {
          this.kappaleet = new ArrayList&lt;&gt;();
      }

      public void lisaaKappale(String kappale) {
          this.kappaleet.add(kappale);
      }

      public void poistaKappale(String kappale) {
          this.kappaleet.remove(kappale);
      }

      public void tulostaKappaleet() {
          int indeksi = 0;
          while (indeksi &lt; this.kappaleet.size()) {
              String kappale = this.kappaleet.get(indeksi);
              System.out.println(kappale);

              indeksi++;
          }
      }
  }
<% end %>

<p>
  Soittolistojen luominen on edellisen luokan avulla helppoa.
</p>

<% partial 'partials/code_highlight' do %>
  Soittolista lista = new Soittolista();
  lista.lisaaKappale("Sorateiden kuningas");
  lista.lisaaKappale("Teuvo, maanteiden kuningas");
  lista.tulostaKappaleet();
<% end %>

<% partial 'partials/sample_output' do %>
  Sorateiden kuningas
  Teuvo, maanteiden kuningas
<% end %>


<% partial 'partials/exercise', locals: { name: 'Ruokalista (3 osaa)' } do %>

  <p>
    Kumpulan kampuksella Helsingissä toimivaan Unicafe-nimiseen gourmet-ravintolaan tarvitaan uusi ruokalista. Keittiömestari tietää ohjelmoinnista, ja haluaa listan hallinnointiin tietokonejärjestelmän. Toteutetaan tässä tehtävässä järjestelmän sydän, luokka Ruokalista.
  </p>

  <p>
    Tehtäväpohjan mukana tulee <code>Main</code>-luokka, jossa voit testata ruokalistan toimintaa. Ruokalistan toteuttamista varten saat seuraavanlaisen tehtäväpohjan:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.ArrayList;

    public class Ruokalista {

        private ArrayList&lt;String&gt; ateriat;

        public Ruokalista() {
            this.ateriat = new ArrayList&lt;&gt;();
        }

        // toteuta tänne tarvittavat metodit
    }
  <% end %>

  <p>
    Ruokalistaoliolla on oliomuuttujana ArrayList, jonka on tarkoitus tallentaa ruokalistalla olevien ruokalajien nimet. Ruokalistan tulee tarjota seuraavat metodit:
  </p>

  <ul>
    <li>
      <code>public void lisaaAteria(String ateria)</code> lisää aterian ruokalistalle.
    </li>
    <li>
      <code>public void tulostaAteriat()</code> tulostaa ateriat.
    </li>
    <li>
      <code>public void tyhjennaRuokalista()</code> tyhjentää ruokalistan.
    </li>    
  </ul>


  <h2>Aterian lisääminen</h2>

  <p>
    Toteuta metodi <code>public void lisaaAteria(String ateria)</code>, joka lisää uuden aterian listalle <code>ateriat</code>. Jos lisättävä ateria on jo listalla, sitä ei tule lisätä uudelleen. Jos et muista miten listalla olemassaoloa tarkastellaan, lue edellisestä osasta kohta "Onko listalla".
  </p>


  <h2>Aterioiden tulostaminen</h2>

  <p>
    Toteuta metodi <code>public void tulostaAteriat()</code>, joka tulostaa ateriat. Kolmen aterian lisäyksen jälkeen tulostuksen tulee olla seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
    ensimmäisenä lisätty ateria
    toisena lisätty ateria
    kolmantena lisätty ateria
  <% end %>


  <h2>Ruokalistan tyhjentäminen</h2>

  <p>
    Toteuta metodi <code>public void tyhjennaRuokalista()</code> joka tyhjentää ruokalistan. <code>ArrayList</code>-luokalla on metodi josta on tässä hyötyä. NetBeans osaa vihjata käytettävissä olevista metodeista kun kirjoitat olion nimen ja pisteen. Yritä kirjoittaa <code>ateriat.</code> metodirungon sisällä ja katso mitä käy.
  </p>

<% end %>


<p>
  Oliomuuttujana oleva lista voi sisältää myös muunlaisia olioita. Laajennetaan neljännessä osassa hahmoteltua luokkaa <code>PainonvartijaYhdistys</code> siten, että yhdistys lisää kaikki jäsenensä listalle. Laajennetussa versiossa konstruktorille annetaan alimman painoindeksin lisäksi myös nimi:
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      private double alinPainoindeksi;
      private String nimi;
      private ArrayList&lt;Henkilo&gt; jasenet;

      public PainonvartijaYhdistys(String nimi, double alinPainoindeksi) {
          this.alinPainoindeksi = alinPainoindeksi;
          this.nimi = nimi;
          this.jasenet = new ArrayList&lt;&gt;();
      }

      //..
  }
<% end %>

<p>
  Tehdään metodi jolla henkilö liitetään yhdistykseen. Metodi ei liitä yhdistykseen kuin tarpeeksi suuren painoindeksin omaavat henkilöt. Tehdään myös toString jossa tulostetaan jäsenten nimet:
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      // ...

      public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
          if (henkilo.painoIndeksi() &lt; this.alinPainoindeksi) {
              return false;
          }

          return true;
      }

      public void lisaaJaseneksi(Henkilo henkilo) {
          // sama kuin hyvaksytaanJaseneksi(henkilo) == false
          if (!hyvaksytaanJaseneksi(henkilo)) {
              // void-tyyppisistä metodeista voi palata
              // return-kutsulla
              return;
          }

          this.jasenet.add(henkilo);
      }

      public String toString() {
          String jasenetMerkkijonona = "";

          int indeksi = 0;
          while (indeksi &lt; this.jasenet.size()) {
              Henkilo jasen = this.jasenet.get(indeksi);
              jasenetMerkkijonona += "  " + jasen.getNimi() + "\n";
              indeksi++;
          }

          return "Painonvartijayhdistys " + this.nimi + " jäsenet: \n" + jasenetMerkkijonona;
      }
  }
<% end %>

<p>
  Metodi <code>lisaaJaseneksi</code> käyttää aiemmin tehtyä metodia <code>hyvaksytaanJaseneksi</code>.
</p>

<p>
  Kokeillaan laajentunutta painonvartijayhdistystä:
</p>

<% partial 'partials/code_highlight' do %>
  PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpulan paino", 25);

  Henkilo matti = new Henkilo("Matti");
  matti.setPaino(86);
  matti.setPituus(180);
  painonVartija.lisaaJaseneksi(matti);

  Henkilo juhana = new Henkilo("Juhana");
  juhana.setPaino(64);
  juhana.setPituus(172);
  painonVartija.lisaaJaseneksi(juhana);

  Henkilo harri = new Henkilo("Harri");
  harri.setPaino(104);
  harri.setPituus(182);
  painonVartija.lisaaJaseneksi(harri);

  Henkilo petri = new Henkilo("Petri");
  petri.setPaino(112);
  petri.setPituus(173);
  painonVartija.lisaaJaseneksi(petri);

  System.out.println(painonVartija);
<% end %>

<p>
  Tulostuksesta huomaamme, että Juhanaa ei kelpuutettu jäseneksi:
</p>

<% partial 'partials/sample_output' do %>
  Painonvartijayhdistys Kumpulan paino jäsenet:
  Matti
  Harri
  Petri
<% end %>


<div class="parqu-exercise" data-id="21" data-name="Arraylist oliona"></div>

<!-- CAST4 -->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=Rut2pt5ztN0" height="300" target="_blank" rel="noopener"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>


<p>
  Tehdään vielä lopuksi painovartijayhdistykselle metodi, jolla saadaan tietoon yhdistyksen suurimman painoindeksin omaava henkilö.
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      // ...

      public Henkilo suurinPainoindeksinen() {
          // jos jasenlista on tyhjä, palautetaan null-viite
          if (this.jasenet.isEmpty()) {
              return null;
          }

          Henkilo painavinTahanAsti = this.jasenet.get(0);

          int indeksi = 0;
          while (indeksi < this.jasenet.size()) {
              Henkilo henkilo = this.jasenet.get(indeksi);
              if (henkilo.painoIndeksi() &gt; painavinTahanAsti.painoIndeksi()) {
                  painavinTahanAsti = henkilo;
              }

              indeksi++;
          }

          return painavinTahanAsti;
      }
  }
<% end %>

<p>
  Logiikaltaan edeltävä metodi toimii samaan tapaan kuin suurimman luvun etsiminen taulukosta. Käytössä on apumuuttuja <code>painavinTahanAsti</code> joka laitetaan aluksi viittaamaan listan ensimmäiseen henkilöön. Sen jälkeen käydään lista läpi ja katsotaan tuleeko vastaan suuremman painoindeksin omaavia henkilöitä, jos tulee, niin otetaan viite talteen muuttujaan <code>painavinTahanAsti</code>. Lopuksi palautetaan muuttujan arvo eli viite henkilöolioon.
</p>

<p>
  Tehdään lisäys edelliseen pääohjelmaan. Pääohjelma ottaa vastaan metodin palauttaman viitteen muuttujaan <code>painavin</code>.
</p>

<% partial 'partials/code_highlight' do %>
  PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpulan paino", 25);

  // .. lisätään listalle ..

  Henkilo painavin = painonVartija.suurinPainoindeksinen();
  System.out.print("suurin painoindeksi on jäsenellä " + painavin.getNimi());
<% end %>

<% partial 'partials/sample_output' do %>
  suurin painoindeksi on jäsenellä Petri
<% end %>


<% partial 'partials/exercise', locals: { name: 'Puhelinmuistio (3 osaa)' } do %>

  <p>
    Tehtävässä tehdään puhelinmuistio.
  </p>

  <h2>Henkilö</h2>

  <p>
    Tee ensin luokka <code>Henkilo</code>. Luokan tulee toimia seuraavan esimerkin osoittamalla tavalla:
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo pekka = new Henkilo("Pekka Mikkola", "040-123123");

    System.out.println(pekka.getNimi());
    System.out.println(pekka.getNumero());

    System.out.println(pekka);

    pekka.vaihdaNumeroa("050-333444");
    System.out.println(pekka);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka Mikkola
    040-123123
    Pekka Mikkola  puh: 040-123123
    Pekka Mikkola  puh: 050-333444
  <% end %>

  <p>
    Tee siis luokalle
  </p>

  <ul>
    <li> metodi <code>public String toString()</code>, joka palauttaa henkilön merkkijonoesityksen (yo. esimerkin tapaan muotoiltuna)</li>
    <li> konstruktori, jolla asetetaan henkilölle nimi ja puhelinnumero</li>
    <li> <code>public String getNimi()</code>, joka palauttaa nimen</li>
    <li> <code>public String getNumero()</code>, joka palauttaa puhelinnumeron</li>
    <li> metodi <code>public void vaihdaNumeroa(String uusiNumero)</code>, joka muuttaa henkilön puhelinnumeroa</li>
  </ul>

  
  <h2>Henkilöiden lisäys puhelinmuistioon</h2>

  <p>
    Tee luokka <code>Puhelinmuistio</code> joka tallettaa sisällään olevaan ArrayListiin <code>Henkilo</code>-olioita. Tässä vaiheessa luokalle tehdään seuraavat metodit:
  </p>

  <ul>
    <li> <code>public void lisaa(String nimi, String numero)</code> luo <code>Henkilo</code>-olion ja lisää sen puhelinmuistion ArrayListiin.</li>
    <li><code>public void tulostaKaikki()</code>, tulostaa puhelinmuistion sisällön</li>
  </ul>

  <p>
    Esimerkki muistion toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Puhelinmuistio muistio = new Puhelinmuistio();

    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    muistio.tulostaKaikki();
  <% end %>

  <p>
    Ohjelman tulostus oikein toteutetuilla luokilla on:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka Mikkola  puh: 040-123123
    Antti Laaksonen  puh: 045-456123
    Juhana Laurinharju  puh: 050-222333
  <% end %>

  
  <h2>Numerojen haku muistiosta</h2>

  <p>
    Tehdään puhelinmuistiolle metodi <code>public String haeNumero(String nimi)</code>, joka  palauttaa parametrina annetun henkilön numeron. Jos henkilö ei ole muistiossa, palautetaan merkkijono "numero ei tiedossa". Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Puhelinmuistio muistio = new Puhelinmuistio();
    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    String numero = muistio.haeNumero("Pekka Mikkola");
    System.out.println(numero);

    numero = muistio.haeNumero("Martti Tienari");
    System.out.println(numero);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    040-123123
    numero ei tiedossa
  <% end %>
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Joukkueet ja pelaajat (5 osaa)' } do %>

  <p>
    Tässä tehtävässä tehdään joukkueiden ja joukkueen pelaajien ylläpitoon tarkoitettuun ohjelmistoon tarvittavat ydinluokat.
  </p>

  <h2>Joukkue</h2>

  <p>
    Tee luokka <code>Joukkue</code>, johon tallennetaan joukkueen nimi (<code>String</code>). Tee luokkaan seuraavat metodit:
  </p>

  <ul>
    <li> konstruktori, jolle annetaan joukkueen nimi</li>
    <li> <code>getNimi</code>, joka palauttaa joukkueen nimen</li>
  </ul>

  <p>
    Seuraava pääohjelma testaa luokan toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Joukkue tapiiri = new Joukkue("FC Tapiiri");
            System.out.println("Joukkue: " + tapiiri.haeNimi());
        } 
    }
  <% end %>

  <p>
    Ohjelman tulostus on seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Joukkue: FC Tapiiri
  <% end %>

  <h2>Pelaaja</h2>

  <p>
    Luo luokka <code>Pelaaja</code>, johon tallennetaan pelaajan nimi ja tehtyjen maalien määrä. Tee luokkaan kaksi konstruktoria: yksi jolle annetaan vain pelaajan nimi, toinen jolle annetaan sekä pelaajan nimi että pelaajan tekemien maalien määrä. Lisää pelaajalle myös metodit:
  </p>

  <ul>
    <li> <code>getNimi</code>, joka palauttaa pelaajan nimen</li>
    <li> <code>getMaalit</code>, joka palauttaa tehtyjen maalien määrän</li>
    <li> <code>toString</code>, joka palauttaa pelaajan merkkijonoesityksen</li>
  </ul>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Joukkue tapiiri = new Joukkue("FC Tapiiri");
            System.out.println("Joukkue: " + tapiiri.getNimi());

            Pelaaja matti = new Pelaaja("Matti");
            System.out.println("Pelaaja: " + matti);

            Pelaaja pekka = new Pelaaja("Pekka", 39);
            System.out.println("Pelaaja: " + pekka);
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Joukkue: FC Tapiiri
    Pelaaja: Matti, maaleja 0
    Pelaaja: Pekka, maaleja 39
  <% end %>

  
  <h2>Pelaajat joukkueisiin</h2>

  <p>
    Lisää luokkaan <code>Joukkue</code> seuraavat metodit:
  </p>

  <ul>
    <li> <code>lisaaPelaaja</code>, joka lisää pelaajan joukkueeseen</li>
    <li> <code>tulostaPelaajat</code>, joka tulostaa joukkueessa olevat pelaajat</li>
  </ul>

  <p>
    Tallenna joukkueessa olevat pelaajat <code>Joukkue</code>-luokan sisäiseen <code>ArrayList</code>-listaan.
  </p>

  <p>
    Seuraava pääohjelma testaa luokan toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Joukkue tapiiri = new Joukkue("FC Tapiiri");

            Pelaaja matti = new Pelaaja("Matti");
            Pelaaja pekka = new Pelaaja("Pekka", 39);

            tapiiri.lisaaPelaaja(matti);
            tapiiri.lisaaPelaaja(pekka);
            tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

            tapiiri.tulostaPelaajat();
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Matti, maaleja 0
    Pekka, maaleja 39
    Mikael, maaleja 1
  <% end %>

  
  <h2>Joukkueen maksimikoko ja nykyinen koko</h2>

  <p>
    Lisää luokkaan <code>Joukkue</code> seuraavat metodit:
  </p>

  <ul>
    <li> <code>setMaksimikoko(int maksimikoko)</code>, joka asettaa joukkueen maksimikoon (eli maksimimäärän pelaajia)</li>
    <li> <code>getPelaajienLukumaara</code>, joka palauttaa pelaajien määrän (<code>int</code>)</li>
  </ul>

  <p>
    Joukkueen suurin sallittu pelaajamäärä on oletusarvoisesti 16 (lisää tämä luokan oliomuuttujaksi ja alusta muuttujan arvo konstruktorissa). Metodin <code>setMaksimikoko</code> avulla tätä rajaa voi muuttaa. Muuta edellisessä osassa tehtyä metodia <code>lisaaPelaaja</code> niin, että se ei lisää pelaajaa joukkueeseen, jos sallittu pelaajamäärä ylittyisi.
  </p>

  <p>
    <strong>HUOM:</strong> muista lisätä oletusarvoinen maksimikoko koodiisi sillä muuten arvoksi tulee 0. Tämä aiheuttaa edellisen kohdan testien hajoamisen, sillä testit luovat oletusmaksimikokoisia joukkueita ja jos joukkueen maksimikoko on 0, ei joukkueeseen voi lisätä yhtään pelaajaa.
  </p>

  <p>
    Seuraava pääohjelma testaa luokan toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Joukkue tapiiri = new Joukkue("FC Tapiiri");
            tapiiri.setMaksimikoko(1);

            Pelaaja matti = new Pelaaja("Matti");
            Pelaaja pekka = new Pelaaja("Pekka", 39);
            tapiiri.lisaaPelaaja(matti);
            tapiiri.lisaaPelaaja(pekka);
            tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

            System.out.println("Pelaajia yhteensä: " + tapiiri.getPelaajienLukumaara());
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Pelaajia yhteensä: 1
  <% end %>

  
  <h2>Joukkueen maalit</h2>

  <p>
    Lisää luokkaan <code>Joukkue</code> metodi:
  </p>

  <ul>
    <li> <code>yhteismaalit</code>, joka palauttaa joukkueen pelaajien tekemien maalien yhteismäärän.</li>
  </ul>

  <p>
    Seuraava pääohjelma testaa luokan toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Joukkue tapiiri = new Joukkue("FC Tapiiri");

            Pelaaja matti = new Pelaaja("Matti");
            Pelaaja pekka = new Pelaaja("Pekka", 39);
            tapiiri.lisaaPelaaja(matti);
            tapiiri.lisaaPelaaja(pekka);
            tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

            System.out.println("Maaleja yhteensä: " + tapiiri.yhteismaalit());
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do%>
    Maaleja yhteensä: 40
  <% end %>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Lahjapakkaamo (2 osaa)' } do %>


  <p>
    Tässä tehtävässä harjoitellaan lahjojen pakkaamista. Tehdään luokat <code>Lahja</code> ja <code>Pakkaus</code>. Lahjalla on nimi ja paino, ja Pakkaus sisältää lahjoja.
  </p>

  <h2>Lahja-luokka</h2>

  <p>
    Tee luokka <code>Lahja</code>, josta muodostetut oliot kuvaavat erilaisia lahjoja. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li>Konstruktori, jolle annetaan parametrina lahjan nimi ja paino</li>
    <li>Metodi <code>public String getNimi()</code>, joka palauttaa lahjan nimen</li>
    <li>Metodi <code>public int getPaino()</code>, joka palauttaa lahjan painon</li>
    <li>Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "nimi (paino kg)"</li>
  </ul>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Lahja kirja = new Lahja("Aapiskukko", 2);

            System.out.println("Lahjan nimi: " + kirja.getNimi());
            System.out.println("Lahjan paino: " + kirja.getPaino());

            System.out.println("Lahja: " + kirja);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Lahjan nimi: Aapiskukko
    Lahjan paino: 2
    Lahja: Aapiskukko (2 kg)<% end %>


  <h2>Pakkaus-luokka</h2>

  <p>
    Tee luokka <code>Pakkaus</code>. Pakkaus voi sisältää äärettömän määrän lahjoja, jonka lisäksi se tarjoaa metodin lahjojen yhteispainon laskemiseen.
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li> Parametriton konstruktori</li>
    <li> Metodi <code>public void lisaaLahja(Lahja lahja)</code>, joka lisää parametrina annettavan lahjan pakkaukseen. Metodi ei palauta mitään arvoa.</li>
  </ul>

  <p>
    Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Lahja&gt; lahjat = new ArrayList&lt;&gt;();
  <% end %>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Lahja kirja = new Lahja("Aapiskukko", 2);

            Pakkaus paketti = new Pakkaus();
            paketti.lisaaLahja(kirja);
            System.out.println(paketti.getPaino());
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    2
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Tavara, Matkalaukku ja Lastiruuma (7 osaa)' } do %>

  <p>
    Tässä tehtäväsarjassa tehdään luokat <code>Tavara</code>, <code>Matkalaukku</code> ja <code>Lastiruuma</code>, joiden avulla harjoitellaan lisää olioita, jotka sisältävät toisia olioita.
  </p>

  <h2>Tavara-luokka</h2>

  <p>
    Tee luokka <code>Tavara</code>, josta muodostetut oliot vastaavat erilaisia tavaroita. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li>Konstruktori, jolle annetaan parametrina tavaran nimi ja paino</li>
    <li>Metodi <code>public String getNimi()</code>, joka palauttaa tavaran nimen</li>
    <li>Metodi <code>public int getPaino()</code>, joka palauttaa tavaran painon</li>
    <li>Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "nimi (paino kg)"</li>
  </ul>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);

            System.out.println("Kirjan nimi: " + kirja.getNimi());
            System.out.println("Kirjan paino: " + kirja.getPaino());

            System.out.println("Kirja: " + kirja);
            System.out.println("Puhelin: " + puhelin);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Kirjan nimi: Aapiskukko
    Kirjan paino: 2
    Kirja: Aapiskukko (2 kg)
    Puhelin: Nokia 3210 (1 kg)<% end %>


  <h2>Matkalaukku-luokka</h2>

  <p>
    Tee luokka <code>Matkalaukku</code>. Matkalaukkuun liittyy tavaroita ja maksimipaino, joka määrittelee tavaroiden suurimman mahdollisen yhteispainon.
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li> Konstruktori, jolle annetaan maksimipaino</li>
    <li> Metodi <code>public void lisaaTavara(Tavara tavara)</code>, joka lisää parametrina annettavan tavaran matkalaukkuun. Metodi ei palauta mitään arvoa.</li>
    <li> Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "x tavaraa (y kg)"</li>
  </ul>

  <p>
    Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Tavara&gt; tavarat = new ArrayList&lt;&gt;();
  <% end %>

  <p>
    Luokan <code>Matkalaukku</code> tulee valvoa, että sen sisältämien tavaroiden yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi lisättävän tavaran vuoksi, metodi <code>lisaaTavara</code> ei saa lisätä uutta tavaraa laukkuun.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku matkalaukku = new Matkalaukku(5);
            System.out.println(matkalaukku);

            matkalaukku.lisaaTavara(kirja);
            System.out.println(matkalaukku);

            matkalaukku.lisaaTavara(puhelin);
            System.out.println(matkalaukku);

            matkalaukku.lisaaTavara(tiiliskivi);
            System.out.println(matkalaukku);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    0 tavaraa (0 kg)
    1 tavaraa (2 kg)
    2 tavaraa (3 kg)
    2 tavaraa (3 kg)
  <% end %>


  <h2>Kielenhuoltoa</h2>

  <p>
    Ilmoitukset "0 tavaraa" ja "1 tavaraa" eivät ole kovin hyvää suomea &ndash; paremmat muodot olisivat "ei tavaroita" ja "1 tavara". Tee tämä muutos luokassa <code>Matkalaukku</code> sijaitsevaan toString-metodiin.
  </p>

  <p>
    Nyt edellisen ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    ei tavaroita (0 kg)
    1 tavara (2 kg)
    2 tavaraa (3 kg)
    2 tavaraa (3 kg)
  <% end %>


  <h2>Kaikki tavarat</h2>

  <p>
    Lisää luokkaan <code>Matkalaukku</code> seuraavat metodit:
  </p>

  <ul>
    <li> metodi <code>tulostaTavarat</code>, joka tulostaa kaikki matkalaukussa olevat tavarat</li>
    <li> metodi <code>yhteispaino</code>, joka palauttaa tavaroiden yhteispainon</li>
  </ul>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku matkalaukku = new Matkalaukku(10);
            matkalaukku.lisaaTavara(kirja);
            matkalaukku.lisaaTavara(puhelin);
            matkalaukku.lisaaTavara(tiiliskivi);

            System.out.println("Matkalaukussa on seuraavat tavarat:");
            matkalaukku.tulostaTavarat();
            System.out.println("Yhteispaino: " + matkalaukku.yhteispaino() + " kg");
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Matkalaukussa on seuraavat tavarat:
    Aapiskukko (2 kg)
    Nokia 3210 (1 kg)
    Tiiliskivi (4 kg)
    Yhteispaino: 7 kg
  <% end %>

  <p>
    Muokkaa myös luokkaasi siten, että käytät vain kahta oliomuuttujaa. Toinen sisältää maksimipainon, toinen on lista laukussa olevista tavaroista.
  </p>


  <h2>Raskain tavara</h2>

  <p>
    Lisää vielä luokkaan <code>Matkalaukku</code> metodi <code>raskainTavara</code>, joka palauttaa painoltaan suurimman tavaran. Jos yhtä raskaita tavaroita on useita, metodi voi palauttaa minkä tahansa niistä. Metodin tulee palauttaa olioviite. Jos laukku on tyhjä, palauta arvo <em>null</em>.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("Tiiliskivi", 4);

            Matkalaukku matkalaukku = new Matkalaukku(10);
            matkalaukku.lisaaTavara(kirja);
            matkalaukku.lisaaTavara(puhelin);
            matkalaukku.lisaaTavara(tiiliskivi);

            Tavara raskain = matkalaukku.raskainTavara();
            System.out.println("Raskain tavara: " + raskain);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Raskain tavara: Tiiliskivi (4 kg)<% end %>


  <h2>Lastiruuma-luokka</h2>

  <p>
    Tee luokka <code>Lastiruuma</code>, johon liittyvät seuraavat metodit:
  </p>

  <ul>
    <li> konstruktori, jolle annetaan maksimipaino</li>
    <li> metodi <code>public void lisaaMatkalaukku(Matkalaukku laukku)</code>, joka lisää parametrina annetun matkalaukun lastiruumaan</li>
    <li> metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "x matkalaukkua (y kg)"</li>
  </ul>

  <p>
    Tallenna matkalaukut sopivaan <code>ArrayList</code>-rakenteeseen.
  </p>

  <p>
    Luokan <code>Lastiruuma</code> tulee valvoa, että sen sisältämien matkalaukkujen yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi uuden matkalaukun vuoksi, metodi <code>lisaaMatkalaukku</code> ei saa lisätä uutta matkalaukkua.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku adanLaukku = new Matkalaukku(10);
            adanLaukku.lisaaTavara(kirja);
            adanLaukku.lisaaTavara(puhelin);

            Matkalaukku pekanLaukku = new Matkalaukku(10);
            pekanLaukku.lisaaTavara(tiiliskivi);

            Lastiruuma lastiruuma = new Lastiruuma(1000);
            lastiruuma.lisaaMatkalaukku(adanLaukku);
            lastiruuma.lisaaMatkalaukku(pekanLaukku);

            System.out.println(lastiruuma);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    2 matkalaukkua (7 kg)
  <% end %>


  <h2>Lastiruuman sisältö</h2>

  <p>
    Lisää luokkaan <code>Lastiruuma</code> metodi <code>public void tulostaTavarat()</code>, joka tulostaa kaikki lastiruuman matkalaukuissa olevat tavarat.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku adanLaukku = new Matkalaukku(10);
            adanLaukku.lisaaTavara(kirja);
            adanLaukku.lisaaTavara(puhelin);

            Matkalaukku pekanLaukku = new Matkalaukku(10);
            pekanLaukku.lisaaTavara(tiiliskivi);

            Lastiruuma lastiruuma = new Lastiruuma(1000);
            lastiruuma.lisaaMatkalaukku(adanLaukku);
            lastiruuma.lisaaMatkalaukku(pekanLaukku);

            System.out.println("Ruuman matkalaukuissa on seuraavat tavarat:");
            lastiruuma.tulostaTavarat();
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Ruuman matkalaukuissa on seuraavat tavarat:
    Aapiskukko (2 kg)
    Nokia 3210 (1 kg)
    tiiliskivi (4 kg)
  <% end %>

<% end %>


<% partial 'partials/material_heading' do %>
  Ensiaskeleet automaattiseen testaamiseen
<% end %>

<p>
  Otetaan seuraavaksi ensiaskeleet ohjelmien testaamiseen.
</p>


<% partial 'partials/material_sub_heading' do %>
  Virhetilanteet ja ongelman ratkaiseminen askel kerrallaan
<% end %>

<p>
  Ohjelmia luodessa niihin päätyy virheitä. Joskus virheet eivät ole niin vakavia, ja aiheuttavat päänvaivaa lähinnä ohjelman käyttäjälle. Joskus toisaalta virheet voivat johtaa hyvinkin vakaviin seurauksiin. Varmaa on joka tapauksessa se, että ohjelmoimaan opetteleva ihminen tekee paljon virheitä.
</p>

<p>
  Virheitä ei kannata missään nimessä pelätä tai välttää, sillä virheitä tekemällä oppii parhaiten. Pyri siis myös välillä rikkomaan työstämääsi ohjelmaa, jolloin pääset tutkimaan virheilmoitusta ja tarkastelemaan kertooko virheilmoitus jotain tekemästäsi virheestä.
</p>

<% partial 'partials/hint', locals: { name: 'Ohjelmistovirhe' } do %>

  <p>
    Osoitteessa <a href="http://sunnyday.mit.edu/accidents/MCO_report.pdf" target="_blank">http://sunnyday.mit.edu/accidents/MCO_report.pdf</a> oleva raportti kuvaa erään hieman vakavamman ohjelmistovirheestä johtuneen tapaturman sekä ohjelmistovirheen.
  </p>

  <p>
    Ohjelmistovirhe liittyi siihen, että käytetty ohjelma odotti, että ohjelmoija käyttäisi <a href="https://fi.wikipedia.org/wiki/Kansainv%C3%A4linen_yksikk%C3%B6j%C3%A4rjestelm%C3%A4" target="_blank">kansainvälistä yksikköjärjestelmää</a> laskuissa (metrit, kilogrammat, ...). Ohjelmoija oli kuitenkin käyttänyt <a href="https://en.wikipedia.org/wiki/English_Engineering_units" target="_blank">amerikkalaista mittajärjestelmää</a> erään järjestelmän osan laskuissa, jolloin satelliitin navigointiin liittynyt automaattinen korjausjärjestelmä ei toiminut oikein.
  </p>

  <p>
    Satelliitti tuhoutui.
  </p>

<% end %>


<p>
  Ohjelmien muuttuessa monimutkaisemmiksi, tulee virheiden löytämisestäkin haastavampaa. NetBeansiin integroitu debuggeri voi olla avuksi virheiden löytämisessä. Debuggerin käyttöä on esitelty kurssimateriaaliin upotetuilla videoilla; alla oleva video esittelee myös miten projekteja voidaan luoda, avata ja sulkea sekä miten ohjelmia voidaan suorittaa NetBeansin ulkopuolella. Screencastissa on myös asioita, joita kurssilla ei vielä ole tullut -- älä huoli, nämä tulevat vastaan opintojen edetessä.
</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=2QlbAvDPmk8" class="youtube" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<% partial 'partials/material_sub_heading' do %>
  Stack trace
<% end %>

<p>
  Kun ohjelmassa tapahtuu virhe, ohjelma tyypillisesti tulostaa ns. stack tracen, eli niiden metodikutsujen listan, joiden seurauksena virhetilanne syntyi. Stack trace voi näyttää esimerkiksi seuraavalta:
</p>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" ...
      at Ohjelma.main(Ohjelma.java:15)
<% end %>

<p>
  Listan alussa kerrotaan minkälainen virhe tapahtui (tässä ...), ja seuraavalla rivillä kerrotaan missä virhe tapahtui. Rivi "at Ohjelma.main(Ohjelma.java:15)" sanoo, että virhe tapahtui Ohjelma.java-tiedoston rivillä 15.
</p>

<% partial 'partials/sample_output' do %>
      at Ohjelma.main(Ohjelma.java:15)
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Muistilista virheenselvitykseen
<% end %>

<p>
  Jos koodisi ei toimi etkä tiedä missä on virhe, näillä askeleilla pääset alkuun.
</p>

<ol>
  <li>Sisennä koodisi oikein ja selvitä, puuttuuko sulkuja.</li>
  <li>Tarkista ovatko käytetyt muuttujat oikean nimisiä.</li>
  <li>Testaa ohjelman kulkua erilaisilla syötteillä, ja selvitä minkälaisella syötteellä ohjelma ei toimi halutusti. Jos sait virheen testeistä, testit saattavat myös kertoa käytetyn syötteen.</li>
  <li>Lisää ohjelmaan tulostuskomentoja, joissa tulostat käytettävien muuttujien arvoja ohjelman suorituksen eri vaiheissa.</li>
  <li>Tarkista, että kaikki käyttämäsi muuttujat on alustettu. Jos tätä ei ole tehty, seuraa virhe NullPointerException.</li>
  <li>Jos ohjelmasi aiheuttaa poikkeuksen, kannattaa ehdottomasti kiinnittää huomiota poikkeuksen yhteydessä olevaan <em>stack traceen</em>, eli niiden metodikutsujen listaan, minkä seurauksena poikkeuksen aiheuttanut tilanne syntyi.</li>
  <li>Opettele käyttämään debuggeria, aiemmin nähdyllä videolla pääsee alkuun.</li>
</ol>


<% partial 'partials/material_sub_heading' do %>
  Testisyötteen antaminen Scannerille
<% end %>

<p>
  Ohjelman testaaminen käsin on usein työlästä. Syötteen antaminen on mahdollista automatisoida esimerkiksi syöttämällä Scanner-oliolle luettava merkkijono. Alla on annettu esimerkki siitä, miten ohjelmaa voi testata automaattisesti. Ohjelmassa syötetään ensin viisi merkkijonoa, jonka jälkeen syötetään aiemmin nähty merkkijono. Tämän jälkeen yritetään syöttää vielä uusi merkkijono. Merkkijonoa "kuusi" ei pitäisi esiintyä sanajoukossa.
</p>

<p>
  Testisyötteen voi antaa merkkijonona Scanner-oliolle konstruktorissa. Jokainen testisyötteessä annettava rivinvaihto merkitään merkkijonoon kenoviivan ja n-merkin yhdistelmänä "\n".
</p>

<% partial 'partials/code_highlight' do %>
  String syote = "yksi\n" + "kaksi\n"  +
      "kolme\n" + "nelja\n" +
      "viisi\n" + "yksi\n"  +
      "kuusi\n";

  Scanner lukija = new Scanner(syote);

  ArrayList&lt;String&gt; luetut = new ArrayList&lt;&gt;();
  while (true) {
      System.out.println("Anna syote: ");
      String rivi = lukija.nextLine();
      if (luetut.contains(rivi)) {
          break;
      }

      luettu.add(rivi);
  }

  System.out.println("Kiitos!");

  if (luetut.sisaltaa("kuusi")) {
      System.out.println("Joukkoon lisättiin arvo, jota sinne ei olisi pitänyt lisätä.");
  }
<% end %>

<p>
  Ohjelma tulostus näyttää vain ohjelman antaman tulostuksen, ei käyttäjän tekemiä komentoja.
</p>

<% partial 'partials/sample_output' do %>
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Kiitos!
<% end %>

<p>
  Merkkijonon antaminen Scanner-luokan konstruktorille korvaa näppäimistöltä luettavan syötteen. Merkkijonomuuttujan <code>syote</code> sisältö siis "simuloi" käyttäjän antamaa syötettä. Rivinvaihto syötteeseen merkitään <code>\n</code>:llä. Jokainen yksittäinen rivinvaihtomerkkiin loppuva osa syote-merkkijonossa siis vastaa yhtä nextLine()-komentoon annettua syötettä.
</p>

<p>
  Kun haluat testata ohjelmasi toimintaa jälleen käsin, vaihda Scanner-olion konstruktorin parametriksi <code>System.in</code>, eli järjestelmän syötevirta. Voit toisaalta halutessasi myös vaihtaa testisyötettä, sillä kyse on merkkijonosta.
</p>

<p>
  Ohjelman toiminnan oikeellisuus tulee edelleen tarkastaa ruudulta. Tulostus voi olla aluksi hieman hämmentävää, sillä automatisoitu syöte ei näy ruudulla ollenkaan. Lopullinen tavoite on automatisoida myös ohjelman tulostuksen oikeellisuden tarkastaminen niin hyvin, että ohjelman testaus ja testituloksen analysointi onnistuu "nappia painamalla". Palaamme aiheeseen myöhemmissä osissa.
</p>


<% partial 'partials/exercise', locals: { name: 'Debuggailua' } do %>

  <p>
    Ohjelmassa on yritetty luoda sovellus, joka kysyy käyttäjältä merkkijonoa ja lukua. Sovelluksen pitäisi toimia esimerkiksi seuraavasti:
  </p>

  <% partial 'partials/sample_output' do %>
    Sana:
    <font color="red">testi</font>
    Luku:
    <font color="red">3</font>
    t
     e
      s
    t
     i
  <% end %>

  <p>
    Esimerkki 2:
  </p>

  <% partial 'partials/sample_output' do %>
    Sana:
    <font color="red">esim</font>
    Luku:
    <font color="red">2</font>
    e
     s
    i
     m
  <% end %>

  <p>
    Tällä hetkellä ohjelma ei kuitenkaan toimi halutusti. Ota selvää miksi ja korjaa ohjelma. Huomaat myös, että ohjelmassa käytetään paljon omituisia asioita, jotka eivät ole tulleet vielä kurssilla tutuksi. Kannattaakin tehdä niin, että kokeilee myös näitä uusia asioita erikseen.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Yksikkötestaus
<% end %>

<p>
  Edellä esitetty menetelmä automaattiseen testaamiseen missä ohjelmalle syötetyt syötteet muutetaan on varsin kätevä, mutta kuitenkin melko rajoittunut. Isompien ohjelmien testaaminen edellä kuvatulla tavalla on haastavaa. Eräs ratkaisu tähän on yksikkötestaus, missä ohjelman pieniä osia testataan erikseen.
</p>

<p>
  Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien kuten luokkien ja niiden tarjoamien metodien testaamista.  Luokkien ja metodien rakenteen suunnittelussa käytettävän ohjesäännön -- jokaisella metodilla ja luokalla tulee olla yksi selkeä vastuu -- noudattamisen tai siitä poikkeamisen huomaa testejä kirjoittaessa. Mitä useampi vastuu metodilla on, sitä monimutkaisempi testi on. Jos laaja sovellus on kirjoitettu yksittäiseen metodiin, on testien kirjoittaminen sitä varten erittäin haastavaa ellei jopa mahdotonta. Vastaavasti, jos sovellus on pilkottu selkeisiin luokkiin ja metodeihin, on testienkin kirjoittaminen suoraviivaista.
</p>

<p>
  Testien kirjoittamisessa hyödynnetään tyypillisesti valmiita yksikkötestauskirjastoja, jotka tarjoavat metodeja ja apuluokkia testien kirjoittamiseen. Javassa käytetyin yksikkötestauskirjasto on <a href="http://junit.org/" target="_blank" rel="noopener">JUnit</a>, johon löytyy myös tuki lähes kaikista ohjelmointiympäristöistä. Esimerkiksi NetBeans osaa automaattisesti etsiä JUnit-testejä projektista -- jos testejä löytyy, ne näytetään projektin alla Test Packages -kansiossa.
</p>

<p>
  Tarkastellaan yksikkötestien kirjoittamista esimerkin kautta. Oletetaan, että käytössämme on seuraava luokka Laskin, ja haluamme kirjoittaa sitä varten automaattisia testejä.
</p>


<% partial 'partials/code_highlight' do %>
  public class Laskin {

      private int arvo;

      public Laskin() {
          this.arvo = 0;
      }

      public void summa(int luku) {
          this.arvo += luku;
      }

      public void erotus(int luku) {
          this.arvo += luku;
      }

      public int getArvo() {
          return this.arvo;
      }
  }
<% end %>

<p>
  Laskimen toiminta perustuu siihen, että se muistaa aina edellisen laskuoperaation tuottaman tuloksen. Seuraavat laskuoperaatiot lisätään aina edelliseen lopputulokseen. Yllä olevaan laskimeen on jäänyt myös pieni copy-paste -ohjelmoinnista johtuva virhe. Metodin erotus pitäisi vähentää arvosta, mutta nyt se lisää arvoon.
</p>

<p>
  Yksikkötestien kirjoittaminen aloitetaan testiluokan luomisella. Testiluokka luodaan Test Packages -kansion alle. Kun testaamme luokkaa <code>Laskin</code>, testiluokan nimeksi tulee <code>LaskinTest</code>. Nimen lopussa oleva merkkijono <code>Test</code> kertoo ohjelmointiympäristölle, että kyseessä on testiluokka. Ilman merkkijonoa Test luokassa olevia testejä ei suoriteta. (Huom! Testit luodaan NetBeansissa Test Packages -kansion alle.)
</p>

<p>
  Testiluokka LaskinTest on aluksi tyhjä.
</p>


<% partial 'partials/code_highlight' do %>
  public class LaskinTest {

  }
<% end %>

<p>
  Testit ovat testiluokassa olevia metodeja ja jokainen testi testaa yksittäistä asiaa. Aloitetaan luokan Laskin testaaminen -- luodaan ensin testimetodi, jossa varmistetaan, että juuri luodun laskimen sisältämä arvo on 0.
</p>

<% partial 'partials/code_highlight' do %>

  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class LaskinTest {

      @Test
      public void laskimenArvoAlussaNolla() {
          Laskin laskin = new Laskin();
          assertEquals(0, laskin.getArvo());
      }
  }
<% end %>

<p>
  Yllä olevassa metodissa laskimenArvoAlussaNolla luodaan ensin laskinolio. Tämän jälkeen käytetään JUnit-testikehyksen tarjoamaa assertEquals-metodia arvon tarkistamiseen. Metodi tuodaan luokasta Assert komennolla import static, ja sille annetaan parametrina odotettu arvo -- tässä 0 -- sekä laskimen palauttama arvo. Jos metodin assertEquals arvot poikkeavat toisistaan, testin suoritus ei pääty hyväksytysti. Jokaisella testimetodilla tulee olla <em>annotaatio</em> @Test -- tämä kertoo JUnit-testikehykselle, että kyseessä on suoritettava testimetodi.
</p>

<p>
  Testien suorittaminen onnistuu valitsemalla projekti oikealla hiirennapilla ja klikkaamalla vaihtoehtoa Test.
</p>

<p>
  Testien suorittaminen luo output-välilehdelle (tyypillisesti NetBeansin alalaidassa) tulosteen, jossa on testiluokkakohtaiset tilastot. Alla olevassa esimerkissä on suoritettu pakkauksessa laskin olevan testiluokan LaskinTest testit. Testejä suoritettiin 1, joista yksikään ei epäonnistunut -- epäonnistuminen tarkoittaa tässä sitä, että testin testaama toiminnallisuus ei toiminut oletetusti.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.054 sec

  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>

<p>
  Lisätään testiluokkaan summaa ja erotusta lisäävää toiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  package laskin;

  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class LaskinTest {

      @Test
      public void laskimenArvoAlussaNolla() {
          Laskin laskin = new Laskin();
          assertEquals(0, laskin.getArvo());
      }

      @Test
      public void arvoViisiKunSummataanViisi() {
          Laskin laskin = new Laskin();
          laskin.summa(5);
          assertEquals(5, laskin.getArvo());
      }

      @Test
      public void arvoMiinusKaksiKunErotetaanKaksi() {
          Laskin laskin = new Laskin();
          laskin.erotus(2);
          assertEquals(-2, laskin.getArvo());
      }
  }
<% end %>

<p>
  Testien suorittaminen antaa seuraavanlaisen tulostuksen.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 3, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.059 sec

  Testcase: arvoMiinusKaksiKunErotetaanKaksi(LaskinTest):	FAILED
  expected:<-2> but was:<2>
  junit.framework.AssertionFailedError: expected:<-2> but was:<2>
      at LaskinTest.arvoMiinusKaksiKunErotetaanKaksi(LaskinTest.java:25)


  Test LaskinTest FAILED
  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>

<p>
  Tulostus kertoo, että kolme testiä suoritettiin. Yksi niistä päätyi virheeseen. Testitulostuksessa on tieto myös testin rivistä, jossa virhe tapahtui (25) sekä tieto odotetusta (-2) ja saadusta arvosta (2). Kun testien suoritus päättyy virheeseen, NetBeans näyttää testien suoritukseen liitttyvän virhetilanteen myös visuaalisena.
</p>

<p>
  Edellisillä testeillä kaksi testeistä menee läpi, mutta yhdessä on tapahtunut virhe. Korjataan luokkaan Laskin jäänyt virhe.
</p>

<% partial 'partials/code_highlight' do %>
  // ...
  public void erotus(int luku) {
      this.arvo -= luku;
  }
  // ...
<% end %>

<p>
  Kun testit suoritetaan uudestaan, testit menevät läpi.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.056 sec

  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>


<% partial 'partials/exercise', locals: { name: 'Laskimen testailua' } do %>

  <p>
    Tehtäväpohjassa tulee edellisen esimerkin alkutilanne. Seuraa edellistä esimerkkiä, ja luo laskimelle esimerkissä näytetyt testit. Kokeile testien toimintaa, ja palauta lopulta tehtävä Test My Code-palvelimelle.
  </p>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Breakout' } do %>

  <p>
    <a href="https://en.wikipedia.org/wiki/Breakout_(video_game)" target="_blank" rel="noopener">Breakout</a> on <a href="https://en.wikipedia.org/wiki/Atari,_Inc." target="_blank" rel="noopener">Atarin</a> vuonna 1976 julkaisema videopeli. Pelin ideana käyttää pelin alalaidassa olevaa mailaa pelissä liikkuvan pallon lyömiseen siten, että pallolla saadaan rikottua ylälaidassa olevia palasia.
  </p>

  <p>
    Termi "Breakout" tulee tilanteesta, missä pelaaja saa pallon ylälaidassa olevien palasten yläpuolelle, missä pallo tekee tuhoa useammalle palalle samaan aikaan.
  </p>

  <p>
    Tässä tehtävässä fiilistellään Breakout-pelin tekemistä.
  </p>

  <p>
    Tehtäväpohjaan on toteutettuna ensimmäisiä palasia Breakout peliin. Tehtävänäsi on täydentää pelin toimintaa. Alla lista täydennysehdotuksista:
  </p>

  <ol>
    <li>Tällä hetkellä pelin ylälaidassa on vain muutama vaivainen palikka. Muokkaa peliä siten, että ylälaidassa on useita erivärisiä palikoita. Hae inspiraatiota <a href="https://images.google.com" target="_blank" rel="noopener">Googlen kuvahausta</a> avainsanalla "Breakout".</li>
    <li>Pelin pelattavuus on tällä hetkellä melko heikko. Mailalla ei osuta palloon, vaikka kuinka yritettäisiin. Lisää peliin mahdollisuus osua mailalla palloon -- palloon osumisen pitäisi muuttaa pallon suuntaa. Osoitteesta <a href="http://www.edu4java.com/en/game/game6.html" target="_blank" rel="noopener">http://www.edu4java.com/en/game/game6.html</a> olevasta oppaasta saattaa olla hyötyä. Hifistelyä kaipaavat voivat lähteä liikenteeseen kysymyksestä <a href="http://gamedev.stackexchange.com/questions/10911/a-ball-hits-the-corner-where-will-it-deflect" target="_blank" rel="noopener">A ball hits the corner, where will it deflect?</a></li>
    <li>Kun pallon osuminen mailaan on hanskassa, lisää samanlainen osumistoiminnallisuus kaikkiin paloihin. Tässä kohtaa paloja ei vielä tarvitse poistaa.</li>
    <li>Kun pallo osuu palaan, pala pitäisi poistaa. Sehän on melkein jo peli!</li>
    <li>Mieti minkälaisia luokkia pelissä kannattaisi olla. Nyt piirtämiseen käytetty paikka sisältää varmaankin jo hyvin paljon koodia.. Siistimisen paikka!</li>
  </ol>

  <p>
    Tehtävässä ei ole automaattisia testejä ja se on yhden pisteen arvoinen. Voit palauttaa tehtävän jo kun saat ensimmäisen parannusehdotuksen tehtyä mutta peliä saa toki viilata enemmänkin.
  </p>

<% end %>


<%= partial 'partials/quiz', locals: { id: '59d2acc145370b000408077c' } %>
