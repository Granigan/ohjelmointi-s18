---
  title: Osa 9
  exercise_page: true
  quiz_page: true
  published: true
---


<% partial 'partials/hint', locals: { name: 'Yhdeksännen osan tavoitteet' } do %>
  
  <p>
    Tuntee luokkaakaavioiden merkintätavan ja luo luokkia luokkakaavioiden perusteella. Tuntee Javan erityyppiset poikkeukset ja luo ohjelmia, jotka varautuvat poikkeuksiin. Tuntee menetelmiä listojen järjestämiseen ja järjestetyistä listoista hakemiseen. Tuntee rajapinnan Comparable ja hyödyntää sitä olioiden järjestämisessä. Tuntee käsitteen perintähierarkia ja kertaa arvojen ryhmittelyä hajautustaulun avulla.
  </p>
    
<% end %>

<% partial 'partials/hint', locals: { name: 'Konekokeesta' } do %>
  
  <p>
    Lisätietoa ohjelmoinnin jatkokurssin ensimmäisestä konekokeesta muutaman päivän sisällä..
  </p>
  
<% end %>


<% partial 'partials/material_heading' do %>
  Luokkakaaviot
<% end %>

<p>
  Luokkakaavio on ohjelmistojen mallinnuksessa käytettävä kaaviotyyppi, jonka avulla kuvataan olio-ohjelmoinnin luokkia. Luokkaaviossa kuvattavat luokat vastaavat ohjelmakoodin luokkia. Kaavioissa kuvataan luokkien nimet, attribuutit, luokkien väliset yhteydet sekä mahdollisesti myös metodit.
</p>

<% partial 'partials/material_sub_heading' do %>
  Luokka ja attribuutit
<% end %>

<p>
  Luodaan luokka nimeltä <code>Henkilo</code>, jolla on oliomuuttujat nimi ja ikä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;
  }
<% end %>

<p>
  Yllä kuvattua luokkaa kuvaa seuraava luokkakaavio. Luokkakaavioissa luokka kuvataan suorakulmiona, jonka ylälaidassa on luokan nimi, ja keskellä on oliomuuttujien nimet ja tyypit. 
</p>

<p>
  Luokkaakaaviossa luokkaan liittyvät muuttujat määritellään muodossa "muuttujanNimi: muuttujanTyyppi". Miinusmerkki ennen muuttujan nimeä kertoo, että muuttujalla on avainsana private.
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi.png" alt="[Henkilo|-nimi:String;-ika:int]">
</p>

<p>
  Olemme nyt määritelleet rakennuspiirustukset -- luokan -- henkilöoliolle. Jokaisella uudella henkilöolioilla on muuttujat <code>nimi</code> ja <code>ika</code>, joissa voi olla oliokohtainen arvo. Henkilöiden "tila" koostuu niiden nimeen ja ikään asetetuista arvoista.
</p>

<p>
  Määrittellään seuraavaksi luokalle konstruktori, joka saa parametrina nimen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;

      public Henkilo(String nimi) {
          this.nimi = nimiAlussa;
          this.ika = 0;
      }
  }
<% end %>

<p>
  Luokkakaaviossa konstruktori (ja metodit) merkitään oliomuuttujien alapuolelle. Konstruktori saa näkyvyysmääreen public takia eteen plussan, jonka lisäksi siitä merkitään nimi sekä parametrien nimet ja niiden tyypit (tässä <code>+ Henkilo(nimi: String)</code>).
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(nimi:String)]">
</p>

<p>
  Lisätään luokalle metodi, jonka palautustyyppi on void.
</p>


<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;

      public Henkilo(String nimi) {
          this.nimi = nimi;
          this.ika = 0;
      }

      public void tulostaHenkilo() {
          System.out.println(this.nimi + ", ikä " + this.ika + " vuotta");
      }
  }
<% end %>

<p>
  Luokkakaaviossa metodi merkitään kuten konstruktori, mutta tämän lisäksi metodista kirjoitetaan myös sen palautustyyppi.
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori-ja-tulosta.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(nimi:String);+tulostaHenkilo():void]">
</p>

<p>
  Metodi <code>tulostaHenkilo</code> hyödyntää oliomuuttujia <code>nimi</code> ja <code>ika</code>, mutta luokkakaaviossa tätä ei kerrota. Tarkemmin katsoen huomaamme, että luokkakaavio ei kerro mitään konstruktorien ja metodien sisäisestä toteutuksesta. Luokkakaaviolla kerrotaan siis olioiden rakenteesta, mutta luokkakaaviot eivät itsessään määrittele toiminnallisuutta.
</p>

<p>
  Lisätään luokalle vielä nimen palauttava metodi <code>getNimi</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;

      public Henkilo(String nimi) {
          this.nimi = nimi;
          this.ika = 0;
      }

      public void tulostaHenkilo() {
          System.out.println(this.nimi + ", ikä " + this.ika + " vuotta");
      }

      public String getNimi() {
          return this.nimi;
      }
  }
<% end %>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori-ja-tulosta-ja-getnimi.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(nimi:String);+tulostaHenkilo():void;+getNimi():String]">
</p>


<% partial 'partials/material_sub_heading' do %>
  Yhteyksien merkintä luokkakaavioon
<% end %>

<p>
  Luokkakaavioissa yhteydet merkitään viivoilla, joissa nuolet kuvaavat yhteyden suuntaa. Oletetaan, että käytössämme luokka Kirja.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private String nimi;
      private String kustantaja;

      // konstruktorit ja metodit
  }
<% end %>


<p>
  <img src="/img/diagrams/luokkakaavio-kirja-nimi-ja-kustantaja.png" alt="[Kirja|-nimi:String;-julkaisija:String]">
</p>



<p>
  Jos luokalle kirja merkitään kirjoittaja, joka on tyyppiä Henkilö, ohjelmakoodissa oliomuuttuja merkitänä muiden muuttujien seuraksi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private String nimi;
      private String kustantaja;
      private Henkilo kirjoittaja;

      // konstruktorit ja metodit
  }
<% end %>

<p>
  Luokkakaaviossa toisiin olioihin viittaavia muuttujia ei merkitä attribuutteihin, vaan ne merkitään yhteyksinä. Alla olevassa luokkakaaviossa on merkittynä sekä luokka Henkilo että luokka Kirja, sekä näiden välinen yhteys. Yhteys kertoo, että se luotu kirjan suunnasta (nuoli henkilöön) ja että yhteys kertoo kirjoittajasta (nuolen teksti "kirjoittaja").
</p>


<p>
  <img src="/img/diagrams/luokkakaavio-kirja-nimi-ja-kustantaja-ja-kirjoittaja.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(nimi:String);+tulostaHenkilo():void;+getNimi():String]
											 [Kirja|-nimi:String;-julkaisija:String]
											 [Kirja]-kirjoittaja->[Henkilo]">
</p>

<p>
  Jos kirjalla voi olla useita kirjoittajia, kirjoittajat merkitään luokkaan listana.
</p>


<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private String nimi;
      private String kustantaja;
      private ArrayList&lt;Henkilo&gt; kirjoittajat;

      // konstruktorit ja metodit
  }
<% end %>


<p>
  Luokkakaaviossa tilanne merkitään yhteyden päätyyn asetettavalla tähdellä. Tähti kertoo, että kirjalla voi olla nollasta äärettömään kirjoittajaa. Alla olevassa esimerkissä yhteyteen ei ole merkitty yhteyttä kuvaavaa tekstiä "kirjoittajat", mutta se kannattaisi lisätä kaavioon.
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-kirja-nimi-ja-kustantaja-ja-kirjoittajat.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(nimi:String);+tulostaHenkilo():void;+getNimi():String]
											  [Kirja|-nimi:String;-julkaisija:String]
											  [Kirja]-*>[Henkilo]">
</p>

<p>
  Metodit merkitään luokkakaavioon normaalisti. Alla luokkaan Kirja on lisätty metodit <code>getKirjoittajat</code> ja <code>lisaaKirjoittaja</code>.
</p>


<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private String nimi;
      private String kustantaja;
      private ArrayList&lt;Henkilo&gt; kirjoittajat;

      // konstruktori

      public ArrayList&lt;Henkilo&gt; getKirjoittajat() {
          return this.kirjoittajat;
      }

      public void lisaaKirjoittaja(Henkilo kirjoittaja) {
          this.kirjoittajat.add(kirjoittaja);
      }
  }
<% end %>


<p>
  <img src="/img/diagrams/luokkakaavio-kirja-nimi-ja-kustantaja-ja-kirjoittajat-ja-metodit.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(nimi:String);+tulostaHenkilo():void;+getNimi():String]
												     [Kirja|-nimi:String;-julkaisija:String|+getKirjoittajat():ArrayList;+lisaaKirjoittaja(kirjoittaja:Henkilo)]
												     [Kirja]-*>[Henkilo]">
</p>

<p>
  Ylläolevaan kaavioon voisi lisätä vielä ArrayListin sisältämien arvojen tyypin <code>ArrayList&lt;Henkilo&gt;</code> sekä yhteyttä tarkentavan määreen "kirjoittajat".
</p>


<% partial 'partials/material_sub_heading' do %>
  Rajapinnat luokkakaaviossa
<% end %>

<p>
  Rajapinnat merkitään luokkakaavioissa muodossa &lt;&lt;interface&gt;&gt; RajapintaLuokanNimi. Tarkastellaan esimerkkinä rajapintaa Luettava.
</p>

<% partial 'partials/code_highlight' do %>
  public interface Luettava {

  }
<% end %>

<p>
  <img src="/img/diagrams/luokkakaavio-rajapinta-luettava.png" alt="[&lt;&lt;interface&gt;&gt; Luettava]">
</p>

<p>
  Metodit voidaan merkitä alle kuten luokkakaavioissa.
</p>

<p>
  Rajapinnan toteuttaminen merkitään katkoviivalla ja kolmiolla. Alla on kuvattu tilanne, missä luokka Kirja toteuttaa rajapinnan Luettava.
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-kirja-toteuttaa-luettavan.png" alt="[<<interface>> Luettava]
									   [Kirja]-.-^[<<interface>> Luettava]">
</p>



<% partial 'partials/material_sub_heading' do %>
  Laajempi esimerkki: Maatilasimulaattori
<% end %>

<p>
  Eräs edellisen osan ohjelmointitehtävä oli maatilasimulaattori. Maatilalla on lehmiä, jotka ovat eleleviä ja lypsäviä. Navetassa on lypsyrobotti ja maitosäiliö. Maatilalla on navetta ja lehmiä. Tämän lisäksi myös Maatila on elelevä. Eräs mahdollinen tehtävän loppuratkaisua kuvaava luokkakaavio on seuraavanlainen.
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-maatilasimulaattori.png" alt="[Maitosailio|-tilavuus:double;-saldo:double]
	    [Lehma]
	    [&lt;&lt;interface&gt;&gt; Eleleva]
            [&lt;&lt;interface&gt;&gt; Lypsava]
	    [Lypsyrobotti]
	    [Maatila|-omistaja:String]
	    [Navetta]
	    [Navetta]-&gt;[Maitosailio]
	    [Navetta]-&gt;[Lypsyrobotti]
	    [Maatila]-&gt;[Navetta]
	    [Maatila]-&gt;*[Lehma]
	    [Maatila]-.-^[&lt;&lt;interface&gt;&gt; Eleleva]
	    [Lehma]-.-^[&lt;&lt;interface&gt;&gt; Eleleva]
	    [Lehma]-.-^[&lt;&lt;interface&gt;&gt; Lypsava]">
</p>


<% partial 'partials/hint', locals: { name: 'Luokkakaavioiden käytöstä' } do %>

  <p>
    Luokkakaavioita kannattaa käyttää laajempien tehtävien (ja ongelmien) käsitteiden sekä niiden yhteyksien hahmottamisessa. Kurssin tehtäviä tehdessä hyvä lähtökohta on piirtää luokat ja niiden yhteydet ilman oliomuuttujia tai metodeja.
  </p>
  
<% end %>


<% partial 'partials/material_heading' do %>
  Poikkeukset
<% end %>

<p>
  Poikkeukset ovat tilanteita, joissa ohjelman suoritus päättyy virheeseen. Ohjelmassa on esimerkiksi kutsuttu <em>null</em>-viitteeseen liittyvää metodia, jolloin ohjelmassa tapahtuu poikkeus <code>NullPointerException</code>. Vastaavasti taulukon ulkopuolella olevan indeksin hakeminen johtaa poikkeukseen <code>IndexOutOfBoundsException</code> ym.
</p>

<p>
  Osa Javassa esiintyvistä poikkeuksista on sellaisia, että niihin tulee aina varautua. Näitä ovat esimerkiksi tiedoston lukemisessa tapahtuvaan virheeseen tai verkkoyhteyden katkeamiseen liittyvät poikkeukset. Osa poikkeuksista taas on ajonaikaisia poikkeuksia -- kuten vaikkapa NullPointerException --, joihin ei erikseen tarvitse varautua. Java ilmoittaa aina jos ohjelmassa on lause tai lauseke, jossa mahdollisesti tapahtuvaan poikkeukseen tulee varautua.
</p>


<% partial 'partials/material_sub_heading' do %>
  Poikkeusten käsittely
<% end %>

<p>
  Poikkeukset käsitellään <code>try { } catch (Exception e) { }</code> -lohkorakenteella. Avainsanan <code>try</code> aloittaman lohkon sisällä on lähdekoodi, jonka suorituksessa tapahtuu <em>mahdollisesti</em> poikkeus. Avainsanan <code>catch</code> aloittaman lohkon sisällä taas määritellään poikkeustilanteessa tapahtuva käsittely, eli mitä tehdään kun try-lohkossa tapahtuu poikkeus. Avainsanaa catch seuraa myös käsiteltävän poikkeuksen tyyppi, esimerkiksi "kaikki poikkeukset" eli Exception (<code>catch (Exception e)</code>).
</p>

<% partial 'partials/code_highlight' do %>
try {
    // poikkeuksen mahdollisesti heittävä ohjelmakoodi
} catch (Exception e) {
    // lohko johon päädytään poikkeustilanteessa
}
<% end %>

<p>
  Avainsana <code>catch</code> eli <em>ota kiinni</em> tulee siitä, että poikkeukset <em>heitetään</em> (<code>throw</code>).</p>
</p>

<p>
  Kuten edellä todettiin, ajonaikaisiin poikkeuksiin kuten NullPointerException ei tarvitse erikseen varautua. Tällaiset poikkeukset voidaan jättää käsittelemättä, jolloin ohjelman suoritus päättyy virheeseen poikkeustilanteen tapahtuessa. Tarkastellaan erästä poikkeustilannetta nyt jo tutun merkkijonon kokonaisluvuksi muuntamisen kautta.
</p>

<p>
  Olemme käyttäneet luokan <code>Integer</code> metodia <code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#parseInt-java.lang.String-" target="_blank" rel="noopener">parseInt</a></code> merkkijonon kokonaisluvuksi muuntamiseen. Metodi heittää poikkeuksen <code>NumberFormatException</code>, jos sille parametrina annettu merkkijono ei ole muunnettavissa kokonaisluvuksi.
</p>

<% partial 'partials/code_highlight' do %>
Scanner lukija = new Scanner(System.in);
System.out.print("Syötä numero: ");

int numero = Integer.parseInt(lukija.nextLine());
<% end %>

<% partial 'partials/sample_output' do %>
Syötä numero: <font color="red">tatti</font>
  <font color="red">Exception in thread "..." java.lang.NumberFormatException: For input string: "tatti"</font>
<% end %>

<p>
  Yllä ohjelma heittää poikkeuksen, kun käyttäjä syöttää virheellisen numeron. Ohjelman suoritus päättyy tällöin virhetilanteeseen.
</p>

<p>
  Lisätään esimerkkiin poikkeuksen käsittely. Kutsu, joka saattaa heittää poikkeuksen asetetaan <code>try</code>-lohkon sisään, ja virhetilanteessa tapahtuva toiminta <code>catch</code>-lohkon sisään.
</p>

<% partial 'partials/code_highlight' do %>
Scanner lukija = new Scanner(System.in);

System.out.print("Syötä numero: ");
int numero = -1;

try {
    numero = Integer.parseInt(lukija.nextLine());
} catch (Exception e) {
    System.out.println("Et syöttänyt kunnollista numeroa.");
}
<% end %>

<% partial 'partials/sample_output' do %>
Syötä numero: <font color="red">5</font>
<% end %>

<% partial 'partials/sample_output' do %>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
<% end %>

<p>
  Avainsanan <code>try</code> määrittelemän lohkon sisältä siirrytään <code>catch</code>-lohkoon heti poikkeuksen tapahtuessa. Havainnollistetaan tätä lisäämällä tulostuslause <code>try</code>-lohkossa metodia <code>Integer.parseInt</code> kutsuvan rivin jälkeen.
</p>

<% partial 'partials/code_highlight' do %>
Scanner lukija = new Scanner(System.in);

System.out.print("Syötä numero: ");
int numero = -1;

try {
    numero = Integer.parseInt(lukija.nextLine());
    System.out.println("Hienosti syötetty!");
} catch (Exception e) {
    System.out.println("Et syöttänyt kunnollista numeroa.");
}
<% end %>

<% partial 'partials/sample_output' do %>
Syötä numero: <font color="red">5</font>
Hienosti syötetty!
<% end %>

<% partial 'partials/sample_output' do %>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
<% end %>

<p>
  Ohjelmalle syötetty merkkijono <code>enpäs!</code> annetaan parametrina <code>Integer.parseInt</code>-metodille, joka heittää poikkeuksen, jos parametrina saadun merkkijonon muuntaminen luvuksi epäonnistuu. Huomaa, että <code>catch</code>-lohkossa oleva koodi suoritetaan <em>vain</em> poikkeustapauksissa.
</p>

<p>
  Tehdään yllä olevasta luvun muuntajasta hieman hyödyllisempi. Tehdään siitä metodi, joka kysyy numeroa yhä uudestaan, kunnes käyttäjä syöttää oikean numeron. Metodin suoritus loppuu vasta silloin, kun käyttäjä syöttää kokonaisluvun.
</p>

<% partial 'partials/code_highlight' do %>
public int lueLuku(Scanner lukija) {
    while (true) {
        System.out.print("Syötä numero: ");

        try {
            int numero = Integer.parseInt(lukija.nextLine());
            return numero;
        } catch (Exception e) {
            System.out.println("Et syöttänyt kunnollista numeroa.");
        }
    }
}
<% end %>

<% partial 'partials/sample_output' do %>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">Matilla on ovessa tatti.</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">43</font>
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Käsittelyvastuun siirtäminen
<% end %>

<p>
  Metodit ja konstruktorit voivat <em>heittää</em> poikkeuksia. Heitettäviä poikkeuksia on karkeasti ottaen kahdenlaisia. On poikkeuksia jotka on pakko käsitellä, ja on poikkeuksia joita ei ole pakko käsitellä. Poikkeukset käsitellään joko <code>try-catch</code> -lohkossa, tai <em>heittämällä ne ulos metodista</em>.
</p>

<p>
  Alla olevassa esimerkissä luetaan parametrina annetun tiedoston rivit yksitellen. Tiedoston lukeminen saattaa heittää poikkeuksen -- voi olla, ettei tiedostoa esimerkiksi löydy, tai voi olla ettei siihen ole lukuoikeuksia. Tällainen poikkeus tulee käsitellä. Poikkeuksen käsittely tapahtuu  <code>try-catch</code> -lauseella. Seuraavassa esimerkissä emme juurikaan välitä poikkeustilanteesta, mutta tulostamme kuitenkin poikkeukseen liittyvän viestin.
</p>

<% partial 'partials/code_highlight' do %>
public List&lt;String&gt; lue(String tiedosto) {
    List&lt;String&gt; rivit = new ArrayList&lt;&gt;();

    try {
        Files.lines(Paths.get("tiedosto.txt")).forEach(rivi -&gt; rivit.add(rivi));
    } catch (Exception e) {
        System.out.println("Virhe: " + e.getMessage());
    }

    return rivit;
}
<% end %>

<p>
  Ohjelmoija voi myös jättää poikkeuksen käsittelemättä ja <em>siirtää vastuun</em> poikkeuksen käsittelystä metodin kutsujalle. Vastuun siirto tapahtuu heittämällä poikkeus metodista eteenpäin lisäämällä tästä tieto metodin määrittelyyn. Tieto poikkeuksen heitosta -- <code>throws <em>PoikkeusTyyppi</em></code>, missä poikkeustyyppi esimerkiksi Exception -- lisätään ennen metodirungon avaavaa aaltosulkua.
</p>

<% partial 'partials/code_highlight' do %>
public List&lt;String&gt; lue(String tiedosto) <strong>throws Exception</strong> {
    ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();
    Files.lines(Paths.get(tiedosto)).forEach(rivi -&gt; rivit.add(rivi));
    return rivit;
}
<% end %>

<p>
  Nyt metodia <code>lue</code> kutsuvan metodin tulee joko käsitellä poikkeus <code>try-catch</code> -lohkossa tai siirtää poikkeuksen käsittelyn vastuuta eteenpäin. Joskus poikkeuksen käsittelyä vältetään viimeiseen asti, ja <code>main</code>-metodikin heittää poikkeuksen käsiteltäväksi eteenpäin:
</p>

<% partial 'partials/code_highlight' do %>
public class Paaohjelma {
   public static void main(String[] args) throws Exception {
       // ...
   }
}
<% end %>

<p>
  Tällöin mahdollinen poikkeus päätyy ohjelman suorittajalle eli Javan virtuaalikoneelle, joka keskeyttää ohjelman suorituksen poikkeukseen johtavan virheen tapahtuessa.
</p>



<% partial 'partials/material_sub_heading' do %>
  Poikkeusten heittäminen
<% end %>

<p>
  Voimme heittää poikkeuksen <code>throw</code>-komennolla. Esimerkiksi <code>NumberFormatException</code>-luokasta luodun poikkeuksen heittäminen tapahtuisi komennolla <code>throw new NumberFormatException()</code>. Seuraava ohjelma päätyy aina poikkeustilaan.
</p>

<% partial 'partials/code_highlight' do %>
public class Ohjelma {

    public static void main(String[] args) throws Exception {
        throw new NumberFormatException(); // Ohjelmassa heitetään poikkeus
    }
}
<% end %>

<p>
  Eräs poikkeus, johon käyttäjän ei ole pakko varautua on <code>IllegalArgumentException</code>. Poikkeuksella <code>IllegalArgumentException</code> kerrotaan että metodille tai konstruktorille annettujen parametrien arvot ovat <em>vääränlaiset</em>. IllegalArgumentException-poikkeusta käytetään esimerkiksi silloin, kun halutaan varmistaa, että parametreilla on tietyt arvot.
</p>

<p>
  Luodaan luokka <code>Arvosana</code>, joka saa konstruktorin parametrina kokonaislukutyyppisen arvosanan.
</p>

<% partial 'partials/code_highlight' do %>
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}<% end %>

<p>
  Haluamme seuraavaksi varmistaa, että Arvosana-luokan konstruktorin parametrina saatu arvo täyttää tietyt kriteerit. Arvosanan tulee olla aina välillä 0-5. Jos arvosana on jotain muuta, haluamme <em>heittää poikkeuksen</em>. Lisätään <code>Arvosana</code>-luokan konstruktoriin ehtolause, joka tarkistaa onko arvosana arvovälin 0-5 ulkopuolella. Jos on, heitetään poikkeus <code>IllegalArgumentException</code> sanomalla <code>throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");</code>.
</p>

<% partial 'partials/code_highlight' do %>
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        if (arvosana &lt; 0 || arvosana &gt; 5) {
            throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");
        }

        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
<% end %>

<% partial 'partials/code_highlight' do %>
Arvosana arvosana = new Arvosana(3);
System.out.println(arvosana.getArvosana());

Arvosana virheellinenArvo = new Arvosana(22);
// tapahtuu poikkeus, tästä ei jatketa eteenpäin
<% end %>

<% partial 'partials/sample_output' do %>
3
Exception in thread "..." java.lang.IllegalArgumentException: Arvosanan tulee olla välillä 0-5
<% end %>

<p>
  Jos poikkeus on esimerkiksi tyyppiä IllegalArgumentException, tai yleisemmin ajonaikainen poikkeus, ei sen heittämisestä tarvitse kirjoittaa erikseen metodin määrittelyyn.
</p>


<% partial 'partials/exercise', locals: { name: 'Parametrien validointi (2 osaa)' } do %>

  <p>
    Harjoitellaan hieman parametrien validointia <code>IllegalArgumentException</code>-poikkeuksen avulla. Tehtäväpohjassa tulee kaksi luokkaa, <code>Henkilo</code> ja <code>Laskin</code>. Muuta luokkia seuraavasti:
  </p>

  
  <h2>Henkilön validointi</h2>

  <p>
    Luokan <code>Henkilo</code> konstruktorin tulee varmistaa että parametrina annettu nimi ei ole null, tyhjä tai yli 40 merkkiä pitkä. Myös iän tulee olla väliltä 0-120. Jos joku edelläolevista ehdoista ei päde, tulee konstruktorin heittää <code>IllegalArgumentException</code>-poikkeus.
  </p>


  <h2>Laskimen validointi</h2>

  <p>
    Luokan <code>Laskin</code> metodeja tulee muuttaa seuraavasti: Metodin <code>kertoma</code> tulee toimia vain jos parametrina annetaan ei-negatiivinen luku (0 tai suurempi). Metodin <code>binomikerroin</code> tulee toimia vain jos parametrit ovat ei-negatiivisia ja osajoukon koko on pienempi kuin joukon koko. Jos jompikumpi metodeista saa epäkelpoja arvoja metodikutsujen yhteydessä, tulee metodien heittää poikkeus <code>IllegalArgumentException</code>.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Poikkeukset ja rajapinnat
<% end %>

<p>
  Rajapintaluokilla ei ole metodirunkoa, mutta metodimäärittely on vapaasti rajapinnan suunnittelijan toteutettavissa. Rajapintaluokissa voidaan määritellä metodeja, jotka saattavat heittää poikkeuksen. Esimerkiksi seuraavan rajapinnan <code>Tiedostopalvelin</code> toteuttavat luokat heittävät <em>mahdollisesti</em> poikkeuksen <code>lataa</code>- ja <code>tallenna</code>-metodissa.
</p>

<% partial 'partials/code_highlight' do %>
public interface Tiedostopalvelin {
    String lataa(String tiedosto) throws Exception;
    void tallenna(String tiedosto, String merkkijono) throws Exception;
}
<% end %>

<p>
  Jos rajapinta määrittelee metodeille <code>throws Exception</code>-määreet, eli että metodit heittävät mahdollisesti poikkeuksen, tulee samat määreet olla myös rajapinnan toteuttavassa luokassa. Luokan ei kuitenkaan ole pakko heittää poikkeusta kuten alla olevasta esimerkistä näkee.
</p>

<% partial 'partials/code_highlight' do %>
public class Tekstipalvelin implements Tiedostopalvelin {

    private Map&lt;String, String&gt; data;

    public Tekstipalvelin() {
        this.data = new HashMap&lt;&gt;();
    }

    @Override
    public String lataa(String tiedosto) throws Exception {
        return this.data.get(tiedosto);
    }

    @Override
    public void tallenna(String tiedosto, String merkkijono) throws Exception {
        this.data.put(tiedosto, merkkijono);
    }
}
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Poikkeuksen tiedot
<% end %>

<p>
  Poikkeusten käsittelytoiminnallisuuden sisältämä <code>catch</code>-lohko määrittelee catch-osion sisällä poikkeuksen johon varaudutaan <code>catch (<em>Exception e</em>)</code>. Poikkeuksen tiedot tallennetaan <code>e</code>-muuttujaan.
</p>

<% partial 'partials/code_highlight' do %>
try {
    // ohjelmakoodi, joka saattaa heittää poikkeuksen
} catch (Exception e) {
    // poikkeuksen tiedot ovat tallessa muuttujassa e
}
<% end %>

<p>
  Luokka <code>Exception</code> tarjoaa hyödyllisiä metodeja. Esimerkiksi metodi <code>printStackTrace()</code> tulostaa <em>stack tracen</em>, joka kertoo miten poikkeukseen päädyttiin. Tutkitaan seuraavaa metodin <code>printStackTrace()</code> tulostamaa virhettä.
</p>

<% partial 'partials/sample_output' do %>
Exception in thread "main" java.lang.NullPointerException
  at pakkaus.Luokka.tulosta(Luokka.java:43)
  at pakkaus.Luokka.main(Luokka.java:29)
<% end %>

<p>
  Stack tracen lukeminen tapahtuu alhaalta ylöspäin. Alimpana on ensimmäinen kutsu, eli ohjelman suoritus on alkanut luokan <code>Luokka</code> metodista <code>main()</code>. Luokan <code>Luokka</code> main-metodin rivillä 29 on kutsuttu metodia <code>tulosta()</code>. Metodin <code>tulosta</code> rivillä 43 on tapahtunut poikkeus <code>NullPointerException</code>. Poikkeuksen tiedot ovatkin hyvin hyödyllisiä virhekohdan selvittämisessä.
</p>


<% partial 'partials/exercise', locals: { name: 'Sensorit ja lämpötila (4 osaa)' } do %>


  <p>
    Kaikki luotavat luokat tulee sijoittaa pakkaukseen <code>sovellus</code>.
  </p>

  <p>
    Käytössämme on seuraava rajapinta:
  </p>

  <% partial 'partials/code_highlight' do %>
public interface Sensori {
    boolean onPaalla();  // palauttaa true jos sensori on päällä
    void paalle();       // käynnistä sensorin
    void poisPaalta();   // sulkee sensorin
    int mittaa();        // palauttaa sensorin lukeman jos sensori on päällä
                         // jos sensori ei ole päällä heittää poikkeuksen
                         // IllegalStateException
}
  <% end %>


  <h2>Vakiosensori</h2>

  <p>
    Tee luokka <code>Vakiosensori</code> joka toteuttaa rajapinnan <code>Sensori</code>.
  </p>

  <p>
    Vakiosensori on koko ajan päällä. Metodien paalle ja poisPaalta kutsuminen ei tee mitään. Vakiosensorilla tulee olla konstruktori, jonka parametrina on kokonaisluku. Metodikutsu <code>mittaa</code> palauttaa aina konstruktorille parametrina annetun luvun.
  </p>

  <p>Esimerkki:</p>

  <% partial 'partials/code_highlight' do %>
public static void main(String[] args) {
    Vakiosensori kymppi = new Vakiosensori(10);
    Vakiosensori miinusViis = new Vakiosensori(-5);

    System.out.println(kymppi.mittaa());
    System.out.println(miinusViis.mittaa());

    System.out.println(kymppi.onPaalla());
    kymppi.poisPaalta();
    System.out.println(kymppi.onPaalla());
}
  <% end %>

  <% partial 'partials/sample_output' do %>
10
-5
true
true
  <% end %>


  <h2>Lampomittari</h2>

  <p>
    Tee luokka <code>Lampomittari</code>, joka toteuttaa rajapinnan <code>Sensori</code>.
  </p>

  <p>
    Aluksi lämpömittari on poissa päältä. Kutsuttaessa metodia <code>mittaa</code> kun mittari on päällä mittari arpoo luvun väliltä -30...30 ja palauttaa sen kutsujalle. Jos mittari ei ole päällä, heitetään poikkeus <code>IllegalStateException</code>.
  </p>

  <p>
    Käytä Javan valmista luokkaa <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html" target="_blank" rel="noopener">Random</a> satunnaisen luvun arpomiseen. Saat luvun väliltä 0...60 kutsulla <code>new Random().nextInt(61);</code> -- väliltä -30...30 arvotun luvun saa vähentämällä väliltä 0...60 olevasta luvusta sopiva luku.
  </p>


  <h2>Keskiarvosensori</h2>

  <p>
    Tee luokka <code>Keskiarvosensori</code>, joka toteuttaa rajapinnan <code>Sensori</code>.
  </p>

  <p>
    Keskiarvosensori sisältää useita sensoreita. Rajapinnan <code>Sensori</code> määrittelemien metodien lisäksi keskiarvosensorilla on metodi <code>public void lisaaSensori(Sensori lisattava)</code> jonka avulla keskiarvosensorin hallintaan lisätään uusi sensori.
  </p>

  <p>
    Keskiarvosensori on päällä silloin kuin <em>kaikki</em> sen sisältävät sensorit ovat päällä. Kun keskiarvosensori käynnistetään, täytyy kaikkien sen sisältävien sensorien käynnistyä jos ne eivät ole käynnissä. Kun keskiarvosensori suljetaan, täytyy ainakin yhden sen sisältävän sensorin mennä pois päältä. Saa myös käydä niin että kaikki sen sisältävät sensorit menevät pois päältä.
  </p>

  <p>
    Keskiarvosensorin metodi <code>mittaa</code> palauttaa sen sisältämien sensoreiden lukemien keskiarvon (koska paluuarvo on <code>int</code>, pyöristyy lukema alaspäin kuten kokonaisluvuilla tehdyissä jakolaskuissa). Jos keskiarvosensorin metodia <code>mittaa</code> kutsutaan sensorin ollessa poissa päältä, tai jos keskiarvosensorille ei vielä ole lisätty yhtään sensoria heitetään poikkeus <code>IllegalStateException</code>.
  </p>

  <p>
    Seuraavassa sensoreja käyttävä esimerkkiohjelma (huomaa, että sekä Lämpömittarin että Keskiarvosensorin konstruktorit ovat parametrittomia):
  </p>

  <% partial 'partials/code_highlight' do %>
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();
    kumpula.paalle();
    System.out.println("lämpötila Kumpulassa " + kumpula.mittaa() + " astetta");

    Sensori kaisaniemi = new Lampomittari();
    Sensori helsinkiVantaa = new Lampomittari();

    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);

    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");
}
  <% end %>

  <p>
    Alla olevan esimerkin tulostukset riippuvat arvotuista lämpötiloista:
  </p>

  <% partial 'partials/code_highlight' do %>
lämpötila Kumpulassa 11 astetta
lämpötila Pääkaupunkiseudulla 8 astetta
  <% end %>


  <h2>Kaikki mittaukset</h2>

  <p>
    Lisää luokalle Keskiarvosensori metodi <code>public List&lt;Integer&gt; mittaukset()</code>, joka palauttaa listana kaikkien keskiarvosensorin avulla suoritettujen mittausten tulokset. Seuraavassa esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();
    Sensori kaisaniemi = new Lampomittari();
    Sensori helsinkiVantaa = new Lampomittari();

    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);

    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");

    System.out.println("mittaukset: "+paakaupunki.mittaukset());
}
  <% end %>

  <p>
    Alla olevan esimerkin tulostukset riippuvat jälleen arvotuista lämpötiloista:
  </p>

  <% partial 'partials/code_highlight' do %>
lämpötila Pääkaupunkiseudulla -10 astetta
lämpötila Pääkaupunkiseudulla -4 astetta
lämpötila Pääkaupunkiseudulla 5 astetta

mittaukset: [-10, -4, 5]
  <% end %>

<% end %>



<% partial 'partials/material_heading' do %>
  Lisää rajapinnoista
<% end %>

<p>
  Rajapinta määrittelee yhden tai useamman metodin, jotka rajapinnan toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>. Rajapinta määrää, että <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>

<% partial 'partials/code_highlight' do %>
package sovellus.domain;

public interface Tunnistettava {
    String getTunnus();
}
<% end %>

<p>
  Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Alla on esimerkkinä luokka <code>Henkilo</code>, joka toteuttaa rajapinnan tunnistettava. Rajapinnan Tunnistettava vaatima metodi <code>getTunnus</code> palauttaa aina henkilön henkilötunnuksen.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus.domain;

public class Henkilo implements Tunnistettava {
    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getHenkilotunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getHenkilotunnus();
    }

    @Override
    public String toString() {
        return this.nimi + " hetu: " + this.henkilotunnus;
    }
}
<% end %>


<p>
  Rajapintojen vahvuus on se, että rajapintaa voidaan käyttää muuttujan tyyppinä. Tämä mahdollistaa yleiskäyttöisempien luokkien tekemisen.
</p>

<p>
  Tehdään luokka <code>Rekisteri</code>, jota käytetään Tunnistettava-tyyppisten olioiden säilömiseen. Rekisteriin voidaan lisätä sekä henkilöitä että mitä tahansa muita olioita, jotka toteuttavat rajapinnan Tunnistettava. Yksittäisten henkilöiden hakemisen lisäksi <code>Rekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.
</p>

<% partial 'partials/code_highlight' do %>
public class Rekisteri {
    private Map&lt;String, Tunnistettava&gt; rekisteroidyt;

    public Rekisteri() {
        this.rekisteroidyt = new HashMap&lt;&gt;();
    }

    public void lisaa(Tunnistettava lisattava) {
        this.rekisteroidyt.put(lisattava.getTunnus(), lisattava);
    }

    public Tunnistettava hae(String tunnus) {
        return this.rekisteroidyt.get(tunnus);
    }

    public List&lt;Tunnistettava&gt; haeKaikki() {
        return new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
    }
}<% end %>

<p>
  Rekisterin käyttö onnistuu seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
Rekisteri henkilokunta = new Rekisteri();
henkilokunta.lisaa(new Henkilo("Pekka", "221078-123X"));
henkilokunta.lisaa(new Henkilo("Jukka", "110956-326B"));

System.out.println(henkilokunta.hae("280283-111A"));

Henkilo loydetty = (Henkilo) henkilokunta.hae("110956-326B");
System.out.println(loydetty.getNimi());
<% end %>

<p>
  Koska henkilöt on lisätty rekisteriin <code>Tunnistettava</code>-tyyppisinä, ne löytyvät sieltä myös Tunnistettava-tyyppisinä. Jos haluamme käsitellä henkilöitä sellaisten metodien kautta, joita rajapinnassa ei ole määritelty, joudumme muuntamaan ne takaisin Henkilo-olioiksi. Tämä tapahtuu eksplisiittisella tyyppimuunnoksella, jota demonstroidaan edellisen esimerkin kahdella viimeisellä rivillä.
</p>

<p>
  Entä jos haluaisimme rekisteriin lisäksi metodin, joka palauttaa rekisteriin talletetut henkilöt tunnisteen mukaan järjestettynä? Yksi vaihtoehto olisi käyttää aiemmin tutuksi tullutta virran järjestämistä. Tutustutaan kuitenkin myös Javan valmiiseen järjestämisessä käytettävään rajapintaan.
</p>


<% partial 'partials/material_sub_heading' do %>
  Järjestämisessä käytettävä rajapinta Comparable
<% end %>

<p>
  Javan valmis rajapinta <code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a></code> määrittelee metodin <code>compareTo</code>, jota käytetään olioiden vertailuun. Jos olio on vertailujärjestyksessä ennen parametrina saatavaa olioa, tulee metodin palauttaa negatiivinen luku. Jos taas olio on järjestyksessä parametrina saatavan olion jälkeen, tulee metodin palauttaa positiivinen luku. Muulloin palautetaan luku 0. Tätä <code>compareTo</code>-metodin avulla johdettua järjestystä kutsutaan <em>luonnolliseksi järjestykseksi</em> (natural ordering).
</p>

<p>
  Tarkastellaan tätä ensin kerhossa käyvää lasta tai nuorta kuvaavan luokan Kerholainen avulla. Jokaisella kerholaisella on nimi ja pituus. Kerholaisten tulee mennä syömään pituusjärjestyksessä, joten toteutetaan kerholaisille rajapinta <code>Comparable</code>. Comparable-rajapinta ottaa tyyppiparametrinaan luokan, johon vertaus tehdään. Käytetään tyyppiparametrina samaa luokkaa <code>Kerholainen</code>.
</p>

<% partial 'partials/code_highlight' do %>
public class Kerholainen implements Comparable&lt;Kerholainen&gt; {
    private String nimi;
    private int pituus;

    public Kerholainen(String nimi, int pituus) {
	this.nimi = nimi;
	this.pituus = pituus;
    }

    public String getNimi() {
	return this.nimi;
    }

    public int getPituus() {
	return this.pituus;
    }

    @Override
    public String toString() {
	return this.getNimi() + " (" + this.getPituus() + ")";
    }

    @Override
    public int compareTo(Kerholainen kerholainen) {
	if (this.pituus == kerholainen.getPituus()) {
	    return 0;
	} else if (this.pituus &gt; kerholainen.getPituus()) {
	    return 1;
	} else {
	    return -1;
	}
    }
}<% end %>

<p>
  Rajapinnan vaatima metodi <code>compareTo</code> palauttaa kokonaisluvun, joka kertoo vertausjärjestyksestä. Koska <code>compareTo()</code>-metodista riittää palauttaa negatiivinen luku, jos <code>this</code>-olio on pienempi kuin parametrina annettu olio ja nolla, kun pituudet ovat samat, voidaan edellä esitelty metodi <code>compareTo</code> toteuttaa myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
@Override
public int compareTo(Kerholainen kerholainen) {
    return this.pituus - kerholainen.getPituus();
}
<% end %>

<p>
  Kerholaisten järjestäminen on nyt suoraviivaista.
</p>

<% partial 'partials/code_highlight' do %>
List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
kerholaiset.add(new Kerholainen("mikael", 182));
kerholaiset.add(new Kerholainen("matti", 187));
kerholaiset.add(new Kerholainen("ada", 184));

kerholaiset.stream().forEach(k -&gt; System.out.println(k);
System.out.println();
kerholaiset.stream().sorted().forEach(k -&gt; System.out.println(k);
<% end %>

<% partial 'partials/sample_output' do %>
mikael (182)
matti (187)
ada (184)

mikael (182)
ada (184)
matti (187)
<% end %>

<p>
  Koska Kerholainen toteuttaa rajapinnan Comparable, ei virran <code>sorted</code>-metodille tarvitse enää antaa parametrina olioiden vertailuun liittyvää järjestystä. Toisin sanoen, minkä tahansa Comparable-rajapinnan toteuttavan luokan oliot voi järjestää virran sorted-metodilla. Huomaa kuitenkin, että virta ei järjestä alkuperäistä listaa, vaan <em>vain virrassa olevat alkiot ovat järjestyksessä</em> -- jos alkuperäisen listan haluaa järjestykseen, tulee lista korvata järjestetystä virrasta kerätyllä listalla.
</p>



<% partial 'partials/exercise', locals: { name: 'Palkkajärjestys' } do %>

  <p>
    Saat valmiin luokan Ihminen. Ihmisellä on nimi- ja palkkatiedot. Muokkaa Ihminen-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee ihmiset palkan mukaan järjestykseen isoimmasta palkasta pienimpään.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Opiskelijat nimijärjestykseen' } do %>

  <p>
    Saat valmiin luokan Opiskelija. Opiskelijalla on nimi. Muokkaa Opiskelija-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee opiskelijat nimen mukaan aakkosjärjestykseen.
  </p>

  <p>
    <strong>Vinkki:</strong> Opiskelijan nimi on String, ja String-luokka on itsessään <code>Comparable</code>. Voit hyödyntää String-luokan <code>compareTo</code>-metodia Opiskelija-luokan metodia toteuttaessasi. <code>String.compareTo</code> kohtelee kirjaimia eriarvoisesti kirjainkoon mukaan, ja tätä varten String-luokalla on myös metodi <code>compareToIgnoreCase</code> joka nimensä mukaisesti jättää kirjainkoon huomioimatta. Voit käyttää opiskelijoiden järjestämiseen kumpaa näistä haluat.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Useamman rajapinnan toteuttaminen
<% end %>

<p>
  Luokka voi toteuttaa useamman rajapinnan. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidän toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalle <code>Henkilo</code> rajapinta <code>Comparable</code>.
</p>

<% partial 'partials/code_highlight' do %>
package sovellus.domain;

public class Henkilo implements Tunnistettava, Comparable&lt;Henkilo&gt; {
    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getHenkilotunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getHenkilotunnus();
    }

    @Override
    public int compareTo(Henkilo toinen) {
        return this.getTunnus().compareTo(toinen.getTunnus());
    }
}
<% end %>

<p>
  Kokeillaan lisätä aiemmin luomallemme Rekisteri-luokalle metodi haeKaikkiJarjestyksessa.
</p>

<% partial 'partials/code_highlight' do %>
public List&lt;Tunnistettava&gt; haeKaikkiJarjestyksessa() {
    // ei toimi!
    return rekisteroidyt.values()
        .stream().sorted().collect(Collectors.toCollection(ArrayList::new));
}
<% end %>

<p>
  Metodi ei kuitenkaan toimi. Koska henkilöt on talletettu rekisteriin <code>Tunnistettava</code>-tyyppisinä, on Henkilön toteutettava rajapinta <code>Comparable&lt;Tunnistettava&gt;</code>, jotta rekisteri osaisi järjestää henkilöt tunnistettavina. Joudumme joko muuttamaan henkilön toteuttamaa rajapintaa, tai lisäämään <code>sorted</code>-metodille järjestämiseen käytettävät tiedot. Muutetaan tässä henkilön toteuttamaa rajapintaa:
</p>

<% partial 'partials/code_highlight' do %>
public class Henkilo implements Tunnistettava, Comparable&lt;Tunnistettava&gt; {
    // ...

    @Override
    public int compareTo(Tunnistettava toinen) {
        return this.getTunnus().compareTo(toinen.getTunnus());
    }
}<% end %>

<p>
  Nyt ratkaisu toimii!
</p>

<p>
  Rekisteri on täysin tietämätön sinne lisättyjen olioiden todellisesta tyypistä. Voimme käyttää luokkaa rekisteri myös muuntyyppisten olioiden kuin henkilöiden rekisteröintiin, kunhan olioiden luokka vaan toteuttaa rajapinnan <code>Tunnistettava</code>. Esim. seuraavassa käytetään rekisteriä kaupassa myytävien tuotteiden hallintaan:
</p>

<% partial 'partials/code_highlight' do %>
public class Tuote implements Tunnistettava {

    private String nimi;
    private String viivakoodi;
    private int varastosaldo;
    private int hinta;

    public Tuote(String nimi, String viivakoodi) {
        this.nimi = nimi;
        this.viivakoodi = viivakoodi;
    }

    public String getTunnus() {
        return viivakoodi;
    }

    // ...
}
<% end %>


<% partial 'partials/code_highlight' do %>
Rekisteri tuotteet = new Rekisteri();
tuotteet.lisaa(new Tuote("maito", "11111111"));
tuotteet.lisaa(new Tuote("piimä", "11111112"));
tuotteet.lisaa(new Tuote("juusto", "11111113"));

System.out.println(tuotteet.hae("99999999"));

Tuote tuote = (Tuote) tuotteet.hae("11111112");
tuote.kasvataSaldoa(100);
tuote.muutaHinta(23);
<% end %>

<p>
  Teimme luokasta <code>Rekisteri</code> melko yleiskäyttöisen pitämällä sen riippumattomana konkreettisista luokista. Mikä tähänsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code>, on rekisterin kanssa käyttökelpoinen. Metodin <code>haeKaikkiJarjestyksessä</code> toimiminen tosin edellyttää luokalta myös vertailtavuuden eli Comparable&lt;Tunnistettava&gt;-rajapinnan toteuttamisen.
</p>


<% partial 'partials/hint', locals: { name: 'Muutama NetBeans-vihje' } do %>

  <ul>
    <li> <strong>Implement all abstract methods</strong>

      <p>
	Voit pyytää NetBeansia täydentämään metodirungot automaattisesti rajapinnan toteuttavalle luokalle. Kun olet määritellyt luokan toteuttavan rajapinnan, eli kirjoittanut
      </p>

      <% partial 'partials/code_highlight' do %>
public class Luokka implements Rajapinta {
}
      <% end %>

      <p>
	NetBeans värjää luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvät koodiin!
      </p>

    </li>

    <li> <strong>Clean and Build</strong>

      <p>
	Tietyissä tilanteissa NetBeans saattaa mennä sekaisin ja yrittää ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. Yleensä huomaat tilanteen siten, että jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio löytyy Run-valikosta ja sen voi suorittaa myös painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat käännetyt versiot ja tekee uuden käännöksen.
      </p>

    </li>

  </ul>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Oletusmetodit rajapinnoissa
<% end %>

<p>
  Rajapintoihin voi määritellä oletusmetodeja, joiden mukana annetaan myös toteutus. Oletusmetodien määrittely alkaa avainsanalla <code>default</code>, jota seuraa metodin määrittely. Kuten rajapintojen metodeissa yleensä, myös tässäkään näkyvyyttä ei tarvitse määritellä erikseen. Rajapinnoissa määriteltyjen metodien näkyvyys on aina <code>public</code>.
</p>

<p>
  Alla olevassa esimerkissä rajapintaan <code>Luettava</code> on lisätty oletusmetodi <code>lueTulostaen</code>, joka tulostaa <code>lue</code>-metodin palauttaman arvon.
</p>

<% partial 'partials/code_highlight' do %>
public interface Luettava {
    String lue();

    default void lueTulostaen() {
        System.out.println(lue());
    }
}
<% end %>

<p>
  Yksi oletusmetodien suurimmista hyödyistä ilmenee tilanteissa, missä rajapinta on määritelty aiemmin, ja useampi luokka toteuttaa sen jo valmiiksi. Jos rajapintaan lisätään uusi metodi, tulee sille ohjelmoida toteutus kaikkiin rajapinnan toteuttamiin luokkiin, jos uusi metodi ei tarjoa oletustoteutusta.
</p>

<p>
  Toisaalta, jos oletustoteutus lisätään uuden metodin lisäämisen yhteydessä, ei aiemmin rajapinnan toteuttaneille luokille tarvitse tehdä minkäänlaisia muutoksia. Edellisestä osasta tutut luokat Tekstiviesti ja Sahkoposti toimisivat nyt myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
Tekstiviesti viesti = new Tekstiviesti("G. Hopper", "COBOL kicks ass");
viesti.lueTulostaen();

Sahkoposti posti = new Sahkoposti("D. Knuth", "If you optimize everything, you will always be unhappy.");
posti.lueTulostaen();
<% end %>

<% partial 'partials/sample_output' do %>
COBOL kicks ass
If you optimize everything, you will always be unhappy.
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Järjestäminen ja hakeminen
<% end %>

<p>
  Tähän mennessä käyttämämme järjestäminen stream-metodin avulla ei muuta alkuperäisen listan järjestystä, vaan se luo aina uuden järjestetyn listan. Tutustutaan seuraavaksi luokkakirjastoon <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html" target="_blank" rel="noopener">Collections</a>, joka tarjoaa tähän liittyviä yleishyödyllisiä metodeja.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Järjestäminen
<% end %>

<p>
  Collections tarjoaa metodin <code>sort</code> listan järjestämiseen. Metodi olettaa, että listalla olevat oliot toteuttavat rajapinnan Comparable. Järjestäminen on suoraviivaista.
</p>


<% partial 'partials/code_highlight' do %>
List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
kerholaiset.add(new Kerholainen("mikael", 182));
kerholaiset.add(new Kerholainen("matti", 187));
kerholaiset.add(new Kerholainen("ada", 184));

kerholaiset.stream().forEach(k -&gt; System.out.println(k));
Collections.sort(kerholaiset);

System.out.println();

kerholaiset.stream().forEach(k -&gt; System.out.println(k));
<% end %>

<% partial 'partials/sample_output' do %>
mikael (182)
matti (187)
ada (184)

mikael (182)
ada (184)
matti (187)
<% end %>

<p>
  Järjestämisen lisäksi luokkakirjaston avulla voi etsiä esimerkiksi minimi- (<code>min</code>-metodi) tai maksimialkioita (<code>max</code>-metodi), vaikkapa kääntää listan (<code>reverse</code>-metodi).
</p>

<% partial 'partials/code_highlight' do %>
List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
kerholaiset.add(new Kerholainen("mikael", 182));
kerholaiset.add(new Kerholainen("matti", 187));
kerholaiset.add(new Kerholainen("ada", 184));

kerholaiset.stream().forEach(k -&gt; System.out.println(k));
Collections.sort(kerholaiset);
Collections.reverse(kerholaiset);

System.out.println();

kerholaiset.stream().forEach(k -&gt; System.out.println(k));

System.out.println();
System.out.println(Collections.max(kerholaiset));
<% end %>

<% partial 'partials/sample_output' do %>
mikael (182)
matti (187)
ada (184)

matti (187)
ada (184)
mikael (182)

matti (187)
<% end %>

<%= partial 'partials/quiz', locals: { id: '59fdce547bced50004788107' } %>


<% partial 'partials/exercise', locals: { name: 'Kirjallisuutta (3 osaa)' } do %>
  
  <p>
    Tee ohjelma, joka lukee käyttäjältä kirjoja ja niiden minimikohdeikiä. Minimikohdeiällä tarkoitetaan pienintä ikää vuosina, jolle kyseistä kirjaa suositellaan.
  </p>

  <p>
    Ohjelma kysyy uusia kirjoja kunnes käyttäjä syöttää tyhjän merkkijonon kirjan nimen kohdalla (eli painaa rivinvaihtoa). Täämän jälkeen ohjelma tulostaa syötettyjen kirjojen lukumäärän sekä kirjat.
  </p>

  <h2>Kirjojen lukeminen ja tulostaminen</h2>

  <p>
    Toteuta ensin kirjojen lukeminen ja niiden listaaminen. Tässä vaiheessa kirjojen järjestyksellä ei ole vielä väliä.
  </p>

  <% partial 'partials/sample_output' do %> 
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Soiva tuutulaulukirja</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>

    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Kurkkaa kulkuneuvot</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Lunta tupaan</font>
    Syötä kirjan pienin kohdeikä: <font color="red">12</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Litmanen 10</font>
    Syötä kirjan pienin kohdeikä: <font color="red">10</font>
    
    Syötä kirjan nimi, tyhjä lopettaa:
        
    Yhteensä 4 kirjaa.
    
    Kirjat:
    Soiva tuutulaulukirja (0 vuotiaille ja vanhemmille)
    Kurkkaa kulkuneuvot (0 vuotiaille ja vanhemmille)
    Lunta tupaan (12 vuotiaille ja vanhemmille)
    Litmanen 10 (10 vuotiaille ja vanhemmille)
  <% end %>
    
  <h2>Kirjojen järjestäminen kohdeiän perusteella</h2>

  <p>
    Täydennä toteuttamaasi ohjelmaa siten, että kirjat järjestetään tulostuksen yhteydessä kohdeiän perusteella. Jos kahdella kirjalla on sama kohdeikä, näiden kahden kirjan keskinäinen järjestys saa olla mielivaltainen.
  </p>


  <% partial 'partials/sample_output' do %> 
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Soiva tuutulaulukirja</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>

    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Kurkkaa kulkuneuvot</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Lunta tupaan</font>
    Syötä kirjan pienin kohdeikä: <font color="red">12</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Litmanen 10</font>
    Syötä kirjan pienin kohdeikä: <font color="red">10</font>
    
    Syötä kirjan nimi, tyhjä lopettaa:
    
    Yhteensä 4 kirjaa.
    
    Kirjat:
    Soiva tuutulaulukirja (0 vuotiaille ja vanhemmille)
    Kurkkaa kulkuneuvot (0 vuotiaille ja vanhemmille)
    Litmanen 10 (10 vuotiaille ja vanhemmille)
    Lunta tupaan (12 vuotiaille ja vanhemmille)
  <% end %>

  
  <h2>Kirjojen järjestäminen kohdeiän ja nimen perusteella</h2>

  <p>
    Täydennä edellistä ohjelmaasi siten, että saman kohdeiän kirjat tulostetaan aakkosjärjestyksessä.
  </p>


  <% partial 'partials/sample_output' do %> 
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Soiva tuutulaulukirja</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>

    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Kurkkaa kulkuneuvot</font>
    Syötä kirjan pienin kohdeikä: <font color="red">0</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Lunta tupaan</font>
    Syötä kirjan pienin kohdeikä: <font color="red">12</font>
    
    Syötä kirjan nimi, tyhjä lopettaa: <font color="red">Litmanen 10</font>
    Syötä kirjan pienin kohdeikä: <font color="red">10</font>
    
    Syötä kirjan nimi, tyhjä lopettaa:
    
    Yhteensä 4 kirjaa.
    
    Kirjat:
    Kurkkaa kulkuneuvot (0 vuotiaille ja vanhemmille)
    Soiva tuutulaulukirja (0 vuotiaille ja vanhemmille)
    Litmanen 10 (10 vuotiaille ja vanhemmille)
    Lunta tupaan (12 vuotiaille ja vanhemmille)
  <% end %>

<% end %>




<% partial 'partials/exercise', locals: { name: 'Muuttaminen (4 osaa)' } do %>

  <p>
    Muuttokuormaa pakattaessa esineitä lisätään muuttolaatikoihin siten, että tarvittujen laatikoiden määrä on mahdollisimman pieni. Tässä tehtävässä simuloidaan esineiden pakkaamista muuttolaatikoihin. Jokaisella esineellä on tilavuus, ja muuttolaatikoilla on maksimitilavuus.
  </p>


  <h2>Tavara ja Esine</h2>

  <p>
    Muuttomiehet siirtävät tavarat myöhemmin rekka-autoon (ei toteuteta tässä), joten toteutetaan ensin kaikkia esineitä ja laatikoita kuvaava <code>Tavara</code>-rajapinta.
  </p>

  <p>
    Tavara-rajapinnan tulee määritellä metodi <code>int getTilavuus()</code>, jonka avulla tavaroita käsittelevät saavat selville kyseisen tavaran tilavuuden. Toteuta rajapinta <code>Tavara</code> pakkaukseen <code>muuttaminen.domain</code>.
  </p>

  <p>
    Toteuta seuraavaksi pakkaukseen <code>muuttaminen.domain</code> luokka <code>Esine</code>, joka saa konstruktorin parametrina esineen nimen (String) ja esineen tilavuuden (int). Luokan tulee toteuttaa rajapinta <code>Tavara</code>.
  </p>

  <p>
    Lisää luokalle <code>Esine</code> myös metodit <code>public String getNimi()</code> ja korvaa metodi <code>public String toString()</code> siten että se tuotta merkkijonoja muotoa "<code>nimi (tilavuus dm^3)</code>". Esineen tulee toimia seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    Tavara esine = new Esine("hammasharja", 2);
    System.out.println(esine);
  <% end %>

  <% partial 'partials/sample_output' do %>
    hammasharja (2 dm^3)
  <% end %>


  <h2>Esine vertailtavaksi</h2>

  <p>
    Pakatessamme esineitä muuttolaatikkoon haluamme aloittaa pakkaamisen järjestyksessä olevista esineistä. Toteuta <code>Esine</code>-luokalla rajapinta <code>Comparable</code> siten, että esineiden <em>luonnollinen järjestys</em> on tilavuuden mukaan nouseva. Kun olet toteuttanut esineellä rajapinnan <code>Comparable</code>, tulee niiden toimia <code>Collections</code>-luokan <code>sort</code>-metodin kanssa seuraavasti.
  </p>


  <% partial 'partials/code_highlight' do %>
    List&lt;Esine&gt; esineet = new ArrayList&lt;&gt;();
    esineet.add(new Esine("passi", 2));
    esineet.add(new Esine("hammasharja", 1));
    esineet.add(new Esine("sirkkeli", 100));

    Collections.sort(esineet);
    System.out.println(esineet);
  <% end %>

  <% partial 'partials/sample_output' do %>
    [hammasharja (1 dm^3), passi (2 dm^3), sirkkeli (100 dm^3)]
  <% end %>


  <h2>Muuttolaatikko</h2>

  <p>Toteuta tämän jälkeen pakkaukseen <code>muuttaminen.domain</code> luokka <code>Muuttolaatikko</code>. Tee aluksi muuttolaatikolle seuraavat:</p>

  <ul>
    <li><code>public Muuttolaatikko(int maksimitilavuus)</code></li>Muuttolaatikko-luokan konstruktori. Saa parametrina muuttolaatikon maksimitilavuuden.<br/>
    <li><code>public boolean lisaaTavara(Tavara tavara)</code></li> Lisää muuttolaatikkoon <code>Tavara</code>-rajapinnan toteuttaman esineen. Jos laatikkoon ei mahdu, metodi palauttaa arvon <code>false</code>. Jos tavara mahtuu laatikkoon, metodi palauttaa arvon <code>true</code>. Muuttolaatikon tulee tallettaa tavarat listaan.<br/>
  </ul>

  <p>
    Laita vielä <code>Muuttolaatikko</code> toteuttamaan rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code> tulee saada selville muuttolaatikossa olevien tavaroiden tämänhetkinen yhteistilavuus.
  </p>


  <h2>Esineiden pakkaaminen</h2>

  <p>
    Toteuta luokka <code>Pakkaaja</code> pakkaukseen <code>muuttaminen.logiikka</code>. Luokan <code>Pakkaaja</code> konstruktorille annetaan parametrina <code>int laatikoidenTilavuus</code>, joka määrittelee minkä kokoisia muuttolaatikoita pakkaaja käyttää.
  </p>

  <p>
    Toteuta tämän jälkeen luokalle metodi <code>public List&lt;Muuttolaatikko&gt; pakkaaTavarat(List&lt;Tavara&gt; tavarat)</code>, joka pakkaa tavarat muuttolaatikoihin.
  </p>

  <p>
    Tee metodista sellainen, että kaikki parametrina annetussa listassa olevat tavarat päätyvät muuttolaatikoihin. Muuttolaatikot tulee luoda metodissa. Sinun ei tarvitse varautua tilanteisiin, joissa tavarat ovat suurempia kuin pakkaajan käyttämä muuttolaatikon koko. Testit eivät välitä siitä kuinka täyteen pakkaaja täyttää muuttolaatikot.
  </p>

  <% partial 'partials/code_highlight' do %>
    // tavarat jotka haluamme pakata
    List&lt;Tavara&gt; tavarat = new ArrayList&lt;&gt;();
    tavarat.add(new Esine("passi", 2));
    tavarat.add(new Esine("hammasharja", 1));
    tavarat.add(new Esine("kirja", 4));
    tavarat.add(new Esine("sirkkeli", 8));

    // luodaan pakkaaja, joka käyttää tilavuudeltaan 10:n kokoisia muuttolaatikoita
    Pakkaaja pakkaaja = new Pakkaaja(10);

    // pyydetään pakkaajaa pakkaamaan tavarat laatikoihin
    List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaTavarat(tavarat);

    System.out.println("laatikoita: " + laatikot.size());

    laatikot.stream().forEach(laatikko -&gt; {
        System.out.println("  laatikossa tavaraa: " + laatikko.getTilavuus() + " dm^3");
    });
  <% end %>


  <% partial 'partials/sample_output' do %>
    laatikoita: 2
    laatikossa tavaraa: 7 dm^3
    laatikossa tavaraa: 8 dm^3
  <% end %>

  <p>
    Pakkaaja on siis pakannut tavarat kahteen laatikkoon, ensimmäiseen laatikkoon on mennyt 3 ensimmäistä tavaraa, yhteistilavuudeltaan 7, ja listan viimeinen tavara eli sirkkeli jonka tilavuus on 8 on mennyt toiseen laatikkoon. Testit eivät aseta rajoitusta pakkaajan käyttävien muuttolaatioiden määrälle, tavarat olisi siis voitu pakata vaikka jokainen eri laatikkoon, eli tuloste olisi ollut:
  </p>

  <% partial 'partials/sample_output' do %>
    laatikoita: 4
    laatikossa tavaraa: 2 dm^3
    laatikossa tavaraa: 1 dm^3
    laatikossa tavaraa: 7 dm^3
    laatikossa tavaraa: 8 dm^3
  <% end %>

  <p>
    <strong>Huom:</strong> tehtävän testaamista helpottamaan kannatanee tehdä luokalle <code>Muuttolaatikko</code> esim. toString-metodi, jonka avulla voi printata laatikon sisällön.
  </p>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Binäärihaku ja hakeminen
<% end %>

<p>
  Binäärihaku (tunnetaan myös nimellä puolitushaku) etsii annettua arvoa järjestyksessä olevasta listasta. Tutustutaan algoritmin ideaa seuraavan järjestyksessä olevan listan avulla.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   0   1   2   3    4   5    6   7   8   9  10
  // luvut     -7  -3   3   7   11  15   17  21  24  28  30
<% end %>

<p>
  Oletetaan että haluamme löytää luvun 17 indeksin. Hyödynnetään tietoa siitä että arvot ovat järjestyksessä. Sen sijaan, että kävisimme lukuja läpi alusta lähtien, tarkastelemme arvoa listan puolivälissä. Listan puolivälissä olevan alkion indeksi on isoin indeksi 10 jaettuna kahdella eli 5. Keskimmäinen alkio on merkattu seuraavaan tähdellä:
</p>

<% partial 'partials/sample_output' do %>
                                     *
  // indeksit   0   1   2   3    4   5    6   7   8   9  10
  // luvut     -7  -3   3   7   11  15   17  21  24  28  30
<% end %>

<p>
  Puolessa välissä on luku 15, joka ei ollut hakemamme luku (eli luku 17). Koska taulukko on järjestyksessä (tässä suuruusjärjestyksessä), ei etsitty luku voi missään tapauksessa olla luvun 15 vasemmalla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat pienempiä tai yhtäsuuria kuin 5, eivät missään nimessä sisällä hakemaamme arvoa.
</p>

<p>
  Alue, jolta etsimme haettavaa lukua voidaan nyt rajata lukuihin, jotka sijaitsevat indeksin 5 oikealla puolella, eli indekseihin välillä [6, 10] (6, 7, 8, 9, 10). Seuraavassa on merkitty harmaalla se osa taulukkoa jossa etsitty ei voi olla:
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7   8   9  10
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
<% end %>

<p>
  Tutkitaan seuraavaksi jäljellä olevan etsintäalueen, eli indeksien 6-10 keskimmäistä indeksiä. Keskimmäinen indeksi löytyy laskemalla etsintäalueen pienimmän ja suurimman indeksin summan ja jakamalla se kahdella, eli (6+10)/2 = 16/2 = 8. Indeksi 8 on merkitty alle tähdellä.
</p>

<% partial 'partials/sample_output' do %>
                                                   *
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7   8   9  10
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
<% end %>

<p>
  Indeksissä 8 oleva luku on 24, joka ei ollut hakemamme luku. Koska luvut taulukossa ovat suuruusjärjestyksessä, ei etsittävä luku voi missään nimessä olla luvun 24 oikealla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat suurempia tai yhtäsuuria kuin 8, eivät missään nimessä sisällä hakemaamme arvoa. Etsintäalue rajautuu taas:
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Etsintä jatkuu. Tutkitaan jäljellä olevan etsintäalueen, eli indeksien 6-7, keskimmäistä indeksiä. Keskimmäinen indeksi löytyy taas ottamalla etsintäalueen pienimmän ja suurimman indeksin summa ja jakamalla se kahdella, eli (6+7)/2 = 6,5, joka pyöristyy alaspäin luvuksi 6. Kohta on merkitty alle tähdellä.
</p>

<% partial 'partials/sample_output' do %>
                                           *
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Indeksissä 6 on luku 17, joka on sama kuin hakemamme luku. Voimme lopettaa haun ja ilmoittaa että etsitty luku on taulukossa. Jos luku ei olisi ollut taulukossa -- esimerkiksi jos haettava luku olisi ollut 16, etsintäalue olisi jäänyt lopulta tyhjäksi.
</p>

<% partial 'partials/sample_output' do %>
                                           *
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    <font color="red">6</font>   7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   <font color="red">17</font>  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Simuloi kynällä ja paperilla miten binäärihaku toimii kun taulukkona on alla oleva taulukko ja haet ensin lukua 33, sitten lukua 1.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   0   1   2   3   4   5   6   7   8   9  10  11  12  13
  // luvut     -5  -2   3   5   8  11  14  20  22  26  29  33  38  41
<% end %>


<% partial 'partials/hint', locals: { name: 'Binäärihaku vs. Peräkkäishaku' } do %>
  
  <p>
    Peräkkäishaun pahimmassa tapauksessa käydään kaikki taulukon arvot läpi. Miljoona alkiota sisältävässä taulukossa tämä tarkoittaa miljoonan alkion tarkastelua.
  </p>

  <p>
    Binäärihaun pahimmassa tapauksessa tutkittava alue jaetaan kahteen osaan kunnes osan koko on yksi. Alkioita tarkastellaan huomattavasti vähemmän kuin peräkkäishaussa. Tarkastellaan tätä hieman tarkemmin.
  </p>

  <p>
    Lista, jossa on 16 alkiota, voidaan jakaa kahteen osaan korkeintaan 4 kertaa, eli 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1.
  </p>

  <p>
    Toisaalta, lista, jossa on miljoona alkiota voidaan jakaa kahteen osaan korkeintaa 20 kertaa, eli 1000000 -&gt; 500000 -&gt; 250000 -&gt; 125000 -&gt; 62500 -&gt; 31250 -&gt; 15625 -&gt; ~7813 -&gt; ~3907 -&gt; 1954 -&gt; ~977 -&gt; ~489 -&gt; ~245 -&gt; ~123 -&gt; ~62 -&gt; ~31 -&gt; ~16 -&gt; ~8 -&gt; ~4 -&gt; ~2 -&gt; ~1.
  </p>

  <p>
    Mitä tämä tarkoittaa? Binäärihakua käyttäen miljoona alkiota sisältävästä listasta tulee pahimmassa tapauksessa tarkastella noin kahtakymmentä alkiota, kun peräkkäishaussa tarkasteltavia alkioita on miljoona.
  </p>

  <p>
    Koska haettavien alkioiden määrä puolittuu binäärihaussa jokaisen tarkastelun yhteydessä, voi binäärihaun tehokkuutta tarkastella kaksikantaisen logaritmin avulla. Kaksikantainen logaritmi (<code>log<sub>2</sub></code>) annetusta luvusta kertoo kuinka monta kertaa luku voidaan puolittaa. Esimerkiksi kaksikantainen logaritmi luvusta 16777216 (<code>log<sub>2</sub> 16777216</code>) on 24, ja luvun 4294967296 kaksikantainen logaritmi, (<code>log<sub>2</sub> 4294967296</code>) on 32. Tämä tarkoittaa että 4294967296 eri arvoa sisältävästä järjestyksessä olevasta listasta hakeminen vaatisi binäärihaulta korkeintaan 32 eri alkion tarkastamista.
  </p>

<% end %>


<p>
  Collections-luokkakirjasto tarjoaa valmiiksi toteutetun binäärihakualgoritmin. Kerholainen-luokkamme vertaa pituuksia <code>compareTo()</code>-metodissaan, eli listasta etsiessä etsisimme samanpituista kerholaista.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;&gt;();
  kerholaiset.add(new Kerholainen("mikael", 182));
  kerholaiset.add(new Kerholainen("matti", 187));
  kerholaiset.add(new Kerholainen("joel", 184));

  Collections.sort(kerholaiset);

  Kerholainen haettava = new Kerholainen("Nimi", 180);
  int indeksi = Collections.binarySearch(kerholaiset, haettava);

  if (indeksi &gt;= 0) {
      System.out.println("180 senttiä pitkä löytyi indeksistä " + indeksi);
      System.out.println("nimi: " + kerholaiset.get(indeksi).getNimi());
  }

  haettava = new Kerholainen("Nimi", 187);
  int indeksi = Collections.binarySearch(kerholaiset, haettava);

  if (indeksi &gt;= 0) {
      System.out.println("187 senttiä pitkä löytyi indeksistä " + indeksi);
      System.out.println("nimi: " + kerholaiset.get(indeksi).getNimi());
  }
<% end %>

<% partial 'partials/sample_output' do %>
  187 senttiä pitkä löytyi indeksistä 2
  nimi: matti
<% end %>

<p>
  Esimerkissä kutsuttiin myös metodia <code>Collections.sort()</code> sillä binäärihakualgoritmi ei toimi jos käsiteltävä lista ei ole valmiiksi järjestyksessä. Huom! Älä kuitenkaan toteuta hakutoiminnallisuutta siten, että lista järjestetään jokaisen haun yhteydessä -- järjestäminen itsessään on hitaampaa kuin peräkkäishaku eli listan läpikäynti alkio kerrallaan. Binäärihaun hyödyt tulevatkin esille vasta useamman haun jälkeen.
</p>





<% partial 'partials/material_heading' do %>
  Olioiden monimuotoisuus
<% end %>

<p>
  Olemme aiemmissa osissa törmänneet tilanteisiin, joissa viittaustyyppisillä muuttujilla on oman tyyppinsä lisäksi muita tyyppejä. Esimerkiksi <em>kaikki</em> oliot ovat tyyppiä <code>Object</code>, eli mikä tahansa olio voidaan oman tyyppinsä lisäksi esittää <code>Object</code>-tyyppisenä muuttujana.
</p>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "merkkijono";
  Object merkkijonoString = "toinen merkkijono";
<% end %>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "merkkijono";
  Object merkkijonoString = merkkijono;
<% end %>

<p>
  Yllä olevissa esimerkeissä merkkijonomuuttuja esitetään sekä String-tyyppisenä että Object-tyyppisenä, jonka lisäksi String-tyyppinen muuttuja asetetaan Object-tyyppiseen muuttujaan. Asetus toiseen suuntaan, eli Object-tyyppisen muuttujan asettaminen String-tyyppiseksi ei kuitenkaan onnistu. Tämä johtuu siitä, että <code>Object</code>-tyyppiset muuttujat eivät ole tyyppiä <code>String</code></p>

<% partial 'partials/code_highlight' do %>
  Object merkkijonoString = "toinen merkkijono";
  String merkkijono = merkkijonoString; // EI ONNISTU!
<% end %>

<p>
  Mistä tässä oikein on kyse?
</p>

<p>
  Jokainen muuttuja voidaan esittää muuttujan alkuperäisen tyypin lisäksi myös muuttujan toteuttamien rajapintojen sekä perimien luokkien tyyppisenä. Luokka String perii luokan Object, joten String-oliot ovat aina myös tyyppiä Object. Luokka Object ei peri String-luokkaa, joten Object-tyyppiset muuttujat eivät ole automaattisesti tyyppiä String. Tutustutaan tarkemmin <code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a></code>-luokan API-dokumentaatioon, erityisesti HTML-sivun yläosaan.
</p>

<img src="/img/material/string-api-perinta.png" alt="Kuvakaappaus String-luokan API-dokumentaatiosta. Kuvakaappauksessa näkyy, että String-luokka perii luokan Object."/>

<p>
  String-luokan API-dokumentaatio alkaa yleisellä otsakkeella jota seuraa luokan pakkaus (<code>java.lang</code>). Pakkauksen jälkeen tulee luokan nimi (<code>Class String</code>), jota seuraa luokan <em>perintähierarkia</em>.
</p>

<pre>
  <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">java.lang.Object</a>
  <img src="/img/material/perinta.gif"/><strong>java.lang.String</strong>
</pre>

<p>
  Perintähierarkia listaa luokat, jotka luokka on perinyt. Perityt luokat listataan perimisjärjestyksessä, tarkasteltava luokka aina alimpana. String-luokan perintähierarkiasta näemme, että <code>String</code>-luokka perii luokan <code>Object</code>. <em>Javassa jokainen luokka voi periä korkeintaan yhden luokan</em>. Toisaalta, perittävä luokka on voinut periä toisen luokan, joten välillisesti luokka voi periä useampia luokkia.
</p>

<p>
  Perintähierarkiaa voi ajatella myös listana tyypeistä, joita olio toteuttaa.
</p>

<p>
  Tieto siitä, että oliot voivat olla montaa eri tyyppiä -- esimerkiksi tyyppiä Object -- suoraviivaistaa ohjelmointia. Jos tarvitsemme metodissa vain Object-luokassa määriteltyjä metodeja kuten <code>toString</code>, <code>equals</code> ja <code>hashCode</code>, voimme käyttää metodin parametrina tyyppiä <code>Object</code>. Tällöin metodille voi antaa parametrina <em>minkä tahansa</em> olion. Tarkastellaan tätä metodin <code>tulostaMonesti</code> avulla. Metodi saa parametrinaan <code>Object</code>-tyyppisen muuttujan ja tulostusten lukumäärän.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tulostin {
      ...
      public void tulostaMonesti(Object object, int kertaa) {
          for (int i = 0; i &lt; kertaa; i++) {
              System.out.println(object.toString());
              // tai System.out.println(object);
          }
      }
  ...
  }
<% end %>

<p>
  Metodille voi antaa parametrina minkä tahansa olion. Metodin <code>tulostaMonesti</code> sisällä oliolla on käytössään vain <code>Object</code>-luokassa määritellyt metodit, koska olio <em>tunnetaan</em> metodissa <code>Object</code>-tyyppisenä. Todellisuudessa olio voi olla myös toisen tyyppinen.
</p>

<% partial 'partials/code_highlight' do %>
  Tulostin tulostin = new Tulostin();

  String merkkijono = " o ";
  List&lt;String&gt; sanat = new ArrayList&lt;&gt;();
  sanat.add("polymorfismi");
  sanat.add("perintä");
  sanat.add("kapselointi");
  sanat.add("abstrahointi");

  tulostin.tulostaMonesti(merkkijono, 2);
  tulostin.tulostaMonesti(sanat, 3);
<% end %>

<% partial 'partials/sample_output' do %>
  o
  o
  [polymorfismi, perintä, kapselointi, abstrahointi]
  [polymorfismi, perintä, kapselointi, abstrahointi]
  [polymorfismi, perintä, kapselointi, abstrahointi]
<% end %>

<p>
  Jatketaan <code>String</code>-luokan API-kuvauksen tarkastelua. Kuvauksessa olevaa perintähierarkiaa seuraa listaus luokan toteuttamista rajapinnoista.
</p>

<pre>
  <strong>All Implemented Interfaces:</strong>
  <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html" target="_blank" rel="noopener">Serializable</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" target="_blank" rel="noopener">CharSequence</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener">Comparable</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a>&gt;
</pre>

<p>
  Luokka <code>String</code> toteuttaa rajapinnat <code>Serializable</code>, <code>CharSequence</code>, ja <code>Comparable&lt;String&gt;</code>. Myös rajapinta on tyyppi. Luokan String API-kuvauksen mukaan String-olion tyypiksi voi asettaa seuraavat rajapinnat.
</p>

<% partial 'partials/code_highlight' do %>
  Serializable serializableString = "merkkijono";
  CharSequence charSequenceString = "merkkijono";
  Comparable&lt;String&gt; comparableString = "merkkijono";
<% end %>

<p>
  Koska metodeille voidaan määritellä metodin parametrin tyyppi, voimme määritellä metodeja jotka vastaanottavat <em>tietyn rajapinnan toteuttavan</em> olion. Kun metodille määritellään parametrina rajapinta, sille voidaan antaa parametrina mikä tahansa olio, joka toteuttaa kyseisen rajapinnan.
</p>

<p>
  Täydennetään <code>Tulostin</code>-luokkaa siten, että sillä on metodi <code>CharSequence</code>-rajapinnan toteuttavien olioiden merkkien tulostamiseen. Rajapinta <code>CharSequence</code> tarjoaa muunmuassa metodit <code>int length()</code>, jolla saa merkkijonon pituuden, ja <code>char charAt(int index)</code>, jolla saa merkin tietyssä indeksissä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tulostin {
      ...
      public void tulostaMonesti(Object object, int kertaa) {
          for (int i = 0; i &lt; kertaa; i++) {
              System.out.println(object.toString());
          }
      }

      public void tulostaMerkit(CharSequence charSequence) {
          for (int i = 0; i &lt; charSequence.length(); i++) {
              System.out.println(charSequence.charAt(i));
          }
      }
      ...
  }<% end %>

<p>
  Metodille <code>tulostaMerkit</code> voi antaa minkä tahansa <code>CharSequence</code>-rajapinnan toteuttavan olion. Näitä on muunmuassa <code>String</code> ja merkkijonojen rakentamisessa usein Stringiä tehokkaampi <code>StringBuilder</code>. Metodi <code>tulostaMerkit</code> tulostaa annetun olion jokaisen merkin omalle rivilleen.
</p>

<% partial 'partials/code_highlight' do %>
  Tulostin tulostin = new Tulostin();

  String mjono = "toimii";

  tulostin.tulostaMerkit(mjono);
<% end %>

<% partial 'partials/sample_output' do %>
  t
  o
  i
  m
  i
  i
<% end %>


<% partial 'partials/exercise', locals: { name: 'Joukkoja (2 osaa)' } do %>

  <p>
    Tässä tehtävässä teemme eliöita ja eliöistä koostuvia laumoja jotka liikkuvat ympäriinsä. Eliöiden sijaintien ilmoittamiseen käytetään <em>kaksiulotteista koordinaatistoa</em>. Jokaiseen sijaintiin liittyy kaksi lukua, <code>x</code>- ja <code>y</code>-koordinaatti. Koordinaatti <code>x</code> kertoo, kuinka pitkällä "nollapisteestä" mitattuna sijainti on vaakasuunnassa, ja koordinaatti <code>y</code> vastaavasti kuinka pitkällä sijainti on pystysuunnassa. Jos koordinaatiston käsite ei ole tuttu, voit lukea siitä lisää esimerkiksi <a href="http://fi.wikipedia.org/wiki/Koordinaatisto">wikipediasta</a>.
  </p>

  <p>
    Tehtävän mukana tulee rajapinta <code>Siirrettava</code>, joka kuvaa asiaa jota voidaan siirtää paikasta toiseen. Rajapinta sisältää metodin <code>void siirra(int dx, int dy)</code>. Parametri <code>dx</code> kertoo, paljonko asia siirtyy x-akselilla ja <code>dy</code> y-akselilla.
  </p>

  <p>
    Tehtävässä toteutat luokat <code>Elio</code> ja <code>Lauma</code>, jotka molemmat ovat siirrettäviä. Toteuta kaikki toiminnallisuus pakkaukseen <code>siirrettava</code>.
  </p>

  <h2>Elio-luokan toteuttaminen</h2>

  <p>
    Luo pakkaukseen <code>siirrettava</code> luokka <code>Elio</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Eliön tulee tietää oma sijaintinsa (x, y -koordinaatteina). Luokan <code>Elio</code> APIn tulee olla seuraava:
  </p>

  <ul>
    <li><strong>public Elio(int x, int y)</strong><br/>Luokan konstruktori, joka saa olion aloitussijainnin x- ja y-koordinaatit parametrina</li>
    <li><strong>public String toString()</strong><br/> Luo ja palauttaa oliosta merkkijonoesityksen. Eliön merkkijonoesityksen tulee olla seuraavanlainen <code>"x: 3; y: 6"</code>. Huomaa että koordinaatit on erotettu puolipisteellä (<code>;</code>)</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää oliota parametrina saatujen arvojen verran. Muuttuja <code>dx</code> sisältää muutoksen koordinaattiin <code>x</code>, muuttuja <code>dy</code> sisältää muutoksen koordinaattiin <code>y</code>. Esimerkiksi jos muuttujan <code>dx</code> arvo on 5, tulee oliomuuttujan <code>x</code> arvoa kasvattaa viidellä</li>
  </ul>

  <p>
    Kokeile luokan <code>Elio</code> toimintaa seuraavalla esimerkkikoodilla.
  </p>

  <% partial 'partials/code_highlight' do %>
    Elio elio = new Elio(20, 30);
    System.out.println(elio);
    elio.siirra(-10, 5);
    System.out.println(elio);
    elio.siirra(50, 20);
    System.out.println(elio);
  <% end %>

  <% partial 'partials/sample_output' do %>
    x: 20; y: 30
    x: 10; y: 35
    x: 60; y: 55
  <% end %>


  <h2>Lauman toteutus</h2>

  <p>
    Luo pakkaukseen <code>siirrettava</code> luokka <code>Lauma</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Lauma koostuu useasta <code>Siirrettava</code>-rajapinnan toteutavasta oliosta, jotka tulee tallettaa esimerkiksi listarakenteeseen.
  </p>

  <p>
    Luokalla <code>Lauma</code> tulee olla seuraavanlainen API.
  </p>

  <ul>
    <li><strong>public String toString()</strong><br/> Palauttaa merkkijonoesityksen lauman jäsenten sijainnista rivin vaihdolla erotettuna.</li>
    <li><strong>public void lisaaLaumaan(Siirrettava siirrettava)</strong><br/> Lisää laumaan uuden <code>Siirrettava</code>-rajapinnan toteuttavan olion</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää laumaa parametrina saatujen arvojen verran. Huomaa että tässä sinun tulee siirtää jokaista lauman jäsentä.</li>
  </ul>

  <p>Kokeile ohjelmasi toimintaa alla olevalla esimerkkikoodilla.</p>

  <% partial 'partials/code_highlight' do %>
    Lauma lauma = new Lauma();
    lauma.lisaaLaumaan(new Elio(73, 56));
    lauma.lisaaLaumaan(new Elio(57, 66));
    lauma.lisaaLaumaan(new Elio(46, 52));
    lauma.lisaaLaumaan(new Elio(19, 107));
    System.out.println(lauma);
  <% end %>

  <% partial 'partials/sample_output' do %>
    x: 73; y: 56
    x: 57; y: 66
    x: 46; y: 52
    x: 19; y: 107
  <% end %>

<% end %>


<% partial 'partials/material_heading' do %>
  Ryhmittely hajautustaulun avulla
<% end %>

<p>
  Kerrataan osan lopuksi vielä hieman hajautustaulun toimintaa sekä ryhmittelyä. Hajautustaulu sisältää korkeintaan yhden arvon yhtä avainta kohti. Alla luodaan henkilöiden puhelinnumeroita hajautustauluun.
</p>

<% partial 'partials/code_highlight' do %>
  Map&lt;String, String&gt; puhelinnumerot = new HashMap&lt;&gt;();
  puhelinnumerot.put("Pekka", "040-12348765");

  System.out.println("Pekan numero: " + puhelinnumerot.get("Pekka"));

  puhelinnumerot.put("Pekka", "09-111333");

  System.out.println("Pekan numero: " + puhelinnumerot.get("Pekka"));
<% end %>

<% partial 'partials/sample_output' do %>
  Pekan numero: 040-12348765
  Pekan numero: 09-111333
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Useampi arvo yhdelle avaimelle
<% end %>

<p>
  Entä jos haluaisimme liittää yhteen avaimeen useita arvoja, eli esimerkiksi useampia puhelinnumeroita yhdelle henkilölle?
</p>

<p>
  Koska hajautustaulun avaimet ja arvot voivat olla mitä tahansa muuttujia, listojen käyttäminen hajautustaulun arvona onnistuu. Useamman arvon lisääminen yhdelle arvolle onnistuu liittämällä avaimeen lista. Muutetaan puhelinnumeroiden talletustapaa seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  Map&lt;String, List&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;&gt;();
<% end %>

<p>
  Nyt hajautustaulussa on jokaiseen avaimeen liitettynä lista. Vaikka new-komento luo hajautustaulun, ei hajautustaulu sisällä alussa yhtäkään listaa. Ne on luotava tarvittaessa erikseen.
</p>

<% partial 'partials/code_highlight' do %>
  Map&lt;String, List&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;&gt;();

  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put("Pekka", new ArrayList&lt;&gt;());

  // ja lisätään Pekkaa vastaavalle listalle puhelinnumero
  puhelinnumerot.get("Pekka").add("040-12348765");
  // ja lisätään toinenkin puhelinnumero
  puhelinnumerot.get("Pekka").add("09-111333");

  System.out.println("Pekan numerot: " + puhelinnumerot.get("Pekka"));
<% end %>

<% partial 'partials/sample_output' do %>
  Pekan numero: [040-12348765, 09-111333]
<% end %>

<p>
  Määrittelimme muuttujan puhelinnumero tyypiksi <code>Map&lt;String, List&lt;String&gt;&gt;</code>. Tämä tarkoittaa hajautustaulua, joka käyttää avaimena merkkijonoa ja arvona merkkijonoja sisältävää listaa. Hajautustauluun lisättävät arvot ovat siis <code>List&lt;String&gt;</code>-rajapinnan toteuttavia konkreettisia olioita, eli esimerkiksi ArrayListejä.
</p>

<% partial 'partials/code_highlight' do %>
  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put("Pekka", new  ArrayList&lt;&gt;());

  // ...
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Joukoista
<% end %>

<p>
  Rajapinta <code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" target="_blank" rel="noopener">Set</a></code> kuvaa joukon toiminnallisuutta. Toisin kuin listalla, joukossa kutakin alkioita on korkeintaan yksi kappale, eli yhtään samanlaista oliota ei ole kahdesti. Olioiden samankaltaisuuden tarkistaminen toteutetaan <code>equals</code> ja <code>hashCode</code> -metodeja käyttämällä.
</p>

<p>
  Yksi rajapinnan <code>Set</code> toteuttava luokka on <code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" target="_blank" rel="noopener">HashSet</a></code>. Toteutetaan sen avulla luokka <code>Tehtavakirjanpito</code>, joka tarjoaa mahdollisuuden tehtävien kirjanpitoon ja tehtyjen tehtävien tulostamiseen. Oletetaan että tehtävät ovat aina kokonaislukuja.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tehtavakirjanpito {
      private Set&lt;Integer&gt; tehdytTehtavat;

      public Tehtavakirjanpito() {
          this.tehdytTehtavat = new HashSet&lt;&gt;();
      }

      public void lisaa(int tehtava) {
          this.tehdytTehtavat.add(tehtava);
      }

      public void tulosta() {
          this.tehdytTehtavat.stream().forEach(t -&gt; System.out.println(t));
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
  kirjanpito.lisaa(1);
  kirjanpito.lisaa(1);
  kirjanpito.lisaa(2);
  kirjanpito.lisaa(3);

  kirjanpito.tulosta();
<% end %>

<% partial 'partials/sample_output' do %>
  1
  2
  3
<% end %>

<p>
  Yllä oleva ratkaisu toimii tilanteessa, jossa emme tarvitse tietoa eri käyttäjien tekemistä tehtävistä. Muutetaan sovelluksen toiminnallisuutta siten, että tehtävät tallennetaan <em>käyttäjäkohtaisesti</em> hajautustaulua hyödyntäen. Käyttäjät tunnistetaan käyttäjän yksilöivällä merkkijonolla (esimerkiksi opiskelijanumero), ja jokaiselle käyttäjälle on oma joukko tehdyistä tehtävistä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tehtavakirjanpito {
      private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

      public Tehtavakirjanpito() {
          this.tehdytTehtavat = new HashMap&lt;&gt;();
      }

      public void lisaa(String kayttaja, int tehtava) {
          // uudelle käyttäjälle on lisättävä HashMapiin tyhjä tehtäväjoukko jos sitä
          // ei ole jo lisätty
          this.tehdytTehtavat.putIfAbsent(kayttaja, new HashSet&lt;&gt;());

          // haetaan ensin käyttäjän tehtävät sisältävä joukko ja tehdään siihen lisäys
          Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
          tehdyt.add(tehtava);

          // edellinen olisi onnitunut myös ilman apumuuttujaa seuraavasti
          // this.tehdytTehtavat.get(kayttaja).add(tehtava);
      }

      public void tulosta() {
          this.tehdytTehtavat.entrySet().stream(entry -&gt; {
              System.out.println(entry.getKey() + ": " + entry.getValue());
          });
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
  kirjanpito.lisaa("Ada", 3);
  kirjanpito.lisaa("Ada", 4);
  kirjanpito.lisaa("Ada", 3);
  kirjanpito.lisaa("Ada", 3);

  kirjanpito.lisaa("Pekka", 4);
  kirjanpito.lisaa("Pekka", 4);

  kirjanpito.lisaa("Matti", 1);
  kirjanpito.lisaa("Matti", 2);

  kirjanpito.tulosta();
<% end %>

<% partial 'partials/sample_output' do %>
  Matti: [1, 2]
  Pekka: [4]
  Ada: [3, 4]
<% end %>

<p>
  Huomaamme että käyttäjien nimet eivät tulostu järjestyksessä. Tämä selittyy sillä että <code>HashMap</code>-tyyppisessä hajautustaulussa alkioiden tallennus tapahtuu <code>hashCode</code>-metodin palauttaman hajautusarvon perusteella. HashMap-hajautustaulu ei ota kantaa alkioiden järjestykseen.
</p>


<% partial 'partials/exercise', locals: { name: 'Usean käännöksen sanakirja' } do %>

  <p>
    Tehtävänäsi on toteuttaa pakkaukseen <code>sanakirja</code> luokka <code>OmaUseanKaannoksenSanakirja</code>, johon voidaan lisätä yksi tai useampi käännös jokaiselle sanalle. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>UseanKaannoksenSanakirja</code>, joka määrittelee seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(String sana, String kaannos)</code> lisää käännöksen sanalle säilyttäen vanhat käännökset</li>
    <li><code>public Set&lt;String&gt; kaanna(String sana)</code> palauttaa <code>Set</code>-rajapinnan toteuttavan olion, jossa on kaikki käännökset sanalle. Jos sanalle ei ole yhtäkään käännöstä, metodin tulee palauttaa Set-olio, jossa ei ole yhtäkään alkiota</li>
    <li><code>public void poista(String sana)</code> poistaa sanan ja sen kaikki käännökset sanakirjasta.</li>
  </ul>

  <p>
    Käännökset kannattanee lisätä <code>Map&lt;String, Set&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan.
  </p>

  <p>Rajapinta UseanKaannoksenSanakirja:</p>

  <% partial 'partials/code_highlight' do %>
    package sanakirja;

    import java.util.Set;

    public interface UseanKaannoksenSanakirja {
        void lisaa(String sana, String kaannos);
        Set&lt;String&gt; kaanna(String sana);
        void poista(String sana);
    }
  <% end %>

  <p>
    Esimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    UseanKaannoksenSanakirja sanakirja = new OmaUseanKaannoksenSanakirja();
    sanakirja.lisaa("kuusi", "six");
    sanakirja.lisaa("kuusi", "spruce");

    sanakirja.lisaa("pii", "silicon");
    sanakirja.lisaa("pii", "pi");

    System.out.println(sanakirja.kaanna("kuusi"));
    sanakirja.poista("pii");
    System.out.println(sanakirja.kaanna("pii"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    [six, spruce]
    []
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Duplikaattien poistaja' } do %>

  <p>
    Tehtävänäsi on toteuttaa pakkaukseen <code>tyokalut</code> luokka <code>OmaDuplikaattienPoistaja</code>, joka tallettaa annetut merkkijonot siten, että annetuista merkkijonoista poistetaan samanlaiset merkkijonot (eli duplikaatit). Lisäksi luokka pitää kirjaa duplikaattien määrästä. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>DuplikaattienPoistaja</code>, jossa on seuraavat toiminnot:
  </p>

  <ul>
    <li><code>public void lisaa(String merkkijono)</code></li> tallettaa merkkijonon, jos se ei ole duplikaatti<br/>
    <li><code>public int getHavaittujenDuplikaattienMaara()</code></li> palauttaa tähän mennessä havaittujen duplikaattien määrän<br/>
    <li><code>public Set&lt;String&gt; getUniikitMerkkijonot()</code></li> palauttaa <code>Set&lt;String&gt;</code>-rajapinnan toteuttavan olion, jossa on kaikki uniikit lisätyt merkkijonot (ei siis duplikaatteja!). Jos merkkijonoja ei ole, palautetaan tyhjä joukko-olio.<br/>
    <li><code>public void tyhjenna()</code></li> poistaa talletetut merkkijonot ja nollaa havaittujen duplikaattien määrän<br/>
  </ul>

  <p>
    Rajapinta:
  </p>

  <% partial 'partials/code_highlight' do %>
    package tyokalut;

    import java.util.Set;

    public interface DuplikaattienPoistaja {
        void lisaa(String merkkijono);
        int getHavaittujenDuplikaattienMaara();
        Set&lt;String&gt; getUniikitMerkkijonot();
        void tyhjenna();
    }
  <% end %>

  <p>
    Käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
        DuplikaattienPoistaja poistaja = new OmaDuplikaattienPoistaja();
        poistaja.lisaa("eka");
        poistaja.lisaa("toka");
        poistaja.lisaa("eka");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        poistaja.lisaa("vika");
        poistaja.lisaa("vika");
        poistaja.lisaa("uusi");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit merkkijonot: " +
            poistaja.getUniikitMerkkijonot());

        poistaja.tyhjenna();

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit merkkijonot: " +
            poistaja.getUniikitMerkkijonot());
    }
  <% end %>

  <p>
    Yllä oleva ohjelma tulostaisi esimerkiksi seuraavaa: (merkkijonojen järjestys saa vaihdella, sillä ei ole merkitystä)
  </p>

  <% partial 'partials/sample_output' do %>
    Duplikaattien määrä nyt: 1
    Duplikaattien määrä nyt: 2
    Uniikit merkkijonot: [eka, toka, vika, uusi]
    Duplikaattien määrä nyt: 0
    Uniikit merkkijonot: []
  <% end %>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Sama olio useammassa tietorakenteessa
<% end %>

<p>
  Oliot ovat viittaustyyppisiä, eli muuttuja ei tallenna olioa itseään vaan viitteen. Tämä tarkoittaa myös sitä, että jos olio lisätään esimerkiksi listaan, listalle lisätään viite olioon. Mikään ei estä lisäämästä saman olion viitettä useampaan paikkaan.
</p>

<p>
  Tarkastellaan esimerkkinä kirjastoa joka tallettaa kirjat hajautustauluihin sekä kirjailijan että kirjan isbn-numeron perusteella. Tämän lisäksi kirjasto pitää kirjaa lainassa olevista sekä hyllyssä olevista kirjoista erillisillä listoilla.</p>

<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private String ISBN;
      private String kirjailija;
      private String nimi;
      private int vuosi;
      // ...
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  public class Kirjasto {
      private Map&lt;String, Kirja&gt; kirjaIsbnNumeronPerusteella;
      private Map&lt;String, List&lt;Kirja&gt;&gt; kirjatKirjailijanPerusteella;
      private List&lt;Kirja&gt; lainassaOlevatKirjat;
      private List&lt;Kirja&gt; hyllyssaOlevatKirjat;

      public Kirjasto() {
          this.kirjaIsbnNumeronPerusteella = new HashMap&lt;&gt;();
          this.kirjatKirjailijanPerusteella = new HashMap&lt;&gt;();
          this.lainassaOlevatKirjat = new ArrayList&lt;&gt;();
          this.hyllyssaOlevatKirjat = new ArrayList&lt;&gt;();
      }

      public void lisaaKirjaKokoelmaan(Kirja uusiKirja) {
          this.kirjaIsbnNumeronPerusteella.put(uusiKirja.getIsbn(), uusiKirja);

          this.kirjatKirjailijanPerusteella.putIfAbsent(uusiKirja.getKirjailija(), new ArrayList&lt;&gt;());
          this.kirjatKirjailijanPerusteella.get(uusikirja.getKirjailija()).add(uusiKirja);

          this.hyllyssaOlevatKirjat.add(uusiKirja);
      }

      public Kirja haeKirjaIsbnNumeronPerusteella(String isbn){
          return kirjaIsbnNumeronPerusteella.get(isbn);
      }

      // ...
  }
<% end %>

<p>
  Jos olio on yhtäaikaa useassa kokoelmassa (listalla, joukossa tai map-rakenteessa), on kiinnitettävä erityistä huomiota, että kokoelmien tila on konsistentti. Jos esimerkiksi kirja päätetään poistaa, on se poistettava kaikista paikoista, missä kirjaan on viite.
</p>


<%= partial 'partials/quiz', locals: { id: '59fdcf1e7bced5000478810e' } %>


<% partial 'partials/exercise', locals: { name: 'Numerotiedustelu (5 osaa)' } do %>

  <p>
    <strong>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden syötteen lukemiseen tarkoitetun Scanner-olion.</strong>
  </p>

  <p>
    Tehdään sovellus jonka avulla on mahdollista hallinnoida ihmisten puhelinnumeroita ja osoitteita.
  </p>

  <p>
    Tehtävän voi suorittaa 1-5 pisteen laajuisena. Yhden pisteen laajuuteen on toteutettava seuraavat toiminnot:
  </p>

  <ul>
    <li>1 puhelinnumeron lisäys henkilölle</li>
    <li>2 henkilön puhelinnumeroiden haku</li>
  </ul>

  <p>
    kahteen pisteeseen vaaditaan edellisten lisäksi
  </p>

  <ul>
    <li>3 numeroa vastaavan henkilön nimen haku</li>
  </ul>

  <p>
    kolmeen pisteeseen vaaditaan edellisten lisäksi
  </p>

  <ul>
    <li>4 osoitteen lisäys henkilölle</li>
    <li>5 henkilön tietojen (osoite ja puhelinnumero) haku</li>
  </ul>

  <p>
    neljään pisteeseen vaaditaan toiminto
  </p>

  <ul>
    <li>6 henkilön tietojen poisto</li>
  </ul>

  <p>
    ja täysiin pisteeseen vaaditaan vielä
  </p>

  <ul>
    <li>7 hakusanalla filtteröity listaus (nimen mukaan aakkostettuna), hakusana voi esiintyä henkilön nimessä tai osoitteessa</li>
  </ul>

  <p>
    Esimerkki ohjelman toiminnasta:
  </p>

  <% partial 'partials/sample_output' do %>
numerotiedustelu
käytettävissä olevat komennot:
1 lisää numero
2 hae numerot
3 hae puhelinnumeroa vastaava henkilö
4 lisää osoite
5 hae henkilön tiedot
6 poista henkilön tiedot
7 filtteröity listaus
x lopeta

komento: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">040-123456</font>

komento: <font color="red">2</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

komento: <font color="red">2</font>
kenen: <font color="red">pekka</font>
    <font color="red">040-123456</font>

komento: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">09-222333</font>

komento: <font color="red">2</font>
kenen: <font color="red">pekka</font>
  040-123456
  09-222333

komento: <font color="red">3</font>
numero: <font color="red">02-444123</font>
  ei löytynyt

komento: <font color="red">3</font>
numero: <font color="red">09-222333</font>
  pekka

komento: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite ei tiedossa
  puhelinnumerot:
    040-123456
    09-222333

komento: <font color="red">4</font>
kenelle: <font color="red">pekka</font>
katu: <font color="red">ida ekmanintie</font>
kaupunki: <font color="red">helsinki</font>

komento: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
    040-123456
    09-222333

komento: <font color="red">4</font>
kenelle: <font color="red">jukka</font>
katu: <font color="red">korsontie</font>
kaupunki: <font color="red">vantaa</font>

komento: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  osoite: korsontie vantaa
  ei puhelinta

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">kk</font>

  jukka
    osoite: korsontie vantaa
    ei puhelinta

  pekka
    osoite: ida ekmanintie helsinki
    puhelinnumerot:
      040-123456
      09-222333

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">vantaa</font>

  jukka
    osoite: korsontie vantaa
    ei puhelinta

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">seppo</font>
  ei löytynyt

komento: <font color="red">6</font>
kenet: <font color="red">jukka</font>

komento: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

komento: <font color="red">x</font>
  <% end %>

  <p>
    Huomioita:
  </p>

  <ul>
    <li>Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii kuten yllä olevassa esimerkissä. Sovellus voi itse päättää kuinka epäkelvot syötteet käsitellään. Testit sisältävät vaan kelvollisia syötteitä.</li>
    <li><em><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan, tehtävässä saa luoda vain yhden Scanner-olion.</strong></em></li>
    <li>Älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</li>
    <li>Yksinkertaisuuden vuoksi oletetaan että nimi on yksittäinen merkkijono, eli jos halutaan sukunimen mukaan järjestetyn tulostus viimeiseen toimintoon, nimi on annettava muodossa <em>mikkola pekka</em>.</li>
    <li>Henkilöllä voi olla useita puhelinnumeroja sekä osoite. Henkilöllä ei kuitenkaan ole välttämättä yhtään puhelinnumeroa tai osoite ei ole tiedossa.</li>
    <li>Jos henkilö poistetaan, ei mikään haku saa enää palauttaa henkilön tietoja.</li>
  </ul>

<% end %>


<%= partial 'partials/quiz', locals: { id: '59fdcd007bced500047880fd' } %>

