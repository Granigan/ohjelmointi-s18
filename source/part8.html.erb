---
  title: Osa 8
  exercise_page: true
  quiz_page: true
  published: false
---


<p>
  <strong>
    <em>
      <p>
	Kahdeksas osa aloittaa Ohjelmoinnin jatkokurssin. Jos tulet tässä kohtaa mukaan, kannattaa käydä läpi edellisten osien materiaali. Jos teet kurssia Helsingin yliopistolla, joudut vaihtamaan kurssia TMC:stä. Katso ohjeet materiaalin Johdantosivulta.
      </p>
    </em>
  </strong>
</p>

<% partial 'partials/hint', locals: { name: 'Kahdeksannen osan tavoitteet' } do %>

  <p>
    Tuntee käsitteen object ja ymmärtää miksi jokaisella oliolla on metodi toString ja hashCode. Tietää joitakin käyttökohteita em. metodeille. Tuntee käsitteen rajapinta ja osaa luoda luokan, joka toteuttaa annetun rajapinnan. Osaa määritellä rajapinnan ja tietää, että eri luokista luodut oliot voivat toteuttaa saman rajapinnan. Ymmärtää käsitteen pakkaus ja osaa hyödyntää pakkauksia ohjelman rakenteen pilkkomisessa.
  </p>

<% end %>

<% partial 'partials/material_heading' do %>
  Ensiaskeleet automaattiseen testaamiseen
<% end %>

<p>
  Otetaan seuraavaksi ensiaskeleet ohjelmien testaamiseen.
</p>


<% partial 'partials/material_sub_heading' do %>
  Virhetilanteet ja ongelman ratkaiseminen askel kerrallaan
<% end %>

<p>
  Ohjelmia luodessa niihin päätyy virheitä. Joskus virheet eivät ole niin vakavia, ja aiheuttavat päänvaivaa lähinnä ohjelman käyttäjälle. Joskus toisaalta virheet voivat johtaa hyvinkin vakaviin seurauksiin. Varmaa on joka tapauksessa se, että ohjelmoimaan opetteleva ihminen tekee paljon virheitä.
</p>

<p>
  Virheitä ei kannata missään nimessä pelätä tai välttää, sillä virheitä tekemällä oppii parhaiten. Pyri siis myös välillä rikkomaan työstämääsi ohjelmaa, jolloin pääset tutkimaan virheilmoitusta ja tarkastelemaan kertooko virheilmoitus jotain tekemästäsi virheestä.
</p>

<% partial 'partials/hint', locals: { name: 'Ohjelmistovirhe' } do %>

  <p>
    Osoitteessa <a href="http://sunnyday.mit.edu/accidents/MCO_report.pdf" target="_blank">http://sunnyday.mit.edu/accidents/MCO_report.pdf</a> oleva raportti kuvaa erään hieman vakavamman ohjelmistovirheestä johtuneen tapaturman sekä ohjelmistovirheen.
  </p>

  <p>
    Ohjelmistovirhe liittyi siihen, että käytetty ohjelma odotti, että ohjelmoija käyttäisi <a href="https://fi.wikipedia.org/wiki/Kansainv%C3%A4linen_yksikk%C3%B6j%C3%A4rjestelm%C3%A4" target="_blank">kansainvälistä yksikköjärjestelmää</a> laskuissa (metrit, kilogrammat, ...). Ohjelmoija oli kuitenkin käyttänyt <a href="https://en.wikipedia.org/wiki/English_Engineering_units" target="_blank">amerikkalaista mittajärjestelmää</a> erään järjestelmän osan laskuissa, jolloin satelliitin navigointiin liittynyt automaattinen korjausjärjestelmä ei toiminut oikein.
  </p>

  <p>
    Satelliitti tuhoutui.
  </p>

<% end %>


<p>
  Ohjelmien muuttuessa monimutkaisemmiksi, tulee virheiden löytämisestäkin haastavampaa. NetBeansiin integroitu debuggeri voi olla avuksi virheiden löytämisessä. Debuggerin käyttöä on esitelty kurssimateriaaliin upotetuilla videoilla; alla oleva video esittelee myös miten projekteja voidaan luoda, avata ja sulkea sekä miten ohjelmia voidaan suorittaa NetBeansin ulkopuolella. Screencastissa on myös asioita, joita kurssilla ei vielä ole tullut -- älä huoli, nämä tulevat vastaan opintojen edetessä.
</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=2QlbAvDPmk8" class="youtube" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<% partial 'partials/material_sub_heading' do %>
  Stack trace
<% end %>

<p>
  Kun ohjelmassa tapahtuu virhe, ohjelma tyypillisesti tulostaa ns. stack tracen, eli niiden metodikutsujen listan, joiden seurauksena virhetilanne syntyi. Stack trace voi näyttää esimerkiksi seuraavalta:
</p>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" ...
  at Ohjelma.main(Ohjelma.java:15)
<% end %>

<p>
  Listan alussa kerrotaan minkälainen virhe tapahtui (tässä ...), ja seuraavalla rivillä kerrotaan missä virhe tapahtui. Rivi "at Ohjelma.main(Ohjelma.java:15)" sanoo, että virhe tapahtui Ohjelma.java-tiedoston rivillä 15.
</p>

<% partial 'partials/sample_output' do %>
  at Ohjelma.main(Ohjelma.java:15)
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Muistilista virheenselvitykseen
<% end %>

<p>
  Jos koodisi ei toimi etkä tiedä missä on virhe, näillä askeleilla pääset alkuun.
</p>

<ol>
  <li>Sisennä koodisi oikein ja selvitä, puuttuuko sulkuja.</li>
  <li>Tarkista ovatko käytetyt muuttujat oikean nimisiä.</li>
  <li>Testaa ohjelman kulkua erilaisilla syötteillä, ja selvitä minkälaisella syötteellä ohjelma ei toimi halutusti. Jos sait virheen testeistä, testit saattavat myös kertoa käytetyn syötteen.</li>
  <li>Lisää ohjelmaan tulostuskomentoja, joissa tulostat käytettävien muuttujien arvoja ohjelman suorituksen eri vaiheissa.</li>
  <li>Tarkista, että kaikki käyttämäsi muuttujat on alustettu. Jos tätä ei ole tehty, seuraa virhe NullPointerException.</li>
  <li>Jos ohjelmasi aiheuttaa poikkeuksen, kannattaa ehdottomasti kiinnittää huomiota poikkeuksen yhteydessä olevaan <em>stack traceen</em>, eli niiden metodikutsujen listaan, minkä seurauksena poikkeuksen aiheuttanut tilanne syntyi.</li>
  <li>Opettele käyttämään debuggeria, aiemmin nähdyllä videolla pääsee alkuun.</li>
</ol>


<% partial 'partials/material_sub_heading' do %>
  Testisyötteen antaminen Scannerille
<% end %>

<p>
  Ohjelman testaaminen käsin on usein työlästä. Syötteen antaminen on mahdollista automatisoida esimerkiksi syöttämällä Scanner-oliolle luettava merkkijono. Alla on annettu esimerkki siitä, miten ohjelmaa voi testata automaattisesti. Ohjelmassa syötetään ensin viisi merkkijonoa, jonka jälkeen syötetään aiemmin nähty merkkijono. Tämän jälkeen yritetään syöttää vielä uusi merkkijono. Merkkijonoa "kuusi" ei pitäisi esiintyä sanajoukossa.
</p>

<p>
  Testisyötteen voi antaa merkkijonona Scanner-oliolle konstruktorissa. Jokainen testisyötteessä annettava rivinvaihto merkitään merkkijonoon kenoviivan ja n-merkin yhdistelmänä "\n".
</p>

<% partial 'partials/code_highlight' do %>
  String syote = "yksi\n" + "kaksi\n"  +
  "kolme\n" + "nelja\n" +
  "viisi\n" + "yksi\n"  +
  "kuusi\n";

  Scanner lukija = new Scanner(syote);

  ArrayList&lt;String&gt; luetut = new ArrayList&lt;&gt;();
  while (true) {
  System.out.println("Anna syote: ");
  String rivi = lukija.nextLine();
  if (luetut.contains(rivi)) {
  break;
  }

  luettu.add(rivi);
  }

  System.out.println("Kiitos!");

  if (luetut.sisaltaa("kuusi")) {
  System.out.println("Joukkoon lisättiin arvo, jota sinne ei olisi pitänyt lisätä.");
  }
<% end %>

<p>
  Ohjelma tulostus näyttää vain ohjelman antaman tulostuksen, ei käyttäjän tekemiä komentoja.
</p>

<% partial 'partials/sample_output' do %>
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Kiitos!
<% end %>

<p>
  Merkkijonon antaminen Scanner-luokan konstruktorille korvaa näppäimistöltä luettavan syötteen. Merkkijonomuuttujan <code>syote</code> sisältö siis "simuloi" käyttäjän antamaa syötettä. Rivinvaihto syötteeseen merkitään <code>\n</code>:llä. Jokainen yksittäinen rivinvaihtomerkkiin loppuva osa syote-merkkijonossa siis vastaa yhtä nextLine()-komentoon annettua syötettä.
</p>

<p>
  Kun haluat testata ohjelmasi toimintaa jälleen käsin, vaihda Scanner-olion konstruktorin parametriksi <code>System.in</code>, eli järjestelmän syötevirta. Voit toisaalta halutessasi myös vaihtaa testisyötettä, sillä kyse on merkkijonosta.
</p>

<p>
  Ohjelman toiminnan oikeellisuus tulee edelleen tarkastaa ruudulta. Tulostus voi olla aluksi hieman hämmentävää, sillä automatisoitu syöte ei näy ruudulla ollenkaan. Lopullinen tavoite on automatisoida myös ohjelman tulostuksen oikeellisuden tarkastaminen niin hyvin, että ohjelman testaus ja testituloksen analysointi onnistuu "nappia painamalla". Palaamme aiheeseen myöhemmissä osissa.
</p>


<% partial 'partials/exercise', locals: { name: 'Debuggailua' } do %>

  <p>
    Ohjelmassa on yritetty luoda sovellus, joka kysyy käyttäjältä merkkijonoa ja lukua. Sovelluksen pitäisi toimia esimerkiksi seuraavasti:
  </p>

  <% partial 'partials/sample_output' do %>
    Sana:
    <font color="red">testi</font>
    Luku:
    <font color="red">3</font>
    t
    e
    s
    t
    i
  <% end %>

  <p>
    Esimerkki 2:
  </p>

  <% partial 'partials/sample_output' do %>
    Sana:
    <font color="red">esim</font>
    Luku:
    <font color="red">2</font>
    e
    s
    i
    m
  <% end %>

  <p>
    Tällä hetkellä ohjelma ei kuitenkaan toimi halutusti. Ota selvää miksi ja korjaa ohjelma. Huomaat myös, että ohjelmassa käytetään paljon omituisia asioita, jotka eivät ole tulleet vielä kurssilla tutuksi. Kannattaakin tehdä niin, että kokeilee myös näitä uusia asioita erikseen.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Yksikkötestaus
<% end %>

<p>
  Edellä esitetty menetelmä automaattiseen testaamiseen missä ohjelmalle syötetyt syötteet muutetaan on varsin kätevä, mutta kuitenkin melko rajoittunut. Isompien ohjelmien testaaminen edellä kuvatulla tavalla on haastavaa. Eräs ratkaisu tähän on yksikkötestaus, missä ohjelman pieniä osia testataan erikseen.
</p>

<p>
  Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien kuten luokkien ja niiden tarjoamien metodien testaamista.  Luokkien ja metodien rakenteen suunnittelussa käytettävän ohjesäännön -- jokaisella metodilla ja luokalla tulee olla yksi selkeä vastuu -- noudattamisen tai siitä poikkeamisen huomaa testejä kirjoittaessa. Mitä useampi vastuu metodilla on, sitä monimutkaisempi testi on. Jos laaja sovellus on kirjoitettu yksittäiseen metodiin, on testien kirjoittaminen sitä varten erittäin haastavaa ellei jopa mahdotonta. Vastaavasti, jos sovellus on pilkottu selkeisiin luokkiin ja metodeihin, on testienkin kirjoittaminen suoraviivaista.
</p>

<p>
  Testien kirjoittamisessa hyödynnetään tyypillisesti valmiita yksikkötestauskirjastoja, jotka tarjoavat metodeja ja apuluokkia testien kirjoittamiseen. Javassa käytetyin yksikkötestauskirjasto on <a href="http://junit.org/" target="_blank" rel="noopener">JUnit</a>, johon löytyy myös tuki lähes kaikista ohjelmointiympäristöistä. Esimerkiksi NetBeans osaa automaattisesti etsiä JUnit-testejä projektista -- jos testejä löytyy, ne näytetään projektin alla Test Packages -kansiossa.
</p>

<p>
  Tarkastellaan yksikkötestien kirjoittamista esimerkin kautta. Oletetaan, että käytössämme on seuraava luokka Laskin, ja haluamme kirjoittaa sitä varten automaattisia testejä.
</p>


<% partial 'partials/code_highlight' do %>
  public class Laskin {

  private int arvo;

  public Laskin() {
  this.arvo = 0;
  }

  public void summa(int luku) {
  this.arvo += luku;
  }

  public void erotus(int luku) {
  this.arvo += luku;
  }

  public int getArvo() {
  return this.arvo;
  }
  }
<% end %>

<p>
  Laskimen toiminta perustuu siihen, että se muistaa aina edellisen laskuoperaation tuottaman tuloksen. Seuraavat laskuoperaatiot lisätään aina edelliseen lopputulokseen. Yllä olevaan laskimeen on jäänyt myös pieni copy-paste -ohjelmoinnista johtuva virhe. Metodin erotus pitäisi vähentää arvosta, mutta nyt se lisää arvoon.
</p>

<p>
  Yksikkötestien kirjoittaminen aloitetaan testiluokan luomisella. Testiluokka luodaan Test Packages -kansion alle. Kun testaamme luokkaa <code>Laskin</code>, testiluokan nimeksi tulee <code>LaskinTest</code>. Nimen lopussa oleva merkkijono <code>Test</code> kertoo ohjelmointiympäristölle, että kyseessä on testiluokka. Ilman merkkijonoa Test luokassa olevia testejä ei suoriteta. (Huom! Testit luodaan NetBeansissa Test Packages -kansion alle.)
</p>

<p>
  Testiluokka LaskinTest on aluksi tyhjä.
</p>


<% partial 'partials/code_highlight' do %>
  public class LaskinTest {

  }
<% end %>

<p>
  Testit ovat testiluokassa olevia metodeja ja jokainen testi testaa yksittäistä asiaa. Aloitetaan luokan Laskin testaaminen -- luodaan ensin testimetodi, jossa varmistetaan, että juuri luodun laskimen sisältämä arvo on 0.
</p>

<% partial 'partials/code_highlight' do %>

  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class LaskinTest {

  @Test
  public void laskimenArvoAlussaNolla() {
  Laskin laskin = new Laskin();
  assertEquals(0, laskin.getArvo());
  }
  }
<% end %>

<p>
  Yllä olevassa metodissa laskimenArvoAlussaNolla luodaan ensin laskinolio. Tämän jälkeen käytetään JUnit-testikehyksen tarjoamaa assertEquals-metodia arvon tarkistamiseen. Metodi tuodaan luokasta Assert komennolla import static, ja sille annetaan parametrina odotettu arvo -- tässä 0 -- sekä laskimen palauttama arvo. Jos metodin assertEquals arvot poikkeavat toisistaan, testin suoritus ei pääty hyväksytysti. Jokaisella testimetodilla tulee olla <em>annotaatio</em> @Test -- tämä kertoo JUnit-testikehykselle, että kyseessä on suoritettava testimetodi.
</p>

<p>
  Testien suorittaminen onnistuu valitsemalla projekti oikealla hiirennapilla ja klikkaamalla vaihtoehtoa Test.
</p>

<p>
  Testien suorittaminen luo output-välilehdelle (tyypillisesti NetBeansin alalaidassa) tulosteen, jossa on testiluokkakohtaiset tilastot. Alla olevassa esimerkissä on suoritettu pakkauksessa laskin olevan testiluokan LaskinTest testit. Testejä suoritettiin 1, joista yksikään ei epäonnistunut -- epäonnistuminen tarkoittaa tässä sitä, että testin testaama toiminnallisuus ei toiminut oletetusti.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.054 sec

  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>

<p>
  Lisätään testiluokkaan summaa ja erotusta lisäävää toiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  package laskin;

  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class LaskinTest {

  @Test
  public void laskimenArvoAlussaNolla() {
  Laskin laskin = new Laskin();
  assertEquals(0, laskin.getArvo());
  }

  @Test
  public void arvoViisiKunSummataanViisi() {
  Laskin laskin = new Laskin();
  laskin.summa(5);
  assertEquals(5, laskin.getArvo());
  }

  @Test
  public void arvoMiinusKaksiKunErotetaanKaksi() {
  Laskin laskin = new Laskin();
  laskin.erotus(2);
  assertEquals(-2, laskin.getArvo());
  }
  }
<% end %>

<p>
  Testien suorittaminen antaa seuraavanlaisen tulostuksen.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 3, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.059 sec

  Testcase: arvoMiinusKaksiKunErotetaanKaksi(LaskinTest):	FAILED
  expected:<-2> but was:<2>
  junit.framework.AssertionFailedError: expected:<-2> but was:<2>
  at LaskinTest.arvoMiinusKaksiKunErotetaanKaksi(LaskinTest.java:25)


  Test LaskinTest FAILED
  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>

<p>
  Tulostus kertoo, että kolme testiä suoritettiin. Yksi niistä päätyi virheeseen. Testitulostuksessa on tieto myös testin rivistä, jossa virhe tapahtui (25) sekä tieto odotetusta (-2) ja saadusta arvosta (2). Kun testien suoritus päättyy virheeseen, NetBeans näyttää testien suoritukseen liitttyvän virhetilanteen myös visuaalisena.
</p>

<p>
  Edellisillä testeillä kaksi testeistä menee läpi, mutta yhdessä on tapahtunut virhe. Korjataan luokkaan Laskin jäänyt virhe.
</p>

<% partial 'partials/code_highlight' do %>
  // ...
  public void erotus(int luku) {
  this.arvo -= luku;
  }
  // ...
<% end %>

<p>
  Kun testit suoritetaan uudestaan, testit menevät läpi.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.056 sec

  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>


<% partial 'partials/exercise', locals: { name: 'Laskimen testailua' } do %>

  <p>
    Tehtäväpohjassa tulee edellisen esimerkin alkutilanne. Seuraa edellistä esimerkkiä, ja luo laskimelle esimerkissä näytetyt testit. Kokeile testien toimintaa, ja palauta lopulta tehtävä Test My Code-palvelimelle.
  </p>

<% end %>


<% partial 'partials/material_heading' do %>
  Lista arvojen virtana
<% end %>

<p>
  Tutustutaan listan läpikäyntiin arvojen virtana (stream). Virta on menetelmä tietoa sisältävän kokoelman läpikäyntiin siten, että ohjelmoija määrittelee kullekin listan arvolle suoritettavan toiminnallisuuden. Indeksistä tai kullakin hetkellä käsiteltävästä muuttujasta ei pidetä kirjaa.
</p>

<p>
  Virran avulla ohjelmoija määrittelee funktioketjun, joita kutsutaan tietokokoelman arvoille. Virran avulla voi muuntaa tietoa muodosta toiseen, mutta virta ei muuta alkuperäisen tietokokoelman arvoja.
</p>

<p>
  Tutustutaan virran käyttöön konkreettisen esimerkin kautta. Tarkastellaan seuraavaa ongelmaa:
</p>

<p>
  <em>
    Kirjoita ohjelma, joka lukee käyttäjältä syötteitä ja tulostaa niihin liittyen tilastoja. Kun käyttäjä syöttää merkkijonon "loppu", lukeminen lopetetaan. Muut syötteet ovat lukuja. Kun syötteiden lukeminen lopetetaan, ohjelma tulostaa kolmella jaollisten positiivisten lukujen lukumäärän sekä kaikkien lukujen keskiarvon.
  </em>
</p>

<% partial 'partials/code_highlight' do %>
  // alustetaan lukija ja lista, johon syotteet luetaan
  Scanner lukija = new Scanner(System.in);
  ArrayList&lt;String&gt; syotteet = new ArrayList&lt;&gt;();

  // luetaan syotteet
  while (true) {
  String rivi = lukija.nextLine();
  if (rivi.equals("loppu")) {
  break;
  }
  
  syotteet.add(rivi);
  }

  // selvitetään kolmella jaollisten lukumaara
  long kolmellaJaollistenLukumaara = syotteet.stream()
  .mapToInt(s -&gt; Integer.parseInt(s))
  .filter(luku -&gt; luku % 3 == 0)
  .count();

  // selvitetään keskiarvo
  double keskiarvo = syotteet.stream()
  .mapToInt(s -&gt; Integer.parseInt(s))
  .average()
  .getAsDouble();

  // tulostetaan tilastot
  System.out.println("Kolmella jaollisia: " + kolmellaJaollistenLukumaara);
  System.out.println("Lukujen keskiarvo: " + keskiarvo);
<% end %>

<p>
  Tarkastellaan tarkemmin yllä kuvatun ohjelman osaa, missä luettuja syötteitä käsitellään virtana. 
</p>

<% partial 'partials/code_highlight' do %>
  // selvitetään kolmella jaollisten lukumaara
  long kolmellaJaollistenLukumaara = syotteet.stream()
  .mapToInt(s -&gt; Integer.parseInt(s))
  .filter(luku -&gt; luku % 3 == 0)
  .count();
<% end %>

<p>
  Virta luodaan ArrayList-oliosta metodilla <code>stream()</code>. Tämän jälkeen merkkijonomuotoiset arvot muunnetaan kokonaislukumuotoon virran metodilla <code>mapToInt(arvo -&gt; muunnos)</code> -- muunto toteutetaan Integer-luokan tarjoamalla parseInt-metodilla, jota olemme käyttäneet aiemminkin. Seuraavaksi rajaamme metodilla <code>filter(arvo -&gt; rajausehto)</code> käsiteltäväksi vain ne luvut, jotka ovat kolmella jaollisia. Lopulta kutsumme virran metodia <code>count()</code>, joka laskee virran alkioiden lukumäärän ja palauttaa sen <code>long</code>-tyyppisenä muuttujana.
</p>

<p>
  Tarkastellaan tämän jälkeen listan alkioiden keskiarvon laskemiseen tarkoitettua ohjelmaa.
</p>

<% partial 'partials/code_highlight' do %>
  // selvitetään keskiarvo
  double keskiarvo = syotteet.stream()
  .mapToInt(s -&gt; Integer.parseInt(s))
  .average()
  .getAsDouble();
<% end %>

<p>
  Keskiarvon laskeminen onnistuu virrasta, jolle on kutsuttu <code>mapToInt</code>-metodia. Kokonaislukuja sisältävällä virralla on metodi <code>average()</code>, joka palauttaa <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html" target="_blank" norel>OptionalDouble</a>-tyyppisen olion. Oliolla on metodi <code>getAsDouble()</code>, joka palauttaa listan arvojen keskiarvon <code>double</code>-tyyppisenä muuttujana.
</p>

<p>
  Lyhyt yhteenveto tähän mennessä tutuiksi tulleista virtaan liittyvistä metodeista.
</p>

<table class="table">
  <tr>
    <th>
      Tarkoitus ja metodi
    </th>
    <th>
      Oletukset
    </th>
  </tr>

  <tr>
    <td>
      Virran luominen: <code>stream()</code>
    </td>
    <td>
      Metodia kutsutaan kokoelmalle kuten ArrayList-oliolle. Luotavalle virralle tehdään jotain.
    </td>
  </tr>

  <tr>
    <td>
      Virran muuntaminen kokonaislukuvirraksi: <code>mapToInt(arvo -&gt; toinen)</code>
    </td>
    <td>
      Virta muuntuu kokonaislukuja sisältäväksi virraksi. Merkkijonoja sisältävä muunnos voidaan tehdä esimerkiksi Integer-luokan parseInt-metodin avulla. Kokonaislukuja sisältävälle virralle tehdään jotain.
    </td>
  </tr>

  <tr>
    <td>
      Arvojen rajaaminen: <code>filter(arvo -&gt; hyvaksymisehto)</code>
    </td>
    <td>
      Virrasta rajataan pois ne arvot, jotka eivät täytä hyväksymisehtoa. "Nuolen" oikealla puolella on lauseke, joka palauttaa totuusarvon. Jos totuusarvo on <code>true</code>, arvo hyväksytään virtaan. Jos totuusarvo on <code>false</code>, arvoa ei hyväksytä virtaan. Rajatuille arvoille tehdään jotain.
    </td>
  </tr>
  
  <tr>
    <td>
      Keskiarvon laskeminen: <code>average()</code>
    </td>
    <td>
      Palauttaa OptionalDouble-tyyppisen olion, jolla on <code>double</code> tyyppisen arvon palauttava metodi <code>getAsDouble()</code>. Metodin <code>average()</code> kutsuminen onnistuu kokonaislukuja sisältävälle virralle (luominen onnistuu <code>mapToInt</code>-metodilla.
    </td>
  </tr>

  <tr>
    <td>
      Virrassa olevien alkioiden lukumaara: <code>count()</code>
    </td>
    <td>
      Palauttaa virrassa olevien alkioiden lukumäärän <code>long</code>-tyyppisenä arvona.
    </td>
  </tr>
  
</table>

<% partial 'partials/exercise', locals: { name: 'Lukujen keskiarvo' } do %>

  <p>
    Harjoitellaan lukujen lukemista listalle sekä listan arvojen keskiarvon laskemista virran avulla.
  </p>

  <p>
    Toteuta ohjelma, joka lukee käyttäjältä syötteitä. Jos käyttäjä syöttää merkkijonon "loppu", lukeminen lopetetaan. Muut syötteet ovat lukuja. Kun käyttäjä syöttää merkkijonon "loppu", ohjelman tulee tulostaa syötettyjen lukujen keskiarvo.
  </p>


  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">2</font>
    <font color="red">4</font>
    <font color="red">6</font>
    <font color="red">loppu</font>
    Lukujen keskiarvo: 4.0
  <% end %>
  

  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">-1</font>
    <font color="red">1</font>
    <font color="red">2</font>
    <font color="red">loppu</font>
    Lukujen keskiarvo: 0.6666666666666666
  <% end %>
  
<% end %>

<% partial 'partials/exercise', locals: { name: 'Tiettyjen lukujen keskiarvo' } do %>

  <p>
    Harjoitellaan lukujen lukemista listalle sekä listan arvojen rajaamista virran avulla.
  </p>

  <p>
    Toteuta ohjelma, joka lukee käyttäjältä syötteitä. Jos käyttäjä syöttää merkkijonon "loppu", lukeminen lopetetaan. Muut syötteet ovat lukuja. Kun käyttäjä syöttää merkkijonon "loppu", syötteiden lukeminen lopetetaan.
  </p>

  <p>
    Tämän jälkeen käyttäjältä kysytään tulostetaanko negatiivisten vai positiivisten lukujen keskiarvo (n vai p). Jos käyttäjä syöttää merkkijonon "n", tulostetaan negatiivisten lukujen keskiarvo, muulloin tulostetaan positiivisten lukujen keskiarvo.
  </p>


  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">-1</font>
    <font color="red">1</font>
    <font color="red">2</font>
    <font color="red">loppu</font>
    
    Tulostetaanko negatiivisten vai positiivisten lukujen keskiarvo? (n/p)
    <font color="red">n</font>
    Negatiivisten lukujen keskiarvo: -1.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kirjoita syötteitä, "loppu" lopettaa.
    <font color="red">-1</font>
    <font color="red">1</font>
    <font color="red">2</font>
    <font color="red">loppu</font>
    
    Tulostetaanko negatiivisten vai positiivisten lukujen keskiarvo? (n/p)
    <font color="red">p</font>
    Positiivisten lukujen keskiarvo: 1.5
  <% end %>
  
<% end %>


<% partial 'partials/hint', locals: { name: 'Mikä ihmeen <code>x -&gt; ???</code>' } do %>

  <p>
    Virran arvoja käsitellään virtaan liittyvillä metodeilla. Arvoja käsittelevät metodit saavat parametrinaan funktion, joka kertoo mitä kullekin arvolle tulee tehdä. Funktion toiminnallisuus on metodikohtaista: rajaamiseen käytetylle metodille <code>filter</code> annetaan funktio, joka palauttaa totuusarvoisen muuttujan arvon <code>true</code> tai <code>false</code>, riippuen halutaanko arvo säilyttää virrassa; muuntamiseen käytetylle metodille <code>mapToInt</code> annetaan funktio, joka muuntaa arvon kokonaisluvuksi, jne.
  </p>

  <p>
    Miksi funktiot kirjoitetaan muodossa <code>luku -&gt; luku &gt; 5</code>?
  </p>

  <p>
    Kyseinen kirjoitusmuoto on Javan tarjoama lyhenne. Saman funktion voi kirjoittaa useammalla eri tavalla -- funktio sisältää sekä funktion parametrien määrittelyn että funktion rungon. Saman voi kirjoittaa useammassa muodossa, kts. alla.
  </p>

  <% partial 'partials/code_highlight' do %>
    // alkuperäinen
    .filter(luku -&gt; luku &gt; 5)

    // on sama kuin
    .filter((Integer luku) -&gt; 
    if (luku &gt; 5) {
    return true;
    }
    
    return false;
    })
  <% end %>

  <p>
    Käytännössä kyseessä on ns. anonyymi funktio. Saman voi kirjoittaa myös eksplisiittisesti niin, että ohjelmaan määrittelee staattisen metodin, jota kutsutaan virran metodista. Tämä tapahtuisi seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Rajaajat {
    public static boolean vitostaSuurempi(int luku) {
    return luku &gt; 5;
    }
    }

  <% end %>  

  <% partial 'partials/code_highlight' do %>
    // alkuperäinen
    .filter(luku -&gt; luku &gt; 5)

    // on sama kuin
    .filter(luku -&gt; Rajaajat.vitostaSuurempi(luku))
    
    // on sama kuin
    .filter(Rajaajat::vitostaSuurempi);
  <% end %>

  <p>
    Virran arvoja käsittelevät funktiot eivät voi muuttaa funktion ulkopuolisten muuttujien arvoja. Kyse on käytännössä lähes samasta kuin metodeja kutsuessa -- metodia kutsuttaessa metodin ulkopuolisiin muuttujiin ei pääse käsiksi. Funktioiden tilanteessa funktion ulkopuolisten muuttujien arvoja voi lukea olettaen, että luettavien muuttujien arvot eivät muutu lainkaan ohjelmassa.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Virran metodit
<% end %>

<p>
  Virran metodit voi jakaa karkeasti kahteen eri ryhmään: virran (1) arvojen käsittelyyn tarkoitettuihin välioperaatioihin sekä (2) käsittelyn lopettaviin pääteoperaatiohin. Edellisessä esimerkissä nähdyt metodit <code>filter</code> ja <code>mapToInt</code> ovat välioperaatioita. Välioperaatiot palauttavat arvonaan virran, jonka käsittelyä voi jatkaa -- käytännössä välioperaatioita voi olla käytännössä ääretön määrä ketjutettuna peräkkäin (pisteellä eroteltuna). Toisaalta edellisessä esimerkissä nähty metodi <code>average</code> on pääteoperaatio. Pääteoperaatio palauttaa käsiteltävän arvon, joka luodaan esimerkiksi virran arvoista.
</p>

<p>
  Alla olevassa kuvassa on kuvattu virran toimintaa. Lähtötilanteena (1) on lista, jossa on arvoja. Kun listalle kutsutaan <code>stream()</code>-metodia, (2) luodaan virta listan arvoista. Arvoja käsitellään tämän jälkeen yksitellen. Virran arvoja voidaan (3) rajata metodilla <code>filter</code>. Tämä poistaa virrasta ne arvot, jotka ovat rajauksen ulkopuolella. Virran metodilla <code>map</code> voidaan (4) muuntaa virrassa olevia arvoja muodosta toiseen. Metodi <code>collect</code> (5) kerää virrassa olevat arvot arvot sille annettuun kokoelmaan, esim. listalle.
</p>

<img src="/img/drawings/stream.png" alt="Yllä tekstuaalisesti kuvattu virran toiminta kuvana." />

<p>&nbsp;</p>

<p>
  Alla vielä yllä olevan kuvan kuvaama esimerkki ohjelmakoodina.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; lista = new ArrayList&lt;&gt;();
  lista.add(3);
  lista.add(7);
  lista.add(4);
  lista.add(2);
  lista.add(6);

  ArrayList&lt;Integer&gt; luvut = lista.stream()
  .filter(luku -&gt; luku &gt; 5)
  .map(luku -&gt; luku * 2)
  .collect(Collectors.toCollection(ArrayList::new));
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Pääteoperaatiot
<% end %>

<p>
  Tarkastellaan tässä kolmea pääteoperaatiota: listan arvojen lukumäärän selvittämistä <code>count</code>-metodin avulla, listan arvojen läpikäyntiä <code>forEach</code>-metodin avulla sekä listan arvojen keräämistä tietorakenteeseen <code>collect</code>-metodin avulla.
</p>

<p>
  Metodi <code>count</code> kertoo virran alkioiden lukumäärän <code>long</code>-tyyppisenä muuttujana.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(3);
  luvut.add(2);
  luvut.add(17);
  luvut.add(6);
  luvut.add(8);

  System.out.println("Lukuja: " + luvut.stream().count());
<% end %>

<% partial 'partials/sample_output' do %>
  Lukuja: 5
<% end %>


<p>
  Metodi <code>forEach</code> kertoo mitä kullekin listan arvolle tulee tehdä ja samalla päättää virran käsittelyn. Alla olevassa esimerkissä luodaan ensin numeroita sisältävä lista, jonka jälkeen tulostetaan vain kahdella jaolliset luvut.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(3);
  luvut.add(2);
  luvut.add(17);
  luvut.add(6);
  luvut.add(8);

  luvut.stream()
  .filter(luku -&gt; luku % 2 == 0)
  .forEach(luku -&gt; System.out.println(luku));
<% end %>

<% partial 'partials/sample_output' do %>
  2
  6
  8
<% end %>


<p>
  Virran arvojen kerääminen toiseen kokoelmaan onnistuu metodin <code>collect</code> avulla. Alla olevassa esimerkissä luodaan uusi lista annetun positiivisista arvoista.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(3);
  luvut.add(2);
  luvut.add(-17);
  luvut.add(-6);
  luvut.add(8);

  ArrayList&lt;Integer&gt; positiiviset = luvut.stream()
  .filter(luku -&gt; luku > 0)
  .collect(Collectors.toCollection(ArrayList::new));

  positiiviset.stream()
  .forEach(luku -&gt; System.out.println(luku));
<% end %>

<% partial 'partials/sample_output' do %>
  3
  2
  8
<% end %>



<% partial 'partials/exercise', locals: { name: 'Jaolliset' } do %>

  <p>
    Tehtävässä harjoitellaan virran <code>filter</code> ja <code>collect</code>-metodien käyttöä.
  </p>

  <p>
    Tehtäväpohjassa on annettuna metodirunko <code>public static ArrayList&lt;Integer&gt jaolliset(ArrayList&lt;Integer&gt; luvut)</code>. Toteuta metodirunkoon toiminnallisuus, kerää parametrina saadulta listalta kahdella, kolmella tai viidellä jaolliset luvut, ja palauttaa ne uudessa listassa. Metodille parametrina annetun listan ei tule muuttua.
  </p>
  
  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
    luvut.add(3);
    luvut.add(2);
    luvut.add(-17);
    luvut.add(-5);
    luvut.add(7);
    
    ArrayList&lt;Integer&gt; jaolliset = jaolliset(luvut);

    jaolliset.stream()
    .forEach(luku -&gt; System.out.println(luku));
  <% end %>

  
  <% partial 'partials/sample_output' do %>
    3
    2
    -5
  <% end %>  

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Välioperaatiot
<% end %>

<p>
  Virran välioperaatiot ovat metodeja, jotka palauttavat arvonaan virran. Koska palautettava arvo on virta, voidaan välioperaatioita kutsua peräkkäin. Tyypillisiä välioperaatioita ovat arvon muuntaminen muodosta toiseen <code>map</code> sekä sen erityistapaus <code>mapToInt</code>, arvojen rajaaminen <code>filter</code>, uniikkien arvojen tunnistaminen <code>distinct</code> sekä arvojen järjestäminen <code>sorted</code> (mikäli mahdollista).
</p>

<p>
  Tarkastellaan näitä metodeja muutaman ongelman avulla. Oletetaan, että käytössämme on seuraava luokka Henkilo.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
  private String etunimi;
  private String sukunimi;
  private int syntymavuosi;

  public Henkilo(String etunimi, String sukunimi, int syntymavuosi) {
  this.etunimi = etunimi;
  this.sukunimi = sukunimi;
  this.syntymavuosi = syntymavuosi;
  }

  public String getEtunimi() {
  return this.etunimi;
  }

  public String getSukunimi() {
  return this.sukunimi;
  }

  public int getSyntymavuosi() {
  return this.syntymavuosi;
  }
  }
<% end %>


<p>
  <em>
    Ongelma 1: Saat käyttöösi listan henkilöitä. Tulosta ennen vuotta 1970 syntyneiden henkilöiden lukumäärä.
  </em>
</p>

<p>
  Käytetään <code>filter</code>-metodia henkilöiden rajaamiseen niihin, jotka ovat syntyneet ennen vuotta 1970. Lasketaan tämän jälkeen henkilöiden lukumäärä metodilla <code>count</code>.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista henkiloita
  // ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  long lkm = henkilot.stream()
  .filter(henkilo -&gt; henkilo.getSyntymavuosi() &lt; 1970)
  .count();
  System.out.println("Lukumäärä: " + lkm);
<% end %>


<p>
  <em>
    Ongelma 2: Saat käyttöösi listan henkilöitä. Kuinka monen henkilön etunimi alkaa kirjaimella "A"?
  </em>
</p>

<p>
  Käytetään <code>filter</code>-metodia henkilöiden rajaamiseen niihin, joiden etunimi alkaa kirjaimella "A". Lasketaan tämän jälkeen henkilöiden lukumäärä metodilla <code>count</code>.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista henkiloita
  // ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  long lkm = henkilot.stream()
  .filter(henkilo -&gt; henkilo.getEtunimi().startsWith("A"))
  .count();
  System.out.println("Lukumäärä: " + lkm);
<% end %>

<p>
  <em>
    Ongelma 3: Saat käyttöösi listan henkilöitä. Tulosta henkilöiden uniikit etunimet aakkosjärjestyksessä.
  </em>
</p>

<p>
  Käytetään ensin <code>map</code>-metodia, jonka avulla henkilö-olioita sisältävä virta muunnetaan etunimiä sisältäväksi virraksi. Tämän jälkeen kutsutaan metodia <code>distinct</code>, joka palauttaa virran, jossa on uniikit arvot. Seuraavaksi kutsutaan metodia <code>sorted</code>, joka järjestää merkkijonot. Lopulta kutsutaan metodia <code>forEach</code>, jonka avulla tulostetaan merkkijonot.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista henkiloita
  // ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  henkilot.stream()
  .map(henkilo -&gt; henkilo.getEtunimi())
  .distinct()
  .sorted()
  .forEach(nimi -&gt; System.out.println(nimi));
<% end %>


<% partial 'partials/exercise', locals: { name: 'Luettujen arvojen tulostaminen' } do %>

  <p>
    Kirjoita ohjelma, joka lukee käyttäjältä merkkijonoja. Lukeminen tulee lopettaa kun käyttäjä syöttää tyhjän merkkijonon. Tulosta tämän jälkeen käyttäjän syöttämät merkkijonot.
  </p>

  <% partial 'partials/sample_output' do %>
    <font color="red">eka</font>
    <font color="red">toka</font>
    <font color="red">kolmas</font>
    eka
    toka
    kolmas
  <% end %>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Rajatut luvut' } do %>

  <p>
    Kirjoita ohjelma, joka lukee käyttäjältä lukuja. Kun käyttäjä syöttää negatiivisen luvun, lukeminen lopetetaan. Tulosta tämän jälkeen ne luvut, jotka ovat välillä 1-5.
  </p>

  <% partial 'partials/sample_output' do %>
    <font color="red">7</font>
    <font color="red">14</font>
    <font color="red">4</font>
    <font color="red">5</font>
    <font color="red">4</font>
    <font color="red">-1</font>
    4
    5
    4
  <% end %>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Uniikit sukunimet' } do %>

  <p>
    Tehtäväpohjaan on hahmoteltu ohjelmaa, joka lukee käyttäjältä syötteenä henkilötietoja. Täydennä ohjelmaa siten, että tietojen lukemisen jälkeen ohjelma tulostaa henkilöiden uniikit sukunimet aakkosjärjestyksessä.
  </p>

  
  <% partial 'partials/sample_output' do %>
    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: 
    Syötä etunimi: <font color="red">Ada</font>
    Syötä sukunimi: <font color="red">Lovelace</font>
    Syötä syntymävuosi: <font color="red">1815</font>

    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: 
    Syötä etunimi: <font color="red">Grace</font>
    Syötä sukunimi: <font color="red">Hopper</font>
    Syötä syntymävuosi: <font color="red">1906</font>

    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: 
    Syötä etunimi: <font color="red">Alan</font>
    Syötä sukunimi: <font color="red">Turing</font>
    Syötä syntymävuosi: <font color="red">1912</font>
    
    Syötetäänkö henkilöiden tietoja, "loppu" lopettaa: loppu
    
    Uniikit sukunimet aakkosjärjestyksessä:
    Hopper
    Lovelace
    Turing
  <% end %>

  <p>
    Ohjelmassa ei ole valmiita automaattisia testejä. Voit kirjoittaa automaattisia testejä testiluokkaan <code>UniikitSukunimetTest</code> -- tässä tapauksessa olisi näppärää tehdä esimerkiksi erillinen listan palauttava metodi uniikkien sukunimien tunnistamiseen sille parametrina annetusta henkilölistasta. 
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Oliot ja virta
<% end %>

<p>
  Olioiden käsittely virran metodien avulla on luontevaa. Kukin virran metodi, missä käsitellään virran arvoja, mahdollistaa myös arvoihin liittyvän metodin kutsumisen. Tarkastellaan vielä esimerkkiä, missä käytössämme on Kirjoja, joilla on kirjailijoita. Oletetaan, että kirjailijat ovat edellä kuvattuja Henkilo-olioita. Oletetaan lisäksi, että käytössämme on alla kuvattu luokka Kirja.
</p>


<% partial 'partials/code_highlight' do %>
  public class Kirja {
  private Henkilo kirjailija;
  private String nimi;
  private int sivujenLukumaara;
  
  public Kirja(Henkilo kirjailija, String nimi, int sivuja) {
  this.kirjailija = kirjailija;
  this.nimi = nimi;
  this.sivujenLukumaara = sivuja;
  }

  public Henkilo getKirjailija() {
  return this.kirjailija;
  }

  public String getNimi() {
  return this.nimi;
  }

  public int getSivujenLukumaara() {
  return this.sivujenLukumaara;
  }
  }
<% end %>

<p>
  Oletetaan, että käytössämme on lista kirjoja. Virran metodien avulla esimerkiksi kirjailijoiden syntymävuosien keskiarvon selvittäminen onnistuu luontevasti. Ensin muunnamme kirjoja sisältävän virran henkilöitä sisältäväksi virraksi, tämän jälkeen muunnamme henkilöitä sisältävän virran syntymävuosia sisältäväksi virraksi, ja lopulta pyydämme (kokonaislukuja sisältävältä) virralta keskiarvoa.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista kirjoja
  // ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

  double keskiarvo = kirjat.stream()
  .map(kirja -&gt; kirja.getKirjailija())
  .mapToInt(kirjailija -&gt; kirjailija.getSyntymavuosi())
  .average()
  .getAsDouble();

  System.out.println("Kirjailijoiden syntymävuosien keskiarvo: " + keskiarvo);
<% end %>


<p>
  Vastaavasti kirjojen, joiden nimessä esiintyy sana "Potter", kirjailijoiden nimet saa selville seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista kirjoja
  // ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

  kirjat.stream()
  .filter(kirja -&gt; kirja.getNimi().contains("Potter"))
  .map(kirja -&gt; kirja.getKirjailija())
  .forEach(kirjailija -&gt; System.out.println(kirjailija.getEtunimi() + " " + kirjailija.getSukunimi()));
<% end %>

<p>
  Myös monimutkaisempien merkkijonoesitysten rakentaminen on virran avulla mahdollista. Alla olevassa esimerkissä tulostamme "Kirjailijan sukunimi: Kirja" -parit aakkosjärjestyksessä.
</p>

<% partial 'partials/code_highlight' do %>
  // oletetaan, että käytössämme on lista kirjoja
  // ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

  kirjat.stream()
  .map(kirja -&gt; kirja.getKirjailija().getSukunimi() + ": " + kirja.getNimi())
  .sorted()
  .forEach(nimi -&gt; System.out.println(nimi));
<% end %>



<% partial 'partials/exercise', locals: { name: 'Painon laskemista (2 osaa)' } do %>

  <p>
    Tehtäväpohjassa on edellisen osan tehtävä "Tavara, Matkalaukku ja Lastiruuma". Tässä tehtävässä tarkoituksenasi on muuttaa toistolausetta käyttävät metodit virtaa käyttäviksi metodeiksi niiltä osin, kuin tämä on mahdollista. Ohjelman toiminnallisuuden tulee säilyä samana.
  </p>

  <p>
    Tässä tehtävässä ei ole erillisiä virran käyttämistä testaavista testejä. Kun toistolausetta hyödyntävät osiot on muunnettu virtaa käyttäviksi, palauta tehtävä. Tehtävä on kokonaisuudessaan kahden pisteen arvoinen.
  </p>
  
<% end %>



<% partial 'partials/material_heading' do %>
  Tehtäväpohjien rakenne ja Maven
<% end %>

<p>
  Ohjelmoinnin jatkokurssista lähtien kurssin tehtäväpohjat käyttävät <a href="https://maven.apache.org/" target="_blank" norel>Maven</a>-nimistä projektinhallintatyövälinettä. Kyseinen työväline helpottaa kurssin tehtävien mukana tuotavien kirjastojen hallintaa. Tehtäviin tämä vaikuttaa siten, että niiden kansiorakenne muuttuu hieman. 
</p>

<p>
  Jatkossa tehtävän juurikansiossa on tiedosto pom.xml, joka kuvaa tehtäväpohjan rakenteen. Kansio <code>src</code> sisältää kansiot <code>main</code> ja <code>test</code>, jotka sisältävät lähdekooditiedostot sekä testitiedostot.

</p>

<pre>
$/Osa08_01.SamaPaivays$ tree
.
├── pom.xml
└── src
    ├── main
    │   └── java
    │       ├── Paaohjelma.java
    │       └── Paivays.java
    └── test
        └── java
            └── PaivaysTest.java

</pre>


<p>
  Ohjelmien toiminta ei käytännössä juurikaan muutu. Toisin kuin ennen, ohjelmien tarvitsemat kirjastot eivät kuitenkaan tule tehtäväpohjan mukana, vaan Mavenilta tulee pyytää tarvittaessa niiden lataamista. Tämä onnistuu klikkaamalla tehtäväpohjan Dependencies-kuvaketta Projects-välilehdellä ja valitsemalla "Download declared dependencies."
</p>

<img src="/img/maven-1.png"/>

<br/>

<p>
  Riippuen tietokoneesi käyttöjärjestelmästä, on mahdollista, että joudut lisäämään Maven-ohjelmaan ajo-oikeudet kun sitä käytetään ensimmäistä kertaa. Windowsille ohjeita löytyy yleisesti ottaen googlettamalla ja mm. täältä: <a href="https://www.online-tech-tips.com/computer-tips/set-file-folder-permissions-windows/" target="_blank" norel>https://www.online-tech-tips.com/computer-tips/set-file-folder-permissions-windows/</a> -- myös pajassa neuvotaan tähän liittyen. 
</p>


<% partial 'partials/material_sub_heading' do %>
  Ongelmia ja ratkaisuja
<% end %>

<p>
  Mavenin käyttöönottoon on liittynyt kurssilla ongelmia. Tässä lyhyt ongelmanratkaisuopas.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Linux ja Mac
<% end %>

<p>
  Ongelma: Maven-binäärin suoritusoikeudet puuttuvat. Mavenin virhe on (esimerkiksi) muotoa.
</p>

<pre>
Cannot run program
  /Applications/tmcbeans.app/Contents/Resources/tmcbeans/java/maven/bin/mvn"
  (in directory "/Users/[nimi]/NetBeansProjects/hy-[kurssi]/[tehtava]"):
  error=13,
  Permission denied
</pre>

<p>
  Ratkaisu: lisää maven-binäärille suoritusoikeudet. Suorita terminaalissa (pääte) komento.
</p>

<pre>
chmod +x /Applications/tmcbeans.app/Contents/Resources/tmcbeans/java/maven/bin/mvn
</pre>

<p>
  Huomaa, että edellä polku on sama kuin virheviestin "Cannot run program"-polku.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Windows
<% end %>

<p>
  Ongelma: Ympäristömuuttuja <code>JAVA_HOME</code> ei ole asetettu. Käytännössä Maven yrittää etsiä Javaa, mutta ei löydä sitä.
</p>

<p>
  Ratkaisu: Lisää Windowsiin JAVA_HOME ympäristömuuttuja (esim.) osoitteessa <a href="https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html" target="_blank" norel>https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html</a> olevia ohjeita seuraamalla. Huomaa, että kansion tulee olla jdk, ei jre.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Tietojenkäsittelytieteen laitoksen koneet
<% end %>

<p>
  Ongelma: Riippuvuuksien lataaminen ei onnistu tai ne eivät toimi. Tässä syynä on joko loppunut levytila tai verkkoyhteysongelma. Levytilan tilanteen saa selvitettyä komennolla "quota".
</p>

<p>
  Ratkaisu:
</p>

<ol>
  <li>
    Poista vanhat ohjelmoinnin perusteiden (ja mahdollisesti muiden TMCtä käyttävien kurssien) tehtäväpohjat. Nämä löytyvät kotikansiosta kansion NetBeansProjects alta. Kannattanee harkita myös muiden turhien tiedostojen poistamista sekä esimerkiksi selaimen välimuistin tyhjentämistä ajoittain.
  </li>

  <li>
    Poista kotikansiossa olevan .m2-kansion sisältö. Tämä tehdään sillä Maven luo ladattavista riippuvuuksista (eli kirjastoista) vahingossa tyhjät tiedostot mikäli levytila on loppunut.
  </li>

  <li>
    (Jatkuva) Kun saat tehtäviä lähetettyä TMC:lle, klikkaa tehtäväpohjaa ja valitse "clean". Tämä poistaa tehtäväpohjasta käännetyt tiedostot.
  </li>
</ol>


<% partial 'partials/material_heading' do %>
  Object
<% end %>

<p>
  Olemme useampaan otteeseen käyttäneet metodia <code>public String toString()</code> olion merkkijonoesityksen muodostamiseen. Emme ole kuitenkaan saaneet selvyyttä <em>miksi</em> Java osaa käyttää kyseistä metodia. Olemattoman metodin kutsuminenhan tuottaa normaalisti virheen.
</p>

<p>
  Tutkitaan seuraavaa luokkaa <code>Kirja</code>, jolla ei ole metodia <code>public String toString()</code>, ja ohjelmaa joka yrittää tulostaa <code>Kirja</code>-luokasta luodun olion <code>System.out.println()</code>-komennolla.
</p>

<% partial 'partials/code_highlight' do %>
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }
}
<% end %>

<% partial 'partials/code_highlight' do %>
Kirja olioKirja = new Kirja("Oliokirja", 2000);
System.out.println(olioKirja);
System.out.println(olioKirja.toString());
<% end %>

<p>
  Ohjelma ei tulosta virheilmoitusta tai kaadu kun annamme <code>Kirja</code>-luokasta tehdyn olion parametrina <code>System.out.println</code>-komennolle tai kutsumme oliolle metodia <code>toString</code>. Näemme virheilmoituksen tai kaatumisen sijaan mielenkiintoisen tulosteen. Tuloste sisältää luokan <code>Kirja</code> nimen ja epämääräisen @-merkkiä seuraavan merkkijonon. Huomaa että kutsussa <code>System.out.println(olioKirja)</code> Java tekee oikeasti kutsun <code>System.out.println(olioKirja.toString())</code>
</p>

<p>
  Selitys liittyy Javan luokkien rakenteeseen. Jokainen Javan luokka <strong>perii</strong> automaattisesti luokan <code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a></code>, joka sisältää joukon jokaiselle Javan luokalle hyödyllisiä perusmetodeja. Perintä tarkoittaa että oma luokkamme saa käyttöön perittävän luokan määrittelemiä toiminnallisuuksia ja ominaisuuksia. Luokka <code>Object</code> sisältää muun muassa metodin <code>toString</code>, joka periytyy luokkiimme. Tämän takia metodi toString on jokaisen luomamme luokan käytössä, riippumatta siitä lisäämmekö metodille toteutuksen luokkaamme vai emme.
</p>

<p>
  Object-luokassa määritelty <code>toString</code>-metodi ei yleensä ole toivomamme, minkä takia se tyypillisesti korvataan omalla toteutuksellamme. Tämä tapahtuu luomalla omaan luokkaamme <code>public String toString()</code>-metodi, jossa on toivomamme toiminnallisuus.
</p>

<p>
  Lisätään luokkaan <code>Kirja</code> metodi <code>public String toString()</code>, joka korvaa perityssä <code>Object</code> luokassa olevan metodin <code>toString</code>.
</p>

<% partial 'partials/code_highlight' do %>
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + " (" + this.julkaisuvuosi + ")";
    }
}
<% end %>

<p>
  Nyt kun teemme oliosta ilmentymän ja annamme sen tulostusmetodille, näemme luokassa <code>Kirja</code> olevan <code>toString</code>-metodin tuottaman merkkijonon.
</p>

<% partial 'partials/code_highlight' do %>
Kirja olioKirja = new Kirja("Oliokirja", 2000);
System.out.println(olioKirja);
<% end %>

<% partial 'partials/sample_output' do %>
Oliokirja (2000)
<% end %>

<p>
  Luokassa <code>Kirja</code> olevan metodin <code>toString</code> yläpuolella on <em>annotaatio</em> <code>@Override</code>. Annotaatioilla annetaan vinkkejä siitä, miten metodeihin tulisi suhtautua. Annotaatio <code>@Override</code> kertoo lukijalle että annotaatiota seuraava metodi korvaa perityssä luokassa määritellyn metodin. Jos korvattavaan metodiin ei liitetä annotaatiota, antaa kääntäjä tilanteessa varoituksen, overriden kirjottamatta jättäminen ei kuitenkaan ole virhe.
</p>

<p>
  Luokasta <code>Object</code> peritään muitakin hyödyllisiä metodeja. Tutustutaan seuraavaksi metodeihin <code>equals</code> ja <code>hashCode</code>.
</p>


<% partial 'partials/material_sub_heading' do %>
  Samanarvoisuudesta kertova metodi "equals"
<% end %>

<p>
  Metodia <code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object" target="_blank" rel="noopener">equals</a></code> käytetään kahden olion yhtäsuuruusvertailuun. Metodia on jo käytetty muun muassa <code>String</code>-olioiden yhteydessä.
</p>

<% partial 'partials/code_highlight' do %>
Scanner lukija = new Scanner(System.in);

System.out.print("Kirjoita salasana: ");
String salasana = lukija.nextLine();

if (salasana.equals("salasana")) {
    System.out.println("Oikein meni!");
} else {
    System.out.println("Pieleen meni!");
}
<% end %>

<% partial 'partials/sample_output' do %>
Kirjoita salasana: <font color="red">mahtiporkkana</font>
Pieleen meni!
<% end %>

<p>
  Luokassa <code>Object</code> määritelty metodi <code>equals</code> tarkastaa onko parametrina annetulla oliolla sama viite kuin oliolla johon verrataan, eli toisinsanoen oletusarvoisesti vertaillaan onko kyse kahdesta <em>samasta</em> oliosta. Jos viite on sama, palauttaa metodi arvon <code>true</code>, muuten <code>false</code>. Tämä selvenee seuraavalla esimerkillä. Luokassa <code>Kirja</code> ei ole omaa <code>equals</code>-metodin toteutusta, joten se käyttää <code>Object</code>-luokassa olevaa toteutusta.
</p>

<% partial 'partials/code_highlight' do %>
Kirja olioKirja = new Kirja("Oliokirja", 2000);
Kirja toinenOlioKirja = olioKirja;

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println("Kirjat olivat samat");
} else {
    System.out.println("Kirjat eivät olleet samat");
}

// nyt luodaan saman sisältöinen olio joka kuitenkin on oma erillinen olionsa
toinenOlioKirja = new Kirja("Oliokirja", 2000);

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println("Kirjat olivat samat");
} else {
    System.out.println("Kirjat eivät olleet samat");
}
<% end %>

<% partial 'partials/sample_output' do %>
Kirjat olivat samat
Kirjat eivät olleet samat
<% end %>

<p>
  Vaikka edellisessä esimerkissä olevien kirjaolioiden sisäinen rakenne (eli oliomuuttujien arvot) on täsmälleen sama, vain ensimmäinen vertailu tulostaa merkkijonon "<code>Kirjat olivat samat</code>". Tämä johtuu siitä että vain ensimmäisessä tapauksessa viitteet ovat samat, eli olioa vertaillaan itseensä. Toisessa vertailussa kyse on kahdesta eri oliosta, vaikka muuttujilla onkin samat arvot.
</p>

<p>
  Merkkijonojen eli Stringien yhteydessä <code>equals</code> toimii odotetulla tavalla, eli se ilmoittaa kaksi <em>samansisältöistä</em> merkkijonoa "equalseiksi" vaikka kyseessä olisikin kaksi erillistä olioa. String-luokassa onkin korvattu oletusarvoinen <code>equals</code> omalla toteutuksella.
</p>

<p>
  Haluamme että kirjojen vertailu onnistuu myös nimen ja vuoden perusteella. Korvataan <code>Object</code>-luokassa oleva metodi <code>equals</code> määrittelemällä sille toteutus luokkaan <code>Kirja</code>. Metodin <code>equals</code> tehtävänä on selvittää onko olio sama kuin metodin parametrina saatu olio. Metodi saa parametrina <code>Object</code>-tyyppisen viitteen olion. Määritellään ensin metodi, jonka mielestä kaikki oliot ovat samoja.
</p>

<% partial 'partials/code_highlight' do %>
public boolean equals(Object olio) {
    return true;
}
<% end %>

<p>
  Metodimme on varsin optimistinen, joten muutetaan sen toimintaa hieman. Määritellään että oliot eivät ole samoja jos parametrina saatu olio on <em>null</em> tai jos olioiden tyypit eivät ole samat. Olion tyypin saa (<code>Object</code>-luokassa määritellyllä) metodilla <code>getClass()</code>. Muussa tapauksessa oletetaan että oliot ovat samat.
</p>

<% partial 'partials/code_highlight' do %>
public boolean equals(Object olio) {
    if (olio == null) {
        return false;
    }

    if (this.getClass() != olio.getClass()) {
        return false;
    }

    return true;
}<% end %>

<p>
  Metodi <code>equals</code> huomaa eron erityyppisten olioiden välillä, mutta ei vielä osaa erottaa samanlaisia olioita toisistaan. Jotta voisimme verrata nykyistä oliota ja parametrina saatua <code>Object</code>-tyyppisellä parametrilla viitattua olioa, tulee Object-viitteen tyyppiä muuttaa. Viitteen tyyppiä voidaan muuttaa tyyppimuunnoksella jos ja vain jos olion tyyppi on oikeasti sellainen, mihin sitä yritetään muuttaa. Tyyppimuunnos tapahtuu antamalla asetuslauseen oikealla puolella haluttu luokka suluissa, esimerkiksi:
</p>

<% partial 'partials/code_highlight' do %>
HaluttuTyyppi muuttuja = (HaluttuTyyppi) vanhaMuuttuja;
<% end %>

<p>
  Voimme tehdä tyyppimuunnoksen koska tiedämme olioiden olevan samantyyppisiä, jos ne ovat erityyppisiä yllä oleva metodi <code>getClass</code> palauttaa arvon false. Muunnetaan metodissa <code>equals</code> saatu <code>Object</code>-tyyppinen parametri <code>Kirja</code>-tyyppiseksi, ja todetaan kirjojen olevan eri jos niiden julkaisuvuodet ovat eri. Muuten kirjat ovat vielä samat.
</p>

<% partial 'partials/code_highlight' do %>
public boolean equals(Object olio) {
    if (olio == null) {
        return false;
    }

    if (getClass() != olio.getClass()) {
        return false;
    }

    Kirja verrattava = (Kirja) olio;

    if(this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
        return false;
    }

    return true;
}
<% end %>

<p>
  Nyt vertailumetodimme osaa erottaa  eri vuosina julkaistut kirjat. Lisätään vielä tarkistus, että kirjojemme nimet ovat samat ja että oman kirjamme nimi ei ole <em>null</em>.
</p>

<% partial 'partials/code_highlight' do %>
public boolean equals(Object olio) {
    if (olio == null) {
        return false;
    }

    if (getClass() != olio.getClass()) {
        return false;
    }

    Kirja verrattava = (Kirja) olio;

    if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
        return false;
    }

    if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
        return false;
    }

    return true;
}
<% end %>

<p>
  Mahtavaa, viimeinkin toimiva vertailumetodi! Alla vielä tämänhetkinen <code>Kirja</code>-luokkamme.
</p>

<% partial 'partials/code_highlight' do %>
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + " (" + this.julkaisuvuosi + ")";
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }
}
<% end %>

<p>
  Nyt kirjojen vertailu palauttaa <code>true</code> jos kirjojen sisällöt ovat samat.
</p>

<% partial 'partials/code_highlight' do %>
Kirja olioKirja = new Kirja("Oliokirja", 2000);
Kirja toinenOlioKirja = new Kirja("Oliokirja", 2000);

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println("Kirjat olivat samat");
} else {
    System.out.println("Kirjat eivät olleet samat");
}
<% end %>

<% partial 'partials/sample_output' do %>
Kirjat olivat samat
<% end %>



<% partial 'partials/exercise', locals: { name: 'Sama päiväys' } do %>

  <p>
    Laajennetaan alkukurssin tehtävässä "Päivämäärien erotus" toteutettua Paivays-luokkaa siten, että se osaa myös sanoa ovatko päivämäärät täsmälleen samat.
  </p>

  <p>
    Lisää <code>Paivays</code>-luokkaan metodi <code>public boolean equals(Object object)</code>, joka kertoo onko metodille parametrina annettu olio päiväys ja onko parametrina annetun olion päiväys sama kuin käytetyn olion päiväys.
  </p>

  <p>
    Metodin tulee toimia seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
Paivays p = new Paivays(1, 2, 2000);
System.out.println(p.equals("heh"));
System.out.println(p.equals(new Paivays(5, 2, 2012)));
System.out.println(p.equals(new Paivays(1, 2, 2000)));
  <% end %>

  <% partial 'partials/sample_output' do %>
false
false
true
  <% end %>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Equals ja ArrayList
<% end %>

<p>
  Useat Javan valmiit tietorakenteet käyttävät <code>equals</code>-metodia osana sisäistä hakumekanismiaan. Esimerkiksi luokan <code>ArrayList</code> <code>contains</code>-metodi vertailee olioiden yhtäsuuruutta <code>equals</code>-metodin avulla. Jatketaan aiemmin määrittelemämme <code>Kirja</code>-luokan käyttöä seuraavassa esimerkissä. Jos emme toteuta omissa olioissamme <code>equals</code>-metodia, ei <code>contains</code>-metodi toimi oikein, sillä se käyttää omassa toteutuksessaan equals-metodia olioiden vertailemiseen. Kokeile alla olevaa koodia kahdella erilaisella <code>Kirja</code>-luokalla. Toisessa on <code>equals</code>-metodi, ja toisessa sitä ei ole.
</p>

<% partial 'partials/code_highlight' do %>
ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();
Kirja olioKirja = new Kirja("Oliokirja", 2000);
kirjat.add(olioKirja);

if (kirjat.contains(olioKirja)) {
    System.out.println("Oliokirja löytyi.");
}

olioKirja = new Kirja("Oliokirja", 2000);

if (!kirjat.contains(olioKirja)) {
    System.out.println("Oliokirjaa ei löytynyt.");
}
<% end %>

<p>
  Tämä oletusmetodeihin kuten <code>equals</code> tukeutuminen on oikeastaan syy sille, miksi Java haluaa, että ArrayListiin lisättävät muuttujat ovat viittaustyyppisiä. Koska jokaisella luokalla on Object-luokasta periytyvä equals-metodi, ei luokan ArrayList sisäistä toteutusta tarvitse muuttaa lainkaan erilaisia muuttujia lisättäessä. Alkeistyyppisillä muuttujilla tällaisia metodeja ei ole, jolloin ArrayList ei löydä niihin liittyvää equals-metodia.
</p>


<% partial 'partials/material_sub_heading' do %>
  Hajautusarvo "hashCode"
<% end %>

<p>
  Object-luokasta periytyvää metodia <code>hashCode</code> käytetään oliota kuvaavan hajautusarvon luomiseen. Hajautusarvoa käytetään suurpiirteiseen vertailuun. Jos kahdella oliolla on sama hajautusarvo, ne saattavat olla samanarvoiset. Jos taas kahdella oliolla on eri hajautusarvot, ne ovat varmasti eriarvoiset.
</p>

<p>
  Hajautusarvoa tarvitaan muunmuassa HashMapissa. HashMapin sisäinen toiminta perustuu siihen, että avain-arvo -parit on tallennettu avaimen hajautusarvon perusteella listoja sisältävään taulukkoon. Jokainen taulukon indeksi viittaa listaan. Hajautusarvon perusteella tunnistetaan taulukon indeksi, jonka jälkeen taulukon indeksistä löytyvä lista käydään läpi. Avaimeen liittyvä arvo palautetaan jos ja vain jos listasta löytyy täsmälleen sama arvo (samansuuruisuuden vertailu tapahtuu equals-metodilla). Näin etsinnässä tarvitsee tarkastella vain murto-osaa hajautustauluun tallennetuista avaimista.
</p>

<p>
  Olemme tähän mennessä käyttäneet HashMapin avaimina ainoastaan String- ja Integer-tyyppisiä olioita, joilla on ollut valmiina sopivasti toteutetut <code>hashCode</code>-metodit. Luodaan esimerkki jossa näin ei ole: jatketaan kirjojen parissa ja pidetään kirjaa lainassa olevista kirjoista. Päätetään ratkaista kirjanpito HashMapin avulla. Avaimena toimii kirja ja kirjaan liitetty arvo on merkkijono, joka keroo lainaajan nimen:
</p>

<% partial 'partials/code_highlight' do %>
HashMap&lt;Kirja, String&gt; lainaajat = new HashMap&lt;&gt;();

Kirja oliokirja = new Kirja("Oliokirja", 2000);
lainaajat.put(oliokirja, "Pekka");
lainaajat.put(new Kirja("Test Driven Development", 1999), "Arto");

System.out.println(lainaajat.get(oliokirja));
System.out.println(lainaajat.get(new Kirja("Oliokirja", 2000));
System.out.println(lainaajat.get(new Kirja("Test Driven Development", 1999));
<% end %>

<% partial 'partials/sample_output' do %>
Pekka
null
null
<% end %>

<p>
  Löydämme lainaajan hakiessamme samalla oliolla, joka annettiin hajautustaulun <code>put</code>-metodille avaimeksi. Täsmälleen samanlaisella kirjalla mutta eri oliolla haettaessa lainaajaa ei kuitenkaan löydy ja saamme <em>null</em>-viitteen. Syynä on <code>Object</code>-luokassa oleva <code>hashCode</code>-metodin oletustoteutus. Oletustoteutus luo <code>hashCode</code>-arvon olion viitteen perusteella, eli samansisältöiset mutta eri oliot saavat eri tuloksen hashCode-metodista. Tämän takia olioa ei osata etsiä oikeasta paikasta.
</p>

<p>
  Jotta HashMap toimisi haluamallamme tavalla, eli palauttaisi lainaajan kun avaimeksi annetaan oikean <em>sisältöinen</em> olio (ei välttämässä siis sama olio kuin alkuperäinen avain), on avaimena toimivan luokan ylikirjoitettava metodin <code>equals</code> lisäksi metodi <code>hashCode</code>. Metodi on ylikirjoitettava siten, että se antaa saman numeerisen tuloksen kaikille samansisältöisille olioille. Myös jotkut erisisältöiset oliot saavat saada saman tuloksen hashCode-metodista. On kuitenkin HashMapin tehokkuuden kannalta oleellista, että erisisältöiset oliot saavat mahdollisimman harvoin saman hajautusarvon.
</p>

<p>
  Olemme aiemmin käyttäneet <code>String</code>-olioita menestyksekkäästi HashMapin avaimena, joten voimme päätellä että <code>String</code>-luokassa on oma järkevästi toimiva <code>hashCode</code>-toteutus. <em>Delegoidaan</em>, eli siirretään laskemisvastuu <code>String</code>-oliolle.
</p>

<% partial 'partials/code_highlight' do %>
public int hashCode() {
    return this.nimi.hashCode();
}
<% end %>

<p>
  Yllä oleva ratkaisu on melko hyvä, mutta jos <code>nimi</code> on <em>null</em>, näemme <code>NullPointerException</code>-virheen. Korjataan tämä vielä määrittelemällä ehto: jos <code>nimi</code>-muuttujan arvo on <em>null</em>, palautetaan hajautusarvoksi julkaisuvuosi.
</p>

<% partial 'partials/code_highlight' do %>
public int hashCode() {
    if (this.nimi == null) {
        return this.julkaisuvuosi;
    }

    return this.nimi.hashCode();
}
<% end %>

<p>
  Nyt ylläolevassa ratkaisussa kaikki saman nimiset kirjat niputetaan samaan joukkoon. Parannetaan toteutusta vielä siten, että kirjan julkaisuvuosi huomioidaan myös nimeen perustuvassa hajautusarvon laskennassa.
</p>

<% partial 'partials/code_highlight' do %>
public int hashCode() {
    if (this.nimi == null) {
        return this.julkaisuvuosi;
    }

    return this.julkaisuvuosi + this.nimi.hashCode();
}
<% end %>


<% partial 'partials/exercise', locals: { name: 'Hajautusarvo päiväykselle' } do %>

  <p>
    Laajennetaan vielä edellisessä tehtävässä nähtyä <code>Paivays</code>-luokkaa siten, että sillä on myös oma <code>hashCode</code>-metodi.</p>

  <p>
    Lisää <code>Paivays</code>-luokkaan metodi <code>public int hashCode()</code>, joka laskee päiväys-oliolle hajautusarvon. Toteuta hajautusarvon laskeminen siten, että vuosien 1900 ja 2100 välillä löytyy mahdollisimman vähän samankaltaisia hajautusarvoja.
  </p>

<% end %>


<p>
  Luokka <code>Kirja</code> nyt kokonaisuudessaan.
</p>

<% partial 'partials/code_highlight' do %>
public class Kirja {

    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + " (" + this.julkaisuvuosi + ")";
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }

    public int hashCode() {
        if (this.nimi == null) {
            return this.julkaisuvuosi;
        }

        return this.julkaisuvuosi + this.nimi.hashCode();
    }
}
<% end %>


<p>
  <strong>Kerrataan vielä:</strong> jotta luokkaa voidaan käyttää HashMap:in avaimena, tulee sille määritellä
</p>

<ul>
  <li>metodi <code>equals</code> siten, että kaikki samansuuruisena (tai saman sisältöisinä) ajatellut oliot tuottavat vertailussa tuloksen true ja muut false</li>
  <li>metodi <code>hashCode</code> siten, että mahdollisimman harvalla erisuuruisella oliolla on sama hajautusarvo</li>
</ul>

<p>
  Luokalle <code>Kirja</code> määrittelemämme equals ja hashCode selvästi täyttävät nämä ehdot. Nyt myös aiemmin kohtaamamme ongelma ratkeaa ja kirjojen lainaajat löytyvät:
</p>

<% partial 'partials/code_highlight' do %>
HashMap&lt;Kirja, String&gt; lainaajat = new HashMap&lt;&gt;();

Kirja oliokirja = new Kirja("Oliokirja", 2000);
lainaajat.put(oliokirja, "Pekka");
lainaajat.put(new Kirja("Test Driven Development",1999), "Arto");

System.out.println(lainaajat.get(oliokirja));
System.out.println(lainaajat.get(new Kirja("Oliokirja", 2000));
System.out.println(lainaajat.get(new Kirja("Test Driven Development", 1999));
<% end %>

<p>Tulostuu:</p>

<% partial 'partials/sample_output' do %>
Pekka
Pekka
Arto
<% end %>


<% partial 'partials/hint', locals: { name: 'Metodien equals ja hashCode automaattinen luominen' } do %>

  <p>
    NetBeans tarjoaa metodien <code>equals</code> ja <code>hashCode</code> automaattisen luonnin. Voit valita valikosta Source -&gt; Insert Code, ja valita aukeavasta listasta <em>equals() and hashCode()</em>. Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään. Nämä NetBeansin generoimat metodit ovat tyypillisesti "tarpeeksi hyviä" omiin tarpeisiimme.
  </p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Autorekisterikeskus (3 osaa)' } do %>


  <h2>Rekisterinumeron equals ja hashCode</h2>

  <p>
    Eurooppalaiset rekisteritunnukset koostuvat kahdesta osasta: yksi tai kaksikirjaimisesta maatunnuksesta ja maakohtaisesti määrittyvästä rekisterinumerosta, joka taas koostuu numeroista ja merkeistä. Rekisterinumeroita esitetään seuraavanlaisen luokan avulla:
  </p>

  <% partial 'partials/code_highlight' do %>
public class Rekisterinumero {
    // tässä määre final tarkoittaa sitä, että arvoa ei voi muuttaa asetuksen jälkeen
    private final String rekNro;
    private final String maa;

    public Rekisterinumero(String rekNro, String maa) {
       this.rekNro = rekNro;
       this.maa = maa;
    }

    public String toString(){
        return maa+ " "+rekNro;
    }
}
  <% end %>

  <p>
    Rekisterinumeroja halutaan tallettaa esim. ArrayList:eille ja käyttää HashMap:in avaimina, eli kuten yllä mainittu, tulee niille toteuttaa metodit <code>equals</code> ja <code>hashCode</code>, muuten ne eivät toimi halutulla tavalla. Toteuta luokalle rekisterinumero metodit <code>equals</code> ja <code>hashCode</code>.
  </p>

  <p>Esimerkkiohjelma:</p>

  <% partial 'partials/code_highlight' do %>
public static void main(String[] args) {
    Rekisterinumero rek1 = new Rekisterinumero("FI", "ABC-123");
    Rekisterinumero rek2 = new Rekisterinumero("FI", "UXE-465");
    Rekisterinumero rek3 = new Rekisterinumero("D", "B WQ-431");

    ArrayList&lt;Rekisterinumero&gt; suomalaiset = new ArrayList&lt;&gt;();
    suomalaiset.add(rek1);
    suomalaiset.add(rek2);

    Rekisterinumero uusi = new Rekisterinumero("FI", "ABC-123");
    if (!suomalaiset.contains(uusi)) {
        suomalaiset.add(uusi);
    }
    System.out.println("suomalaiset: " + suomalaiset);
    // jos equals-metodia ei ole ylikirjoitettu, menee sama rekisterinumero toistamiseen listalle

    HashMap&lt;Rekisterinumero, String&gt; omistajat = new HashMap&lt;&gt;();
    omistajat.put(rek1, "Arto");
    omistajat.put(rek3, "Jürgen");

    System.out.println("omistajat:");
    System.out.println(omistajat.get(new Rekisterinumero("FI", "ABC-123")));
    System.out.println(omistajat.get(new Rekisterinumero("D", "B WQ-431")));
    // jos hashCode ei ole ylikirjoitettu, eivät omistajat löydy
}
  <% end %>

  <p>
    Jos equals ja hashCode on toteutettu oikein, tulostus on seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
suomalaiset: [FI ABC-123, FI UXE-465]
omistajat:
Arto
Jürgen
  <% end %>


  <h2>Omistaja rekisterinumeron perusteella</h2>

  <p>
    Toteuta luokka <code>Ajoneuvorekisteri</code> jolla on seuraavat metodit:
  </p>

  <ul>
    <li><code>public boolean lisaa(Rekisterinumero rekkari, String omistaja)</code> lisää parametrina olevaa rekisterinumeroa vastaavalle autolle parametrina olevan omistajan, metodi palauttaa true jos omistajaa ei ollut ennestään, jos rekisterinumeroa vastaavalla autolla oli jo omistaja, metodi palauttaa false ja ei tee mitään</li>

    <li><code>public String hae(Rekisterinumero rekkari)</code> palauttaa parametrina olevaa rekisterinumeroa vastaavan auton omistajan. Jos auto ei ole rekisterissä, palautetaan <code>null</code></li>

    <li><code>public boolean poista(Rekisterinumero rekkari)</code> poistaa parametrina olevaa rekisterinumeroa vastaavat tiedot, metodi palauttaa true jos tiedot poistetiin, ja false jos parametria vastaavia tietoja ei ollut rekisterissä</li>
  </ul>

  <p>
    <strong>Huom:</strong> Ajoneuvorekisterin täytyy tallettaa omistajatiedot <code>HashMap&lt;Rekisterinumero, String&gt; omistajat</code> -tyyppiseen oliomuuttujaan!
  </p>


  <h2>Ajoneuvorekisteri laajenee</h2>

  <p>
    Lisää Ajoneuvorekisteriin vielä seuraavat metodit:
  </p>

  <ul>
    <li><code>public void tulostaRekisterinumerot()</code> tulostaa rekisterissä olevat rekisterinumerot</li>
    <li><code>public void tulostaOmistajat()</code> tulostaa rekisterissä olevien autojen omistajat, yhden omistajan nimeä ei saa tulostaa kuin kertaalleen vaikka omistajalla olisikin useampi auto</li>
  </ul>

<% end %>


<% partial 'partials/material_heading' do %>
  Rajapinta
<% end %>


<p>
  Rajapinnan (engl. <em>interface</em>) avulla määritellään luokalta vaadittu käyttäytyminen, eli sen metodit. Rajapinnat määritellään kuten normaalit Javan luokat, mutta luokan alussa olevan määrittelyn "<code>public class ...</code>" sijaan käytetään määrittelyä "<code>public interface ...</code>". Rajapinnat määrittelevät käyttäytymisen metodien niminä ja palautusarvoina, mutta ne eivät aina sisällä metodien konkreettista toteutusta. Näkyvyysmäärettä rajapintoihin ei erikseen merkitä, sillä se on aina <code>public</code>. Tutkitaan luettavuutta kuvaavaa rajapintaa <em>Luettava</em>.
</p>

<% partial 'partials/code_highlight' do %>
public interface Luettava {
    String lue();
}<% end %>

<p>
  Rajapinta <code>Luettava</code> määrittelee metodin <code>lue()</code>, joka palauttaa String-tyyppisen olion. Luettava kuvaa käyttäytymistä: esimerkiksi tekstiviesti tai sähköpostiviesti voi olla luettava.
</p>

<p>
  Rajapinnan toteuttavat luokat päättävät <em>miten</em> rajapinnassa määritellyt metodit toteutetaan. Luokka toteuttaa rajapinnan lisäämällä luokan nimen jälkeen avainsanan <em>implements</em>, jota seuraa rajapinnan nimi. Luodaan luokka <code>Tekstiviesti</code>, joka toteuttaa rajapinnan <code>Luettava</code>.
</p>

<% partial 'partials/code_highlight' do %>
public class Tekstiviesti implements Luettava {
    private String lahettaja;
    private String sisalto;

    public Tekstiviesti(String lahettaja, String sisalto) {
        this.lahettaja = lahettaja;
        this.sisalto = sisalto;
    }

    public String getLahettaja() {
        return this.lahettaja;
    }

    public String lue() {
        return this.sisalto;
    }
}
<% end %>

<p>
  Koska luokka <code>Tekstiviesti</code> toteuttaa rajapinnan <code>Luettava</code> (<code>public class Tekstiviesti implements Luettava</code>), on luokassa <code>Tekstiviesti</code> <em>pakko</em> olla metodin <code>public String lue()</code> toteutus. Rajapinnassa määriteltyjen metodien toteutuksilla tulee aina olla näkyvyysmääre public.
</p>


<% partial 'partials/hint', locals: { name: 'Rajapinta on sopimus käyttäytymisestä' } do %>

  <p>
    Kun luokka toteuttaa rajapinnan, se allekirjoittaa sopimuksen. Sopimuksessa luvataan, että luokka toteuttaa rajapinnan määrittelemät metodit. Jos metodeja ei ole luokassa toteutettu, ei ohjelma toimi.
  </p>

  <p>
    Rajapinta määrittelee vain vaadittujen metodien nimet, parametrit, ja paluuarvot. Rajapinta ei kuitenkaan ota kantaa metodien sisäiseen toteutukseen. Ohjelmoijan vastuulla on määritellä metodien sisäinen toiminnallisuus.
  </p>

<% end %>

<p>
  Toteutetaan luokan <code>Tekstiviesti</code> lisäksi toinen <code>Luettava</code> rajapinnan toteuttava luokka. Luokka <code>Sahkokirja</code> on sähköinen toteutus kirjasta, joka sisältää kirjan nimen ja sivut. Sähkökirjaa luetaan sivu kerrallaan, metodin <code>public String lue()</code> kutsuminen palauttaa aina seuraavan sivun merkkijonona.
</p>

<% partial 'partials/code_highlight' do %>
public class Sahkokirja implements Luettava {
    private String nimi;
    private ArrayList&lt;String&gt; sivut;
    private int sivunumero;

    public Sahkokirja(String nimi, ArrayList&lt;String&gt; sivut) {
        this.nimi = nimi;
        this.sivut = sivut;
        this.sivunumero = 0;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int sivuja() {
        return this.sivut.size();
    }

    public String lue() {
        String sivu = this.sivut.get(this.sivunumero);
        seuraavaSivu();
        return sivu;
    }

    private void seuraavaSivu() {
        this.sivunumero = this.sivunumero + 1;
        if(this.sivunumero % this.sivut.size() == 0) {
            this.sivunumero = 0;
        }
    }
}
<% end %>

<p>
  Rajapinnan toteuttavasta luokasta voi tehdä olioita aivan kuten normaaleistakin luokista, ja niitä voidaan käyttää myös esimerkiksi ArrayList-listojen tyyppinä.
</p>

<% partial 'partials/code_highlight' do %>
Tekstiviesti viesti = new Tekstiviesti("ope", "Huikeaa menoa!");
System.out.println(viesti.lue());

ArrayList&lt;Tekstiviesti&gt; tekstiviestit = new ArrayList&lt;&gt;();
tekstiviestit.add(new Tekstiviesti("tuntematon numero", "I hid the body.");
<% end %>

<% partial 'partials/sample_output' do %>
Huikeaa menoa!
<% end %>

<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
sivut.add("Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.");
sivut.add("Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.");

Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);
for (int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
    System.out.println(kirja.lue());
}
<% end %>

<% partial 'partials/sample_output' do %>
Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.
Erota käyttöliittymälogiikka sovelluksen logiikasta.
Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.
Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.
<% end %>

<% partial 'partials/hint', locals: { name: 'Mikä ihmeen for (int i = 0; ...?' } do %>

  <p>
    Yllä olevassa esimerkissä käytettiin toisenlaista toistolausetta alkioiden läpikäyntiin. Olemme tottuneet seuraavanlaiseen toistolauseeseen while-toistolauseeseen.
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
    sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
    sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
    sivut.add("Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.");
    sivut.add("Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.");

    Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);

    int sivu = 0;
    while (sivu &lt; kirja.sivuja()) {
        System.out.println(kirja.lue());
        sivu++;
    }
  <% end %>

  <p>
    Saman voi kirjoittaa myös for-toistolauseella seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
    sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
    sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
    sivut.add("Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.");
    sivut.add("Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.");

    Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);
    for (int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
  <% end %>

  
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Palvelusvelvollinen (2 osaa)' } do %>

  <p>
    Tehtäväpohjassa on valmiina rajapinta <code>Palvelusvelvollinen</code>, jossa on seuraavat toiminnot:
  </p>

  <ul>
    <li> metodi <code>int paiviaJaljella()</code> palauttaa jäljellä olevien palveluspäivien määrän</li>
    <li> metodi <code>void palvele()</code> vähentää yhden palveluspäivän. Palveluspäivien määrä ei saa mennä negatiiviseksi.</li>
  </ul>

  <% partial 'partials/code_highlight' do %>
public interface Palvelusvelvollinen {
    int paiviaJaljella();
    void palvele();
}
  <% end %>


  <h2>Sivari</h2>

  <p>
    Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Sivari</code>, jolla parametriton konstruktori. Luokalla on oliomuuttuja paivia, joka alustetaan konstruktorikutsun yhteydessä arvoon 362.
  </p>


  <h2>Asevelvollinen</h2>

  <p>
    Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Asevelvollinen</code>, jolla on parametrillinen konstruktori, jolla määritellään palvelusaika (<code>int paivia</code>).
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Rajapinta muuttujan tyyppinä
<% end %>

<p>
  Uutta muuttujaa esitellessä kerrotaan aina muuttujan tyyppi. Tyyppejä on kahdenlaisia, alkeistyyppiset muuttujat (int, double, ...) ja viittaustyyppiset muuttujat (kaikki oliot). Olemme tähän mennessä käyttäneet viittaustyyppisten muuttujien tyyppinä olion luokkaa.
</p>

<% partial 'partials/code_highlight' do %>
String merkkijono = "merkkijono-olio";
Tekstiviesti viesti = new Tekstiviesti("ope", "samalla oliolla monta tyyppiä");
<% end %>

<p>
  Olion tyyppi voi olla muutakin kuin sen luokka. Esimerkiksi rajapinnan <code>Luettava</code> toteuttavan luokan <code>Sahkokirja</code> tyyppi on sekä <code>Sahkokirja</code> että <code>Luettava</code>. Samalla tavalla myös tekstiviestillä on monta tyyppiä. Koska luokka <code>Tekstiviesti</code> toteuttaa rajapinnan <code>Luettava</code>, on sillä tyypin <code>Tekstiviesti</code> lisäksi myös tyyppi <code>Luettava</code>.
</p>

<% partial 'partials/code_highlight' do %>
Tekstiviesti viesti = new Tekstiviesti("ope", "Kohta tapahtuu huikeita");
Luettava luettava = new Tekstiviesti("ope", "Tekstiviesti on Luettava!");
<% end %>

<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
sivut.add("Metodi voi kutsua itse itseään.");

Luettava kirja = new Sahkokirja("Rekursion alkeet.", sivut);
for (int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
    System.out.println(kirja.lue());
}
<% end %>

<p>
  Koska rajapintaa voidaan käyttää tyyppinä, on mahdollista luoda rajapintaluokan tyyppisiä olioita sisältävä lista.
</p>

<% partial 'partials/code_highlight' do %>
ArrayList&lt;Luettava&gt; lukulista = new ArrayList&lt;&gt;();

lukulista.add(new Tekstiviesti("ope", "never been programming before..."));
lukulista.add(new Tekstiviesti("ope", "gonna love it i think!"));
lukulista.add(new Tekstiviesti("ope", "give me something more challenging! :)"));
lukulista.add(new Tekstiviesti("ope", "you think i can do it?"));
lukulista.add(new Tekstiviesti("ope", "up here we send several messages each day"));


ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
sivut.add("Metodi voi kutsua itse itseään.");

lukulista.add(new Sahkokirja("Rekursion alkeet.", sivut));

lukulista.stream().forEach(l -&gt; System.out.println(l.lue()));
<% end %>

<p>
  Huomaa että vaikka rajapinnan <code>Luettava</code> toteuttava luokka <code>Sahkokirja</code> on aina rajapinnan tyyppinen, eivät kaikki <code>Luettava</code>-rajapinnan toteuttavat luokat ole tyyppiä <code>Sahkokirja</code>. Luokasta <code>Sahkokirja</code> tehdyn olion asettaminen <code>Luettava</code>-tyyppiseen muuttujaan onnistuu, mutta toiseen suuntaan asetus ei ole sallittua ilman erillistä tyyppimuunnosta.
</p>

<% partial 'partials/code_highlight' do %>
Luettava luettava = new Tekstiviesti("ope", "Tekstiviesti on Luettava!"); // toimii
Tekstiviesti viesti = luettava; // ei toimi

Tekstiviesti muunnettuViesti = (Tekstiviesti) luettava; // toimii jos ja vain jos
                                                        // luettava on tyyppiä Tekstiviesti
<% end %>

<p>
  Tyyppimuunnos onnistuu jos ja vain jos muuttuja on oikeastikin sitä tyyppiä johon sitä yritetään muuntaa. Tyyppimuunnoksen käyttöä ei yleisesti suositella, ja lähes ainut sallittu paikka sen käyttöön on <code>equals</code>-metodin toteutuksessa.
</p>

<% partial 'partials/material_sub_heading' do %>
  Rajapinta metodin parametrina
<% end %>


<p>
  Rajapintojen todelliset hyödyt tulevat esille kun niitä käytetään metodille annettavan parametrin tyyppinä. Koska rajapintaa voidaan käyttää muuttujan tyyppinä, voidaan sitä käyttää metodikutsuissa parametrin tyyppinä. Esimerkiksi seuraavan luokan <code>Tulostin</code> metodi <code>tulosta</code> saa parametrina <code>Luettava</code>-tyyppisen muuttujan.
</p>

<% partial 'partials/code_highlight' do %>
public class Tulostin {
    public void tulosta(Luettava luettava) {
        System.out.println(luettava.lue());
    }
}
<% end %>

<p>
  Luokan <code>Tulostin</code> tarjoaman metodin <code>tulosta</code> huikeus piilee siinä, että sille voi antaa parametrina <em>minkä tahansa</em> <code>Luettava</code>-rajapinnan toteuttavan luokan ilmentymän. Kutsummepa metodia millä tahansa Luettava-luokan toteuttaneen luokan oliolla, metodi osaa toimia oikein.
</p>

<% partial 'partials/code_highlight' do %>
Tekstiviesti viesti = new Tekstiviesti("ope", "Huhhuh, tää tulostinkin osaa tulostaa näitä!");

ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
sivut.add("Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisiä lukuja ovat {3, 5}.");
Sahkokirja kirja = new Sahkokirja("Yliopistomatematiikan perusteet.", sivut);

Tulostin tulostin = new Tulostin();
tulostin.tulosta(viesti);
tulostin.tulosta(kirja);
<% end %>

<% partial 'partials/sample_output' do %>
Huhhuh, tää tulostinkin osaa tulostaa näitä!
Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisiä lukuja ovat {3, 5}.
<% end %>

<p>
  Toteutetaan toinen luokka <code>Lukulista</code>, johon voidaan lisätä mielenkiintoisia luettavia asioita. Luokalla on oliomuuttujana <code>ArrayList</code>-luokan ilmentymä, johon luettavia asioita tallennetaan. Lukulistaan lisääminen tapahtuu <code>lisaa</code>-metodilla, joka saa parametrikseen <code>Luettava</code>-tyyppisen olion.
</p>

<% partial 'partials/code_highlight' do %>
public class Lukulista {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }
}
<% end %>

<p>
  Lukulistat ovat yleensä luettavia, joten toteutetaan luokalle <code>Lukulista</code> rajapinta <code>Luettava</code>. Lukulistan <code>lue</code>-metodi lukee kaikki <code>luettavat</code>-listalla olevat oliot läpi, ja lisää yksitellen niiden <code>lue()</code>-metodin palauttaman merkkijonoon.
</p>

<% partial 'partials/code_highlight' do %>
public class Lukulista implements Luettava {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }

    public String lue() {
        String luettu = this.luettavat.stream()
            .reduce("", (a, luettava) -&gt; a + luettava.lue() + "\n");

        // yllä oleva on sama kuin
        /*
        String luettu = "";
        for (int i = 0; i &lt; this.luettavat.size(); i++) {
            luettu += this.luettavat.get(i).lue() + "\n";
        }
        */

        // kun lukulista on luettu, tyhjennetään se
        this.luettavat.clear();
        return luettu;
    }
}
<% end %>


<% partial 'partials/code_highlight' do %>
Lukulista joninLista = new Lukulista();
joninLista.lisaa(new Tekstiviesti("arto", "teitkö jo testit?"));
joninLista.lisaa(new Tekstiviesti("arto", "katsoitko jo palautukset?"));

System.out.println("Jonilla luettavia: " + joninLista.luettavia());
<% end %>

<% partial 'partials/sample_output' do %>
Jonilla luettavia: 2
<% end %>


<p>
  Koska <code>Lukulista</code> on tyyppiä <code>Luettava</code>, voi lukulistalle lisätä <code>Lukulista</code>-olioita. Alla olevassa esimerkissä Jonilla on paljon luettavaa. Onneksi Verna tulee hätiin ja lukee viestit Jonin puolesta.
</p>

<% partial 'partials/code_highlight' do %>
Lukulista joninLista = new Lukulista();
for (int i = 0; i &lt; 1000; i++) {
    joninLista.lisaa(new Tekstiviesti("arto", "teitkö jo testit?"));
}

System.out.println("Jonilla luettavia: " + joninLista.luettavia());
System.out.println("Delegoidaan lukeminen Vernalle");

Lukulista vernanLista = new Lukulista();
vernanLista.lisaa(joninLista);
vernanLista.lue();

System.out.println();
System.out.println("Jonilla luettavia: " + joninLista.luettavia());
<% end %>

<% partial 'partials/sample_output' do %>
Jonilla luettavia: 1000
Delegoidaan lukeminen Vernalle

Jonilla luettavia: 0
<% end %>

<p>
  Ohjelmassa Vernan listalle kutsuttu <code>lue</code>-metodi käy kaikki sen sisältämät <code>Luettava</code>-oliot läpi, ja kutsuu niiden <code>lue</code>-metodia. Kutsuttaessa <code>lue</code>-metodia Vernan listalle käydään myös Vernan lukulistalla oleva Jonin lukulista läpi. Jonin lukulista käydään läpi kutsumalla sen <code>lue</code>-metodia. Jokaisen <code>lue</code>-metodin kutsun lopussa tyhjennetään juuri luettu lista. Eli Jonin lukulista tyhjenee kun Verna lukee sen.
</p>

<p>
  Kuten huomaat, ohjelmassa on jo hyvin paljon viitteitä. Kannattaa piirtää ohjelman tilaa askeleittain paperille, ja hahmotella miten <code>vernanLista</code>-oliolle tapahtuva metodikutsu <code>lue</code> etenee!
</p>

<% partial 'partials/hint', locals: { name: 'Mikä ihmeen reduce?' } do %>

  <p>
    Edellisessä esimerkissä käytettiin virtaan liittyvää reduce-metodia. Reduce-metodi on hyödyllinen kun virrassa olevat alkiot halutaan yhdistää jonkinlaiseen toiseen muotoon. Metodin saamat parametrit ovat seuraavaa muotoa: <code>reduce(<em>alkutila</em>, (<em>edellinen</em>, <em>olio</em>) -&gt; <em>mitä oliolla tehdään</em>)</code>.
  </p>

  <p>
    Esimerkiksi kokonaislukuja sisältävän listan summan saa luotua reduce-metodin avulla seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
luvut.add(7);
luvut.add(3);
luvut.add(2);
luvut.add(1);

int summa = luvut.stream()
    .reduce(0, (edellinenSumma, luku) -&gt; edellinenSumma + luku);
System.out.println(summa);
  <% end %>

  <% partial 'partials/sample_output' do %>
13
  <% end %>

  <p>
    Vastaavasti merkkijonoista koostuvasta listasta saa luotua rivitetyn merkkijonon seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; sanat = new ArrayList&lt;&gt;();
sanat.add("Eka");
sanat.add("Toka");
sanat.add("Kolmas");
sanat.add("Neljäs");

String yhdistetty = sanat.stream()
    .reduce("", (edellinenMjono, sana) -&gt; edellinenMjono + sana + "\n");
System.out.println(yhdistetty);
  <% end %>

  <% partial 'partials/sample_output' do %>
Eka
Toka
Kolmas
Neljäs
  <% end %>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Tavaroita ja laatikoita (4 osaa)' } do %>

  <h2>Talletettavia</h2>

  <p>
    Muuton yhteydessa tarvitaan muuttolaatikoita. Laatikoihin talletetaan erilaisia esineitä. Kaikkien laatikoihin talletettavien esineiden on toteutettava seuraava rajapinta:
  </p>

  <% partial 'partials/code_highlight' do %>
public interface Talletettava {
    double paino();
}
  <% end %>

  <p>
    Lisää rajapinta ohjelmaasi. Rajapinta lisätään melkein samalla tavalla kuin luokka, <i>new Java class</i> sijaan valitaan <i>new Java interface</i>.
  </p>

  <p>
    Tee rajapinnan toteuttavat luokat <code>Kirja</code> ja <code>CDLevy</code>. Kirja saa konstruktorin parametreina kirjan kirjoittajan (String), kirjan nimen (String), ja kirjan painon (double). CD-Levyn konstruktorin parametreina annetaan artisti (String), levyn nimi (String), ja julkaisuvuosi (int). Kaikkien CD-levyjen paino on 0.1 kg.
  </p>

  <p>
    Muista toteuttaa luokilla myös rajapinta <code>Talletettava</code>. Luokkien tulee toimia seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
public static void main(String[] args) {
    Kirja kirja1 = new Kirja("Fedor Dostojevski", "Rikos ja Rangaistus", 2);
    Kirja kirja2 = new Kirja("Robert Martin", "Clean Code", 1);
    Kirja kirja3 = new Kirja("Kent Beck", "Test Driven Development", 0.5);

    CDLevy cd1 = new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
    CDLevy cd2 = new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
    CDLevy cd3 = new CDLevy("Rendezvous Park", "Closer to Being Here", 2012);

    System.out.println(kirja1);
    System.out.println(kirja2);
    System.out.println(kirja3);
    System.out.println(cd1);
    System.out.println(cd2);
    System.out.println(cd3);
}
  <% end %>

  <p>
    Tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Fedor Dostojevski: Rikos ja Rangaistus
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
  <% end %>

  <p>
    Huom! Painoa ei ilmoiteta tulostuksessa.
  </p>


  <h2>Laatikko</h2>

  <p>
    Tee luokka laatikko, jonka sisälle voidaan tallettaa <code>Talletettava</code>-rajapinnan toteuttavia tavaroita. Laatikko saa konstruktorissaan parametrina laatikon maksimikapasiteetin kiloina. Laatikkoon ei saa lisätä enempää tavaraa kuin sen maksimikapasiteetti määrää. Laatikon sisältämien tavaroiden paino ei siis koskaan saa olla yli laatikon maksimikapasiteetin.
  </p>

  <p>
    Seuraavassa esimerkki laatikon käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
public static void main(String[] args) {
    Laatikko laatikko = new Laatikko(10);

    laatikko.lisaa(new Kirja("Fedor Dostojevski", "Rikos ja Rangaistus", 2)) ;
    laatikko.lisaa(new Kirja("Robert Martin", "Clean Code", 1));
    laatikko.lisaa(new Kirja("Kent Beck", "Test Driven Development", 0.7));

    laatikko.lisaa(new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973));
    laatikko.lisaa(new CDLevy("Wigwam", "Nuclear Nightclub", 1975));
    laatikko.lisaa(new CDLevy("Rendezvous Park", "Closer to Being Here", 2012));

    System.out.println(laatikko);
}
  <% end %>

  <p>
    Tulostuu
  </p>

  <% partial 'partials/sample_output' do %>
Laatikko: 6 esinettä, paino yhteensä 4.0 kiloa
  <% end %>

  <p>
    Huom: koska painot esitetään doubleina, saattaa laskutoimituksissa tulla pieniä pyöristysvirheitä. Tehtävässä ei tarvitse välittää niistä.
  </p>


  <h2>Laatikon paino</h2>

  <p>
    Jos teit laatikon sisälle oliomuuttujan <code>double paino</code>, joka muistaa laatikossa olevien esineiden painon, korvaa se metodilla, joka laskee painon:
  </p>

  <% partial 'partials/code_highlight' do %>
public class Laatikko {
    //...

    public double paino() {
        double paino = 0;
        // laske laatikkoon talletettujen tavaroiden yhteispaino
        return paino;
    }
}<% end %>

  <p>
    Kun tarvitset laatikon sisällä painoa esim. uuden tavaran lisäyksen yhteydessä, riittää siis kutsua laatikon painon laskevaa metodia.
  </p>

  <p>
    Metodi voisi palauttaa myös oliomuuttujan arvon. Harjoittelemme tässä kuitenkin tilannetta, jossa oliomuuttujaa ei tarvitse eksplisiittisesti ylläpitää vaan se voidaan tarpeentullen laskea. Seuraavan tehtävän jälkeen laatikossa olevaan oliomuuttujaan talletettu painotieto ei kuitenkaan välttämättä enää toimisi. Pohdi tehtävän tekemisen jälkeen miksi näin on.
  </p>


  <h2>Laatikkokin on talletettava!</h2>

  <p>
    Rajapinnan <code>Talletettava</code> toteuttaminen siis edellyttää että luokalla on metodi <code>double paino()</code>. Laatikollehan lisättiin juuri tämä metodi. Laatikosta voidaan siis tehdä talletettava!
  </p>

  <p>
    Laatikot ovat olioita joihin voidaan laittaa <code>Talletettava</code>-rajapinnan toteuttavia olioita. Laatikot toteuttavat itsekin rajapinnan. Eli <b>laatikon sisällä voi olla myös laatikoita!</b>
  </p>

  <p>
    Kokeile että näin varmasti on, eli tee ohjelmassasi muutama laatikko, laita laatikoihin tavaroita ja laita pienempiä laatikoita isompien laatikoiden sisään. Kokeile myös mitä tapahtuu kun laitat laatikon itsensä sisälle. Miksi näin käy?
  </p>

<% end %>



<% partial 'partials/material_sub_heading' do %>
  Rajapinta metodin paluuarvona
<% end %>

<p>
  Kuten mitä tahansa muuttujan tyyppiä, myös rajapintaa voi käyttää metodin paluuarvona. Seuraavassa <code>Tehdas</code>, jota voi pyytää valmistamaan erilaisia <code>Talletettava</code>-rajapinnan toteuttavia oliota. Tehdas valmistaa aluksi satunnaisesti kirjoja ja levyjä.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.Random;

public class Tehdas {

    public Tehdas() {
        // HUOM: parametritonta tyhjää konstruktoria ei ole pakko kirjoittaa,
        // jos luokalla ei ole muita konstruktoreja
        // Java tekee automaattisesti tälläisissä tilanteissa luokalle oletuskonstruktorin
        // eli parametrittoman tyhjän konstruktorin
    }

    public Talletettava valmistaUusi() {
        // Tässä käytettyä Random-oliota voi käyttää satunnaisten lukujen arpomiseen
        Random arpa = new Random();
        // arpoo luvun väliltä [0, 4[. Luvuksi tulee 0, 1, 2 tai 3.
        int luku = arpa.nextInt(4);

        if (luku == 0) {
            return new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
        } else if (luku == 1) {
            return new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
        } else if (luku == 2) {
            return new Kirja("Robert Martin", "Clean Code", 1);
        } else {
            return new Kirja("Kent Beck", "Test Driven Development", 0.7);
        }
    }
}
<% end %>

<p>
  Tehdasta on mahdollista käyttää tuntematta tarkalleen mitä erityyppisiä Talletettava-rajapinnan luokkia on olemassa. Seuraavassa luokka Pakkaaja, jolta voi pyytää laatikollisen esineitä. Pakkaaja tuntee tehtaan, jota se pyytää luomaan esineet:
</p>

<% partial 'partials/code_highlight' do %>
public class Pakkaaja {
    private Tehdas tehdas;

    public Pakkaaja() {
        this.tehdas = new Tehdas();
    }

    public Laatikko annaLaatikollinen() {
         Laatikko laatikko = new Laatikko(100);

         for (int i = 0; i &lt; 10; i++) {
             Talletettava uusiTavara = tehdas.valmistaUusi();
             laatikko.lisaa(uusiTavara);
         }

         return laatikko;
    }
}
<% end %>

<p>
  Koska pakkaaja ei tunne rajapinnan Talletettava toteuttavia luokkia, on ohjelmaan mahdollisuus lisätä uusia luokkia jotka toteuttavat rajapinnan ilman tarvetta muuttaa pakkaajaa. Seuraavassa on luotu uusi Talletettava-rajapinnan toteuttava luokka, <code>Suklaalevy</code>. Tehdasta on muutettu siten, että se luo kirjojen ja cd-levyjen lisäksi suklaalevyjä. Luokka <code>Pakkaaja</code> toimii muuttamatta tehtaan laajennetun version kanssa.
</p>

<% partial 'partials/code_highlight' do %>
public class Suklaalevy implements Talletettava {
    // koska Javan generoima oletuskonstruktori riittää, emme tarvitse konstruktoria!

    public double paino() {
        return 0.2;
    }
}
<% end %>

<% partial 'partials/code_highlight' do %>
import java.util.Random;

public class Tehdas {
    // koska Javan generoima oletuskonstruktori riittää, emme tarvitse konstruktoria!

    public Talletettava valmistaUusi() {

        Random arpa = new Random();
        int luku = arpa.nextInt(5);

        if (luku == 0) {
            return new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
        } else if (luku == 1) {
            return new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
        } else if (luku == 2) {
            return new Kirja("Robert Martin", "Clean Code", 1 );
        } else if (luku == 3) {
            return new Kirja("Kent Beck", "Test Driven Development", 0.7);
        } else {
            return new Suklaalevy();
        }
    }
}
<% end %>


<% partial 'partials/hint', locals: { name: 'Luokkien välisten riippuvuuksien vähentäminen' } do %>

  <p>
    Rajapintojen käyttö ohjelmoinnissa mahdollistaa luokkien välisten riippuvaisuuksien vähentämisen. Esimerkissämme Pakkaaja ei ole riippuvainen rajapinnan Talletettava-toteuttavista luokista vaan ainoastaan rajapinnasta. Tämä mahdollistaa rajapinnan toteuttavien luokkien lisäämisen ohjelmaan ilman tarvetta muuttaa luokkaa Pakkaaja. Myöskään pakkaaja-luokkaa käyttäviin luokkiin uusien Talletettava-rajapinnan toteuttavien luokkien lisääminen ei vaikuta.
  </p>

  <p>
    Vähäisemmät riippuvuudet helpottavat ohjelman laajennettavuutta.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Valmiit rajapinnat
<% end %>

<p>
  Javan API tarjoaa huomattavan määrän valmiita rajapintoja. Tutustutaan tässä neljään usein käytettyyn rajapintaan: <code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a></code>, <code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html" target="_blank" rel="noopener">Map</a></code>, <code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html" target="_blank" rel="noopener">Set</a></code> ja <code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="noopener">Collection</a></code>.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  List-rajapinta
<% end %>


<p>
  Rajapinta <a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a> määrittelee listoihin liittyvän peruskäyttäytymisen. Koska ArrayList-luokka toteuttaa <code>List</code>-rajapinnan, voi sitä käyttää myös <code>List</code>-rajapinnan kautta.
</p>

<% partial 'partials/code_highlight' do %>
List&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
merkkijonot.add("merkkijono-olio arraylist-oliossa!");
<% end %>

<p>
  Kuten huomaamme <a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html">List-rajapinnan Java API</a>:sta, rajapinnan <code>List</code> toteuttavia luokkia on useita. Eräs tietojenkäsittelijöille tuttu listarakenne on linkitetty lista (<a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener">linked list</a>). Linkitettyä listaa voi käyttää rajapinnan List-kautta täysin samoin kuin ArrayLististä luotua oliota.
</p>

<% partial 'partials/code_highlight' do %>
List&lt;String&gt; merkkijonot = new LinkedList&lt;&gt;();
merkkijonot.add("merkkijono-olio linkedlist-oliossa!");
<% end %>

<p>
  Molemmat rajapinnan <code>List</code> toteutukset toimivat käyttäjän näkökulmasta samoin. Rajapinta siis <em>abstrahoi</em> niiden sisäisen toiminnallisuuden. ArrayListin ja LinkedListin sisäinen rakenne on kuitenkin huomattavan erilainen. ArrayList tallentaa alkioita taulukkoon, josta tietyllä indeksillä hakeminen on nopeaa. LinkedList taas rakentaa listan, jossa jokaisessa listan alkiossa on viite seuraavan listan alkioon. Kun linkitetyssä listassa haetaan alkiota tietyllä indeksillä, tulee listaa käydä läpi alusta indeksiin asti.
</p>

<p>
  Isoilla listoille voimme nähdä huomattaviakin suorituskykyeroja. Linkitetyn listan vahvuutena on se, että listaan lisääminen on aina nopeaa. ArrayListillä taas taustalla on taulukko, jota täytyy kasvattaa aina kun se täyttyy. Taulukon kasvattaminen vaatii uuden taulukon luonnin ja vanhan taulukon tietojen kopioinnin uuteen taulukkoon. Toisaalta, indeksin perusteella hakeminen on Arraylististä erittäin nopeaa, kun taas linkitetyssä listassa joudutaan käymään listan alkioita yksitellen läpi tiettyyn indeksiin pääsemiseksi.
</p>

<p>
  Tällä ohjelmointikurssilla eteen tulevissa tilanteissa kannattanee käytännössä valita aina ArrayList. "Rajapintoihin ohjelmointi" kuitenkin kannattaa: toteuta ohjelmasi siten, että käytät tietorakenteita rajapintojen kautta.
</p>

<% partial 'partials/exercise', locals: { name: 'List metodin parametrina' } do %>

  <p>
    Toteuta luokkaan <code>ListanTarkistin</code> metodi <code>palautaKoko</code>, joka saa parametrina List-olion ja palauttaa sen koon kokonaislukuna.
  </p>

  <p>
    Metodin tulee toimia esimerkiksi seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
List&lt;String&gt; nimet = new ArrayList&lt;&gt;();
nimet.add("eka");
nimet.add("toka");
nimet.add("kolmas");

System.out.println(new ListanTarkistin().palautaKoko(nimet));
  <% end %>

  <% partial 'partials/sample_output' do %>
3
  <% end %>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Map-rajapinta
<% end %>

<p>
  Rajapinta <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Map</a> määrittelee hajautustauluihin liittyvän peruskäyttäytymisen. Koska HashMap-luokka toteuttaa <code>Map</code>-rajapinnan, voi sitä käyttää myös <code>Map</code>-rajapinnan kautta.
</p>

<% partial 'partials/code_highlight' do %>
Map&lt;String, String&gt; kaannokset = new HashMap&lt;&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");
<% end %>

<p>
  Hajautustaulun avaimet saa hajautustaulusta <code>keySet</code>-metodin avulla.
</p>

<% partial 'partials/code_highlight' do %>
Map&lt;String, String&gt; kaannokset = new HashMap&lt;&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

kaannokset.keySet().stream()
    .forEach(avain -&gt; System.out.println(avain + ": " + kaannokset.get(avain)));
<% end %>

<% partial 'partials/sample_output' do %>
gambatte: tsemppiä
hai: kyllä
<% end %>

<p>
  Metodi <code>keySet</code> palauttaa <code>Set</code>-rajapinnan toteuttavan joukon alkioita. <code>Set</code>-rajapinnan toteuttavan joukon voi käydä läpi virtana. Hajautustaulusta saa talletetut arvot metodin <code>values</code>-avulla. Metodi <code>values</code> palauttaa <code>Collection</code> rajapinnan toteuttavan joukon alkioita. Tutustutaan vielä pikaisesti Set- ja Collection-rajapintoihin.
</p>


<% partial 'partials/exercise', locals: { name: 'Map metodin parametrina' } do %>

  <p>
    Toteuta luokkaan <code>HajautustaulunTarkistin</code> metodi <code>palautaKoko</code>, joka saa parametrina Map-olion ja palauttaa sen koon kokonaislukuna.
  </p>

  <p>Metodin tulee toimia esimerkiksi seuraavasti:</p>

  <% partial 'partials/code_highlight' do %>
Map&lt;String, String&gt; nimet = new HashMap&lt;&gt;();
nimet.put("eka", "first");
nimet.put("toka", "second");

System.out.println(new HajautustaulunTarkistin().palautaKoko(nimet));
  <% end %>

  <% partial 'partials/sample_output' do %>
2
  <% end %>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Set-rajapinta
<% end %>

<p>
  Rajapinta <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html" target="_blank" rel="noopener">Set</a> kuvaa joukkoihin liittyvää toiminnallisuutta. Javassa joukot sisältävät aina joko 0 tai 1 kappaletta tiettyä oliota. Set-rajapinnan toteuttaa muun muassa <code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" target="_blank" rel="noopener">HashSet</a></code>. Joukon alkioita pystyy käymään läpi seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
Set&lt;String&gt; joukko = new HashSet&lt;&gt;();
joukko.add("yksi");
joukko.add("yksi");
joukko.add("kaksi");

joukko.stream().forEach(alkio -&gt; System.out.println(alkio));
<% end %>

<% partial 'partials/sample_output' do %>
yksi
kaksi
<% end %>

<p>
  Huomaa että HashSet ei ota millään tavalla kantaa joukon alkioiden järjestykseen.
</p>


<% partial 'partials/exercise', locals: { name: 'Set metodin parametrina' } do %>

  <p>
    Toteuta luokkaan <code>JoukonTarkistin</code> metodi <code>palautaKoko</code>, joka saa parametrina Set-olion ja palauttaa sen koon kokonaislukuna.
  </p>

  <p>
    Metodin tulee toimia esimerkiksi seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
Set&lt;String&gt; nimet = new HashSet&lt;&gt;();
nimet.add("eka");
nimet.add("eka");
nimet.add("toka");
nimet.add("toka");
nimet.add("toka");

System.out.println(new JoukonTarkistin().palautaKoko(nimet));
  <% end %>

  <p>
    Tulostaa:
  </p>

  <% partial 'partials/sample_output' do %>
2
  <% end %>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Collection-rajapinta
<% end %>

<p>
  Rajapinta <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="noopener">Collection</a> kuvaa kokoelmiin liittyvää toiminnallisuutta. Javassa muun muassa listat ja joukot ovat kokoelmia -- rajapinnat List ja Set toteuttavat rajapinnan Collection. Kokoelmarajapinta tarjoaa metodit muun muassa alkioiden olemassaolon tarkistamiseen (metodi <code>contains</code>) ja kokoelman koon tarkistamiseen (metodi <code>size</code>).
</p>

<p>
  Collection-rajapinta määrää myös virtatoteutuksesta. Jokaisella luokalla, joka toteuttaa Collection-rajapinnan joko välillisesti tai suoraan, tulee olla virran luomiseen käytettävä metodi <code>stream</code>.
</p>

<p>
  Luodaan vielä hajautustaulu ja käydään erikseen läpi siihen liittyvät avaimet ja arvot.
</p>

<% partial 'partials/code_highlight' do %>
Map&lt;String, String&gt; kaannokset = new HashMap&lt;&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

Set&lt;String&gt; avaimet = kaannokset.keySet();
Collection&lt;String&gt; avainKokoelma = avaimet;

System.out.println("Avaimet:");
avainKokoelma.stream().forEach(avain -&gt; System.out.println(avain));

System.out.println();
System.out.println("Arvot:");
Collection&lt;String&gt; arvot = kaannokset.values();
arvot.stream().forEach(arvo -&gt; System.out.println(arvo));
<% end %>

<% partial 'partials/sample_output' do %>
Avaimet:
gambatte
hai

Arvot:
kyllä
tsemppiä
<% end %>

<p>
  Seuraavassa tehtävässä rakennetaan verkkokauppaan liittyvää toiminnallisuutta ja harjoitellaan luokkien käyttämistä niiden tarjoamien rajapintojen kautta.
</p>

<% partial 'partials/exercise', locals: { name: 'Verkkokauppa (8 osaa)' } do %>

  <p>
    Teemme tehtävässä muutamia verkkokaupan hallinnointiin soveltuvia ohjelmakomponentteja.
  </p>


  <h2>Varasto</h2>

  <p>
    Tee luokka Varasto jolla on seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaaTuote(String tuote, int hinta, int saldo)</code> lisää varastoon tuotteen jonka hinta ja varastosaldo ovat parametrina annetut luvut</li>
    <li><code>public int hinta(String tuote)</code> palauttaa parametrina olevan tuotteen hinnan, jos tuotetta ei ole varastossa, palauttaa metodi -99</li>
  </ul>

  <p>
    Varaston sisällä tuotteiden hinnat (ja seuraavassa kohdassa saldot) tulee tallettaa <code>Map&lt;String, Integer&gt;</code>-tyyppiseksi määriteltyyn muuttujaan! Luotava olio voi olla tyypiltään <code>HashMap</code>, muuttujan tyyppinä on käytettävä <code>Map</code>-rajapintaa.
  </p>

  <p>
    Seuraavassa esimerkki varaston käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
Varasto varasto = new Varasto();
varasto.lisaaTuote("maito", 3, 10);
varasto.lisaaTuote("kahvi", 5, 7);

System.out.println("hinnat:");
System.out.println("maito: " + varasto.hinta("maito"));
System.out.println("kahvi: " + varasto.hinta("kahvi"));
System.out.println("sokeri: " + varasto.hinta("sokeri"));
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
hinnat:
maito: 3
kahvi: 5
sokeri: -99
  <% end %>


  <h2>Tuotteen varastosaldo</h2>

  <p>
    Aseta tuotteiden varastosaldot samaan tapaan <code>Map&lt;String, Integer&gt;</code>-tyyppiseen muuttujaan kuin hinnat. Täydennä varastoa seuraavilla metodeilla:
  </p>

  <ul>
    <li><code>public int saldo(String tuote)</code> palauttaa parametrina olevan tuotteen varastosaldon. Jos tuotetta ei ole varastossa lainkaan, tulee palauttaa 0.</li>
    <li><code>public boolean ota(String tuote)</code> vähentää parametrina olevan tuotteen saldoa yhdellä ja palauuttaa <em>true</em> jos tuotetta oli varastossa. Jos tuotetta ei ole varastossa, palauttaa metodi <em>false</em>, tuotteen saldo ei saa laskea alle nollan.</li>
  </ul>

  <p>
    Esimerkki varaston käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
Varasto varasto = new Varasto();
varasto.lisaaTuote("kahvi", 5, 1);

System.out.println("saldot:");
System.out.println("kahvi:  " + varasto.saldo("kahvi"));
System.out.println("sokeri: " + varasto.saldo("sokeri"));

System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
System.out.println("otetaan sokeri " + varasto.ota("sokeri"));

System.out.println("saldot:");
System.out.println("kahvi:  " + varasto.saldo("kahvi"));
System.out.println("sokeri: " + varasto.saldo("sokeri"));
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
saldot:
kahvi:  1
sokeri: 0
otetaan kahvi true
otetaan kahvi false
otetaan sokeri false
saldot:
kahvi:  0
sokeri: 0
  <% end %>


  <h2>Tuotteiden listaus</h2>

  <p>
    Listätään varastolle vielä yksi metodi:
  </p>

  <ul>
    <li><code>public Set&lt;String&gt; tuotteet()</code> palauttaa <em>joukkona</em> varastossa olevien tuotteiden nimet.</li>
  </ul>

  <p>
    Metodi on helppo toteuttaa HashMapin avulla. Saat tietoon varastossa olevat tuotteet kysymällä ne joko hinnat tai saldot muistavalta Map:iltä metodin <code>keySet</code> avulla.
  </p>

  <p>
    Esimerkki varaston käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
Varasto varasto = new Varasto();
varasto.lisaaTuote("maito", 3, 10);
varasto.lisaaTuote("kahvi", 5, 6);
varasto.lisaaTuote("piimä", 2, 20);
varasto.lisaaTuote("jugurtti", 2, 20);

System.out.println("tuotteet:");
varasto.tuotteet().stream().forEach(t -&gt; System.out.println(t));
  <% end %>

  <% partial 'partials/sample_output' do %>
tuotteet:
piimä
jugurtti
kahvi
maito
  <% end %>


  <h2>Ostos</h2>

  <p>
    Ostoskoriin lisätään <em>ostoksia</em>. Ostoksella tarkoitetaan tiettyä määrää tiettyjä tuotteita. Koriin voidaan laittaa esim. ostos joka vastaa yhtä leipää tai ostos joka vastaa 24:ää kahvia.
  </p>

  <p>
    Tee luokka <code>Ostos</code> jolla on seuraavat toiminnot:
  </p>

  <ul>
    <li><code>public Ostos(String tuote, int kpl, int yksikkohinta)</code> konstruktori joka luo ostoksen joka vastaa parametrina annettua tuotetta. Tuotteita ostoksessa on <em>kpl</em> kappaletta ja yhden tuotteen hinta on kolmantena parametrina annettu <em>yksikkohinta</em></li>
    <li><code>public int hinta()</code> palauttaa ostoksen hinnan. Hinta saadaan kertomalla kappalemäärä yksikköhinnalla</li>
    <li><code>public void kasvataMaaraa()</code> kasvattaa ostoksen kappalemäärää yhdellä</li>
    <li><code>public String toString()</code> palauttaa ostoksen merkkijonomuodossa, joka on alla olevan esimerkin mukainen</li>
  </ul>

  <p>
    Esimerkki ostos-luokan käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
Ostos ostos = new Ostos("maito", 4, 2);
System.out.println("ostoksen joka sisältää 4 maitoa yhteishinta on " + ostos.hinta());
System.out.println(ostos);
ostos.kasvataMaaraa();
System.out.println(ostos);
  <% end %>

  <% partial 'partials/sample_output' do %>
ostoksen joka sisältää 4 maitoa yhteishinta on 8
maito: 4
maito: 5
  <% end %>

  <p>
    Huom: <em>toString</em> on siis muotoa <em>tuote: kpl</em> hintaa ei merkkijonoesitykseen tule!
  </p>


  <h2>Ostoskori</h2>

  <p>
    Vihdoin pääsemme toteuttamaan luokan ostoskori!
  </p>

  <p>
    Ostoskori tallettaa sisäisesti koriin lisätyt tuotteet <em>Ostos-olioina</em>. Ostoskorilla tulee olla oliomuuttuja jonka tyyppi on joko <code>Map&lt;String, Ostos&gt;</code> tai <code>List&lt;Ostos&gt;</code>. Älä laita mitään muita oliomuuttujia ostoskorille kuin ostosten talletukseen tarvittava Map tai List.
  </p>

  <p>
    Huom: jos talletat Ostos-oliot Map-tyyppiseen apumuuttujaan, on tässä ja seuraavassa tehtävässä hyötyä Map:in metodista values(), jonka avulla on helppo käydä läpi kaikki talletetut ostos-oliot.
  </p>

  <p>
    Tehdään aluksi ostoskorille parametriton konstruktori ja metodit:
  </p>

  <ul>
    <li><code>public void lisaa(String tuote, int hinta)</code> lisää ostoskoriin ostoksen joka vastaa parametrina olevaa tuotetta ja jolla on parametrina annettu hinta.</li>
    <li><code>public int hinta()</code> palauttaa ostoskorin kokonaishinnan</li>
  </ul>

  <p>
    Esimerkki ostoskorin käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
Ostoskori kori = new Ostoskori();
kori.lisaa("maito", 3);
kori.lisaa("piimä", 2);
kori.lisaa("juusto", 5);
System.out.println("korin hinta: " + kori.hinta());
kori.lisaa("tietokone", 899);
System.out.println("korin hinta: " + kori.hinta());
  <% end %>

  <% partial 'partials/sample_output' do %>
korin hinta: 10
korin hinta: 909
  <% end %>


  <h2>Ostoskorin tulostus</h2>

  <p>
    Tehdään ostoskorille metodi <code>public void tulosta()</code> joka tulostaa korin sisältämät <em>Ostos</em>-oliot. Tulostusjärjestyksessä ei ole merkitystä. Edellisen esimerkin ostoskori tulostetuna olisi:
  </p>

  <% partial 'partials/sample_output' do %>
piimä: 1
juusto: 1
tietokone: 1
maito: 1
  <% end %>

  <p>
    Huomaa, että tulostuva numero on siis tuotteen korissa oleva kappalemäärä, ei hinta!
  </p>


  <h2>Yksi ostos tuotetta kohti</h2>

  <p>
    Täydennetään Ostoskoria siten, että jos korissa on jo tuote joka sinne lisätään, ei koriin luoda uutta Ostos-olioa vaan päivitetään jo korissa olevaa tuotetta vastaavaa ostosolioa kutsumalla sen metodia <em>kasvataMaaraa()</em>.
  </p>

  <p>
    Esimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
Ostoskori kori = new Ostoskori();
kori.lisaa("maito", 3);
kori.tulosta();
System.out.println("korin hinta: " + kori.hinta() + "\n");

kori.lisaa("piimä", 2);
kori.tulosta();
System.out.println("korin hinta: " + kori.hinta() + "\n");

kori.lisaa("maito", 3);
kori.tulosta();
System.out.println("korin hinta: " + kori.hinta() + "\n");

kori.lisaa("maito", 3);
kori.tulosta();
System.out.println("korin hinta: " + kori.hinta() + "\n");<% end %>

  <% partial 'partials/sample_output' do %>
maito: 1
korin hinta: 3

piimä: 1
maito: 1
korin hinta: 5

piimä: 1
maito: 2
korin hinta: 8

piimä: 1
maito: 3
korin hinta: 11
  <% end %>

  <p>
    Eli ensin koriin lisätään maito ja piimä ja niille omat ostos-oliot. Kun koriin lisätään lisää maitoa, ei luoda uusille maidoille omaa ostosolioa, vaan päivitetään jo korissa olevan maitoa kuvaavan ostosolion kappalemäärää.
  </p>


  <h2>Kauppa</h2>

  <p>
    Nyt meillä on valmiina kaikki osat "verkkokauppaa" varten. Verkkokaupassa on varasto joka sisältää kaikki tuotteet. Jokaista asiakkaan asiointia varten on oma ostoskori. Aina kun asiakas valitsee ostoksen, lisätään se asiakkaan ostoskoriin jos tuotetta on varastossa. Samalla varastosaldoa pienennetään yhdellä.
  </p>

  <p>
    Seuraavassa on valmiina verkkokaupan tekstikäyttöliittymän runko. Tee projektiin luokka <code>Kauppa</code> ja kopioi alla oleva koodi luokkaan.
  </p>

  <% partial 'partials/code_highlight' do %>
import java.util.Scanner;

public class Kauppa {

    private Varasto varasto;
    private Scanner lukija;

    public Kauppa(Varasto varasto, Scanner lukija) {
        this.varasto = varasto;
        this.lukija = lukija;
    }

    // metodi jolla hoidetaan yhden asiakkaan asiointi kaupassa
    public void asioi(String asiakas) {
        Ostoskori kori = new Ostoskori();
        System.out.println("Tervetuloa kauppaan " + asiakas);
        System.out.println("valikoimamme:");

        varasto.tuotteet().stream().forEach(t -&gt; System.out.println(t));

        while (true) {
            System.out.print("mitä laitetaan ostoskoriin (pelkkä enter vie kassalle):");
            String tuote = lukija.nextLine();
            if (tuote.isEmpty()) {
                break;
            }

            // tee tänne koodi joka lisää tuotteen ostoskoriin jos sitä on varastossa
            // ja vähentää varastosaldoa
            // älä koske muuhun koodiin!

        }

        System.out.println("ostoskorissasi on:");
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta());
    }
}
  <% end %>

  <p>
    Seuraavassa pääohjelma joka täyttää kaupan varaston ja laittaa Pekan asioimaan kaupassa:
  </p>

  <% partial 'partials/code_highlight' do %>
Varasto varasto = new Varasto();
varasto.lisaaTuote("kahvi", 5, 10);
varasto.lisaaTuote("maito", 3, 20);
varasto.lisaaTuote("piimä", 2, 55);
varasto.lisaaTuote("leipä", 7, 8);

Kauppa kauppa = new Kauppa(varasto, new Scanner(System.in));
kauppa.asioi("Pekka");
  <% end %>

  <p>
    Kauppa on melkein valmiina. Yhden asiakkaan asioinnin hoitavan metodin <code>public void asioi(String asiakas)</code> on kommenteilla merkitty kohta jonka joudut täydentämään. Lisää kohtaan koodi joka tarkastaa onko asiakkaan haluamaa tuotetta varastossa. Jos on, vähennä tuotteen varastosaldoa ja lisää tuote ostoskoriin.
  </p>

  <p>
    <em>Todellisuudessa verkkokauppa toteutettaisiin hieman eri tavalla. Verkkosovelluksia tehtäessä käyttöliittymä toteutetaan HTML-sivuna, ja sivuilla tapahtuvat klikkaukset ohjataan palvelinohjelmistolle. Teemaan liittyen löytyy useampia kursseja Helsingin yliopistolta.
    </em>
  </p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Maatilasimulaattori (5 osaa)' } do %>

  <p>
    Maatiloilla on lypsäviä eläimiä, jotka tuottavat maitoa.  Maatilat eivät itse käsittele maitoa, vaan se kuljetetaan Maitoautoilla meijereille.  Meijerit ovat yleisiä maitotuotteita tuottavia rakennuksia.  Jokainen meijeri erikoistuu yhteen tuotetyyppiin, esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja Maitomeijeri tuottaa maitoa.
  </p>

  <p>
    Rakennetaan maidon elämää kuvaava simulaattori.
  </p>


  <h2>Maitosäiliö</h2>

  <p>
    Jotta maito pysyisi tuoreena, täytyy se säilöä sille tarkoitettuun säiliöön. Säiliöitä valmistetaan sekä oletustilavuudella 2000 litraa, että asiakkaalle räätälöidyllä tilavuudella.  Toteuta luokka Maitosailio jolla on seuraavat konstruktorit ja metodit.
  </p>

  <ul>
    <li><strong>public Maitosailio()</strong></li>
    <li><strong>public Maitosailio(double tilavuus)</strong></li>
    <li><strong>public double getTilavuus()</strong></li>
    <li><strong>public double getSaldo()</strong></li>
    <li><strong>public double paljonkoTilaaJaljella()</strong></li>
    <li><strong>public void lisaaSailioon(double maara)</strong>
      lisää säiliöön vain niin paljon maitoa kuin sinne mahtuu,
      ylimääräiset jäävät lisäämättä, maitosäiliön ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</li>
    <li><strong>public double otaSailiosta(double maara)</strong>
      ottaa säiliöstä pyydetyn määrän, tai niin paljon kuin siellä on jäljellä
    </li>
  </ul>

  <p>
    Huomaa, että teet <em>kaksi konstruktoria</em>. Kutsuttava konstruktori määräytyy sille annettujen parametrien perusteella. Jos kutsut <code>new Maitosailio()</code>, suoritetaan ensimmäisen konstruktorin lähdekoodi. Toista konstruktoria taas kutsutaan antamalla konstruktorille parametrina tilavuus, esim. <code>new Maitosailio(300.0)</code>.
  </p>

  <p>
    Toteuta <code>Maitosailio</code>-luokalle myös <code>toString()</code>-metodi, jolla kuvaat sen tilaa. Ilmaistessasi säiliön tilaa <code>toString()</code>-metodissa, pyöristä litramäärät ylöspäin käyttäen <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.
  </p>

  <p>
    Testaa maitosailiötä seuraavalla ohjelmapätkällä:
  </p>

  <% partial 'partials/code_highlight' do %>
Maitosailio sailio = new Maitosailio();
sailio.otaSailiosta(100);
sailio.lisaaSailioon(25);
sailio.otaSailiosta(5);
System.out.println(sailio);

sailio = new Maitosailio(50);
sailio.lisaaSailioon(100);
System.out.println(sailio);
  <% end %>

  <% partial 'partials/sample_output' do %>
20.0/2000.0
50.0/50.0
  <% end %>


  <h2>Lehmä</h2>

  <p>
    Saadaksemme maitoa tarvitsemme myös lehmiä. Lehmällä on nimi ja utareet. Utareiden tilavuus on satunnainen luku väliltä 15 ja 40, luokkaa <code>Random</code> voi käyttäää satunnaislukujen arpomiseen, esimerkiksi  <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code> on seuraavat toiminnot:
  </p>

  <ul>
    <li><strong>public Lehma()</strong> luo uuden lehmän satunnaisesti valitulla nimellä</li>
    <li><strong>public Lehma(String nimi)</strong> luo uuden lehmän annetulla nimellä</li>
    <li><strong>public String getNimi()</strong> palauttaa lehmän nimen</li>
    <li><strong>public double getTilavuus()</strong> palauttaa utareiden tilavuuden</li>
    <li><strong>public double getMaara()</strong> palauttaa utareissa olevan maidon määrän</li>
    <li><strong>public String toString()</strong> palauttaa lehmää kuvaavan merkkijonon (ks. esimerkki alla)</li>
  </ul>

  <p>
    <code>Lehma</code> toteuttaa myös rajapinnat: <code>Lypsava</code>, joka kuvaa lypsämiskäyttäytymistä, ja <code>Eleleva</code>, joka kuvaa elelemiskäyttäytymistä.
  </p>

  <% partial 'partials/code_highlight' do %>
public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
  <% end %>


  <p>
    Lehmää lypsettäessä sen koko maitovarasto tyhjennetään jatkokäsittelyä varten. Lehmän elellessä sen maitovarasto täyttyy hiljalleen. Suomessa maidontuotannossa käytetyt lehmät tuottavat keskimäärin noin 25-30 litraa maitoa päivässä. Simuloidaan tätä tuotantoa tuottamalla noin 0.7 - 2 litraa tunnissa.
  </p>

  <p>
    Simuloi tuotantoa tuottamalla noin 0.7 - 2 litraa tunnissa. Random-luokan metodista <code>nextDouble</code>, joka palauttaa satunnaisluvun 0 ja 1 välillä lienee tässä hyötyä.
  </p>

  <p>
    Lisäksi, jos lehmälle ei anneta nimeä, valitse sille nimi satunnaisesti seuraavasta taulukosta. Tässä on hyötyä Random-luokan metodista <code>nextInt</code>, jolle annetaan parametrina yläraja. Kannattaa tutustua Random-luokan toimintaan erikseen ennen kuin lisää sen osaksi tätä ohjelmaa.
  </p>

  <% partial 'partials/code_highlight' do %>
private static final String[] NIMIA = new String[]{
    "Anu", "Arpa", "Essi", "Heluna", "Hely",
    "Hento", "Hilke", "Hilsu", "Hymy", "Matti", "Ilme", "Ilo",
    "Jaana", "Jami", "Jatta", "Laku", "Liekki",
    "Mainikki", "Mella", "Mimmi", "Naatti",
    "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
    "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
  <% end %>

  <p>
    Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmapätkän avulla.
  </p>

  <% partial 'partials/code_highlight' do %>
Lehma lehma = new Lehma();
System.out.println(lehma);


Eleleva elelevaLehma = lehma;
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();

System.out.println(lehma);

Lypsava lypsavaLehma = lehma;
lypsavaLehma.lypsa();

System.out.println(lehma);
System.out.println("");

lehma = new Lehma("Ammu");
System.out.println(lehma);
lehma.eleleTunti();
lehma.eleleTunti();
System.out.println(lehma);
lehma.lypsa();
System.out.println(lehma);
  <% end %>

  <p>
    Ohjelman tulostus on erimerkiksi seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
  <% end %>


  <h2>Lypsyrobotti</h2>

  <p>
    Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lypsämisen. Jotta lypsyrobotti voi lypsää lypsävää otusta, tulee lypsyrobotin olla kiinnitetty maitosäiliöön:
  </p>

  <ul>
    <li><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitosäiliö tai <code>null</code>-viitteen, jos säiliötä ei ole vielä kiinnitetty</li>
    <li><strong>public void setMaitosailio(Maitosailio maitosailio)</strong> kiinnittää annetun säiliön lypsyrobottiin</li>
    <li><strong>public void lypsa(Lypsava lypsava)</strong> lypsää lehmän robottiin kiinnitettyyn maitosäiliöön. Jos robottiin ei ole kiinnitetty maitosäiliötä, ohjelma ilmoittaa että maito menee hukkaan.</li>
  </ul>

  <p>
    Toteuta luokka Lypsyrobotti ja testaa sitä seuraavien ohjelmanpätkien avulla. Varmista että lypsyrobotti voi lypsää kaikkia Lypsava-rajapinnan toteuttavia olioita!
  </p>

  <% partial 'partials/code_highlight' do %>
Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
Lehma lehma = new Lehma();
lypsyrobotti.lypsa(lehma);
  <% end %>

  <% partial 'partials/sample_output' do %>
Maidot menevät hukkaan!
  <% end %>

  <% partial 'partials/code_highlight' do %>
Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
Lehma lehma = new Lehma();
System.out.println("");

Maitosailio sailio = new Maitosailio();
lypsyrobotti.setMaitosailio(sailio);
System.out.println("Säiliö: " + sailio);

for (int i = 0; i &lt; 2; i++) {
    System.out.println(lehma);
    System.out.println("Elellään..");
    for (int j = 0; j &lt; 5; j++) {
        lehma.eleleTunti();
    }
    System.out.println(lehma);

    System.out.println("Lypsetään...");
    lypsyrobotti.lypsa(lehma);
    System.out.println("Säiliö: " + sailio);
    System.out.println("");
}<% end %>

  <p>
    Ohjelman tulostus on esimerkiksi seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
Säiliö: 0.0/2000.0
Mella 0.0/23.0
Elellään..
Mella 6.2/23.0
Lypsetään...
Säiliö: 6.2/2000.0

Mella 0.0/23.0
Elellään..
Mella 7.8/23.0
Lypsetään...
Säiliö: 14.0/2000.0
  <% end %>


  <h2>Navetta</h2>

  <p>
    Lehmät hoidetaan (eli tässä tapauksessa lypsetään) navetassa. Alkukantaisissa navetoissa on maitosäiliö ja tilaa yhdelle lypsyrobotille. Huomaa että lypsyrobottia asennettaessa se kytketään juuri kyseisen navetan maitosäiliöön.  Jos navetassa ei ole lypsyrobottia, ei siellä voida myöskään hoitaa lehmiä. Toteuta luokka <code>Navetta</code> jolla on seuraavat konstruktorit ja metodit:
  </p>

  <ul>
    <li><strong>public Navetta(Maitosailio maitosailio)</strong></li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</li>
    <li><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnittää sen navetan maitosäiliöön</li>
    <li><strong>public void hoida(Lehma lehma)</strong> lypsää parametrina annetun lehmän lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lypsää parametrina annetut lehmät lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public String toString()</strong> palauttaa navetan sisältämän maitosäiliön tilan</li>
  </ul>

  <p>
    Testaa luokkaa <code>Navetta</code> seuraavan ohjelmapätkän avulla.
  </p>

  <% partial 'partials/code_highlight' do %>
Navetta navetta = new Navetta(new Maitosailio());
System.out.println("Navetta: " + navetta);

Lypsyrobotti robo = new Lypsyrobotti();
navetta.asennaLypsyrobotti(robo);

Lehma ammu = new Lehma();
ammu.eleleTunti();
ammu.eleleTunti();

navetta.hoida(ammu);
System.out.println("Navetta: " + navetta);

List&lt;Lehma&gt; lehmaLista = new ArrayList&lt;&gt;();
lehmaLista.add(ammu);
lehmaLista.add(new Lehma());

lehmaLista.stream().forEach(lehma -&gt; {
    lehma.eleleTunti();
    lehma.eleleTunti();
});

navetta.hoida(lehmaLista);
System.out.println("Navetta: " + navetta);
  <% end %>

  <p>
    Tulostuksen tulee olla esimerkiksi seuraavanlainen:
  </p>

  <% partial 'partials/sample_output' do %>
Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
  <% end %>


  <h2>Maatila</h2>

  <p>
    Maatilalla on omistaja ja siihen kuuluu navetta sekä joukko lehmiä. Maatila toteuttaa myös aiemmin nähdyn rajapinnan <code>Eleleva</code>, jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan liittyvät lehmät elelevät tunnin.  Toteuta luokka maatila siten, että se toimii seuraavien esimerkkiohjelmien mukaisesti.
  </p>

  <% partial 'partials/code_highlight' do %>
Maitosailio sailio = new Maitosailio();
Navetta navetta = new Navetta(sailio);

Maatila maatila = new Maatila("Esko", navetta);
System.out.println(maatila);

System.out.println(maatila.getOmistaja() + " on ahkera mies!");
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Ei lehmiä.
Esko on ahkera mies!
  <% end %>

  <% partial 'partials/code_highlight' do %>
Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
System.out.println(maatila);
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
    Naatti 0.0/19.0
    Hilke 0.0/30.0
    Sylkki 0.0/29.0
  <% end %>

  <% partial 'partials/code_highlight' do %>
Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));

maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());

maatila.eleleTunti();
maatila.eleleTunti();

System.out.println(maatila);
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
    Heluna 2.0/17.0
    Rima 3.0/32.0
    Ilo 3.0/25.0
  <% end %>

  <% partial 'partials/code_highlight' do %>
Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
Lypsyrobotti robo = new Lypsyrobotti();
maatila.asennaNavettaanLypsyrobotti(robo);

maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());

maatila.eleleTunti();
maatila.eleleTunti();

maatila.hoidaLehmat();

System.out.println(maatila);
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 18.0/2000.0
Lehmät:
    Hilke 0.0/30.0
    Sylkki 0.0/35.0
    Hento 0.0/34.0
  <% end %>

  <p>
    Edellä otettiin ensiaskeleet simulaattorin tekemiseen. Ohjelmaa voisi jatkaa vaikkapa lisäämällä maitoauton sekä luomalla useampia navettoja. Maitoautot voisivat kulkea tehtaalle, jossa tehtäisiin juustoa, jnejne..
  </p>

<% end %>




<% partial 'partials/material_heading' do %>
  Ohjelman rakenne ja pakkaukset
<% end %>


<p>
  Ohjelmaa varten toteutettujen luokkien määrän kasvaessa niiden toiminnallisuuksien ja metodien muistaminen vaikeutuu. Muistamista helpottaa luokkien järkevä nimentä sekä luokkien suunnittelu siten, että jokaisella luokalla on yksi selkeä vastuu. Tämän lisäksi luokat kannattaa jakaa toiminnallisuutta, käyttötarkoitusta tai jotain muuta loogista kokonaisuutta kuvaaviin pakkauksiin.
</p>

<p>
  Pakkaukset (<em>package</em>) ovat käytännössä hakemistoja (directory, puhekielessä myös kansio), joihin lähdekooditiedostot organisoidaan.
</p>

<p>
  Ohjelmointiympäristöt tarjoavat valmiit työkalut pakkausten hallintaan. Olemme tähän mennessä luoneet luokkia ja rajapintoja vain projektiin liittyvän lähdekoodipakkaukset-osion (<em>Source Packages</em>) oletuspakkaukseen (<em>default package</em>). Uuden pakkauksen voi luoda NetBeansissa projektin pakkauksiin liittyvässä Source Packages -osiossa oikeaa hiirennappia painamalla ja valitsemalla <em>New -&gt; Java Package...</em>.
</p>

<p>
  Pakkauksen sisälle voidaan luoda luokkia aivan kuten oletuspakkaukseenkin (<code>default package</code>). Alla luodaan juuri luotuun pakkaukseen <code>kirjasto</code> luokka <code>Sovellus</code>.
</p>

<p>
  Luokan pakkaus -- eli pakkaus, jossa luokka sijaitsee -- ilmaistaan lähdekooditiedoston alussa lauseella <code>package <em>pakkaus</em>;</code>. Alla oleva luokka <code>Sovellus</code> sijaitsee pakkauksessa <code>kirjasto</code>.
</p>

<% partial 'partials/code_highlight' do %>
  package kirjasto;

  public class Sovellus {

      public static void main(String[] args) {
          System.out.println("Hello packageworld!");
      }
  }
<% end %>

<p>
  Jokainen pakkaus -- myös oletuspakkaus eli default package -- voi sisältää useampia pakkauksia. Esimerkiksi pakkausmäärittelyssä <code>package kirjasto.domain</code> pakkaus <code>domain</code> on pakkauksen <code>kirjasto</code> sisällä. Edellä käytettyä nimeä <code>domain</code> käytetään usein kuvaamaan sovellusalueen käsitteisiin liittyvien luokkien säilytyspaikkaa. Esimerkiksi luokka <code>Kirja</code> voisi hyvin olla pakkauksen <code>kirjasto.domain</code> sisällä, sillä se kuvaa kirjastosovellukseen liittyvää käsitettä.
</p>

<% partial 'partials/code_highlight' do %>
  package kirjasto.domain;

  public class Kirja {
      private String nimi;

      public Kirja(String nimi) {
          this.nimi = nimi;
      }

      public String getNimi() {
          return this.nimi;
      }
  }
<% end %>

<p>
  Pakkauksissa olevia luokkia tuodaan luokan käyttöön <code>import</code>-lauseen avulla. Pakkauksessa <code>kirjasto.domain</code> oleva luokka <code>Kirja</code> tuodaan käyttöön puolipisteeseen päättyvällä lauseella <code>import kirjasto.domain.Kirja</code>. Luokkien tuomiseen käytetyt import-lauseet asetetaan lähdekooditiedostoon pakkausmäärittelyn jälkeen.
</p>


<% partial 'partials/code_highlight' do %>
  package kirjasto;

  import kirjasto.domain.Kirja;

  public class Sovellus {

      public static void main(String[] args) {
          Kirja kirja = new Kirja("pakkausten ABC!");
          System.out.println("Hello packageworld: " + kirja.getNimi());
      }
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Hello packageworld: pakkausten ABC!
<% end %>


<p>
  Jatkossa <em>kaikissa</em> tehtävissämme käytetään pakkauksia. Luodaan seuraavaksi ensimmäiset pakkaukset itse.
</p>

<% partial 'partials/exercise', locals: { name: 'Ensimmäisiä pakkauksia (3 osaa)' } do %>


  <h2>Käyttöliittymä-rajapinta</h2>

  <p>
    Luo projektipohjaan pakkaus <code>mooc</code>. Rakennetaan tämän pakkauksen sisälle sovelluksen toiminta. Lisää pakkaukseen mooc pakkaus <code>ui</code> (tämän jälkeen käytössä pitäisi olla pakkaus <code>mooc.ui</code>), ja lisää sinne rajapinta <code>Kayttoliittyma</code>.
  </p>

  <p>
    Rajapinnan <code>Kayttoliittyma</code> tulee määritellä metodi <code>void paivita()</code>.
  </p>


  <h2>Tekstikäyttöliittymä</h2>

  <p>
    Luo samaan pakkaukseen luokka <code>Tekstikayttoliittyma</code>, joka toteuttaa rajapinnan <code>Kayttoliittyma</code>. Toteuta luokassa <code>Tekstikayttoliittyma</code> rajapinnan <code>Kayttoliittyma</code> vaatima metodi <code>public void paivita()</code> siten, että sen ainut tehtävä on merkkijonon "<code>Päivitetään käyttöliittymää</code>"-tulostaminen <code>System.out.println</code>-metodikutsulla.
  </p>


  <h2>Sovelluslogiikka</h2>

  <p>
    Luo tämän jälkeen pakkaus <code>mooc.logiikka</code>, ja lisää sinne luokka <code>Sovelluslogiikka</code>. Sovelluslogiikan tarjoaman toiminnallisuuden tulee olla seuraavanlainen.
  </p>

  <ul>
    <li>
      <code>public Sovelluslogiikka(Kayttoliittyma kayttoliittyma)</code><br/>Sovelluslogiikka-luokan konstruktori. Saa parametrina Kayttoliittyma-rajapinnan toteuttavan luokan. Huom: jotta sovelluslogiikka näkisi rajapinnan, on sen "importoitava" se, eli tarvitset tiedoston alkuun rivin <code>import mooc.ui.Kayttoliittyma;</code>
    </li>
    
    <li>
      <code>public void suorita(int montaKertaa)</code><br/>Tulostaa <code>montaKertaa</code>-muuttujan määrittelemän määrän merkkijonoa "Sovelluslogiikka toimii". Jokaisen "Sovelluslogiikka toimii"-tulostuksen jälkeen tulee kutsua konstruktorin parametrina saadun rajapinnan <code>Kayttoliittyma</code>-toteuttaman olion määrittelemää <code>paivita()</code>-metodia.
    </li>
  </ul>

  <p>
    Voit testata sovelluksen toimintaa seuraavalla pääohjelmaluokalla.
  </p>

  <% partial 'partials/code_highlight' do %>
    import mooc.logiikka.Sovelluslogiikka;
    import mooc.ui.Kayttoliittyma;
    import mooc.ui.Tekstikayttoliittyma;

    public class Main {

        public static void main(String[] args) {
            Kayttoliittyma kayttoliittyma = new Tekstikayttoliittyma();
            new Sovelluslogiikka(kayttoliittyma).suorita(3);
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Sovelluslogiikka toimii
    Päivitetään käyttöliittymää
    Sovelluslogiikka toimii
    Päivitetään käyttöliittymää
    Sovelluslogiikka toimii
    Päivitetään käyttöliittymää
  <% end %>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hakemistorakenne tiedostojärjestelmässä
<% end %>

<p>
  Kaikki NetBeansissa näkyvät projektit ovat tietokoneesi <em><a href="http://fi.wikipedia.org/wiki/Tiedostoj%C3%A4rjestelm%C3%A4" target="_blank" rel="noopener">tiedostojärjestelmässä</a></em> tai jollain keskitetyllä levypalvelimella. Jokaiselle projektille on olemassa oma hakemisto, jonka sisällä on projektiin liittyvät tiedostot ja hakemistot.
</p>

<p>
  Projektin hakemistossa <code>src</code> on ohjelmaan liittyvät lähdekoodit. Jos luokan pakkauksena on kirjasto, sijaitsee se projektin lähdekoodihakemiston <code>src</code> sisällä olevassa hakemistossa <code>kirjasto</code>. NetBeansissa voi käydä katsomassa projektien konkreettista rakennetta <em>Files</em>-välilehdeltä joka on normaalisti <em>Projects</em>-välilehden vieressä. Jos et näe välilehteä <em>Files</em>, saa sen näkyville valitsemalla vaihtoehdon <em>Files</em> valikosta <em>Window</em>.
</p>

<p>
  Sovelluskehitystä tehdään normaalisti <em>Projects</em>-välilehdeltä, jossa NetBeans on piilottanut projektiin liittyviä tiedostoja joista ohjelmoijan ei tarvitse välittää.
</p>


<% partial 'partials/material_sub_heading' do %>
  Pakkaukset ja näkyvyysmääreet
<% end %>

<p>
  Olemme tähän mennessä käyttäneet kahta näkyvyysmäärettä. Näkyvyysmääreellä <code>private</code> määritellään muuttujia (ja metodeja), jotka ovat näkyvissä vain sen luokan sisällä joka määrittelee ne. Niitä ei voi käyttää luokan ulkopuolelta. Näkyvyysmääreellä <code>public</code> varustetut metodit ja muuttujat ovat taas kaikkien käytettävissä.
</p>

<% partial 'partials/code_highlight' do %>
  package kirjasto.ui;

  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {
          tulostaOtsikko();

          // muu toiminnallisuus
      }

      private void tulostaOtsikko() {
          System.out.println("************");
          System.out.println("* KIRJASTO *");
          System.out.println("************");
      }
  }
<% end %>

<p>
  Yllä olevasta <code>Kayttoliittyma</code>-luokasta tehdyn olion konstruktori ja <code>kaynnista</code>-metodi on kutsuttavissa mistä tahansa ohjelmasta. Metodi <code>tulostaOtsikko</code> ja <code>lukija</code>-muuttuja on käytössä vain luokan sisällä.
</p>

<p>
  Jos näkyvyysmäärettä ei määritellä, metodit ja muuttujat ovat näkyvillä saman pakkauksen sisällä. Tätä kutsutaan oletus- tai pakkausnäkyvyydeksi. Muutetaan yllä olevaa esimerkkiä siten, että metodilla <code>tulostaOtsikko</code> on pakkausnäkyvyys.
</p>

<% partial 'partials/code_highlight' do %>
  package kirjasto.ui;

  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {
          tulostaOtsikko();

          // muu toiminnallisuus
      }

      void tulostaOtsikko() {
          System.out.println("************");
          System.out.println("* KIRJASTO *");
          System.out.println("************");
      }
  }
<% end %>

<p>
  Nyt saman pakkauksen sisällä olevat luokat -- eli luokat, jotka sijaitsevat pakkauksessa <code>kirjasto.ui</code> voivat käyttää metodia <code>tulostaOtsikko</code>.
</p>

<% partial 'partials/code_highlight' do %>
  package kirjasto.ui;

  import java.util.Scanner;

  public class Main {

      public static void main(String[] args) {
          Scanner lukija = new Scanner(System.in);
          Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

          kayttoliittyma.tulostaOtsikko(); // onnistuu!
      }
  }
<% end %>

<p>
  Jos luokka on eri pakkauksessa, ei metodia <code>tulostaOtsikko</code> pysty käyttämään. Alla olevassa esimerkissä luokka Main on pakkauksessa <code>kirjasto</code>, jolloin pakkauksessa <code>kirjasto.ui</code> pakkausnäkyvyydellä määriteltyyn metodiin <code>tulostaOtsikko</code> ei pääse käsiksi.
</p>

<% partial 'partials/code_highlight' do %>
  package kirjasto;

  import java.util.Scanner;
  import kirjasto.ui.Kayttoliittyma;

  public class Main {

      public static void main(String[] args) {
          Scanner lukija = new Scanner(System.in);
          Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

          kayttoliittyma.tulostaOtsikko(); // ei onnistu!
      }
  }
<% end %>



<% partial 'partials/exercise', locals: { name: 'Lentokenttä (3 osaa)' } do %>

  <p>
    Tässä tehtävässä pääset suunnittelemaan vapaasti ohjelman rakenteen. Käyttöliittymän ulkomuoto sekä vaaditut komennot on määritelty ennalta. Tehtävä on kolmen yksittäisen tehtäväpisteen arvoinen.
  </p>

  <p>
    <strong>Huom: jotta testit toimisivat, saat luoda ohjelmassasi vain yhden Scanner-olion käyttäjän syötteen lukemiseen.</strong>
  </p>

  <p>
    Lentokenttä-tehtävässä toteutetaan lentokentän hallintasovellus. Lentokentän hallintasovelluksessa hallinnoidaan lentokoneita ja lentoja. Lentokoneista tiedetään aina tunnus ja kapasiteetti. Lennoista tiedetään lennon lentokone, lähtöpaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank" rel="noopener">HEL</a>) ja kohdepaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank" rel="noopener">BAL</a>).
  </p>

  <p>
    Sekä lentokoneita että lentoja voi olla useita. Samalla lentokoneella voidaan myös lentää useita eri lentoja.
  </p>

  <p>
    Sovelluksen tulee toimia kahdessa vaiheessa: ensin syötetään lentokoneiden ja lentojen tietoja hallintakäyttöliittymässä, jonka jälkeen siirrytään lentopalvelun käyttöön. Lentopalvelussa on kolme toimintoa; lentokoneiden tulostaminen, lentojen tulostaminen, ja lentokoneen tietojen tulostaminen. Tämän lisäksi käyttäjä voi poistua ohjelmasta valitsemalla vaihtoehdon <code>x</code>. Jos käyttäjä syöttää epäkelvon komennon, kysytään komentoa uudestaan.
  </p>


  <% partial 'partials/sample_output' do %>
    Lentokentän hallinta
    --------------------

    Valitse toiminto:
    [1] Lisää lentokone
    [2] Lisää lento
    [x] Poistu hallintamoodista
    &gt; <font color="red">1</font>
    Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
    Anna lentokoneen kapasiteetti: <font color="red">42</font>
    Valitse toiminto:
    [1] Lisää lentokone
    [2] Lisää lento
    [x] Poistu hallintamoodista
    &gt; <font color="red">1</font>
    Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
    Anna lentokoneen kapasiteetti: <font color="red">101</font>
    Valitse toiminto:
    [1] Lisää lentokone
    [2] Lisää lento
    [x] Poistu hallintamoodista
    &gt; <font color="red">2</font>
    Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
    Anna lähtöpaikan tunnus: <font color="red">HEL</font>
    Anna kohdepaikan tunnus: <font color="red">BAL</font>
    Valitse toiminto:
    [1] Lisää lentokone
    [2] Lisää lento
    [x] Poistu hallintamoodista
    &gt; <font color="red">2</font>
    Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
    Anna lähtöpaikan tunnus: <font color="red">JFK</font>
    Anna kohdepaikan tunnus: <font color="red">BAL</font>
    Valitse toiminto:
    [1] Lisää lentokone
    [2] Lisää lento
    [x] Poistu hallintamoodista
    &gt; <font color="red">2</font>
    Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
    Anna lähtöpaikan tunnus: <font color="red">BAL</font>
    Anna kohdepaikan tunnus: <font color="red">HEL</font>
    Valitse toiminto:
    [1] Lisää lentokone
    [2] Lisää lento
    [x] Poistu hallintamoodista
    &gt; <font color="red">x</font>

    Lentopalvelu
    ------------

    Valitse toiminto:
    [1] Tulosta lentokoneet
    [2] Tulosta lennot
    [3] Tulosta lentokoneen tiedot
    [x] Lopeta
    &gt; <font color="red">1</font>
    G-OWAC (101 henkilöä)
    HA-LOL (42 henkilöä)
    Valitse toiminto:
    [1] Tulosta lentokoneet
    [2] Tulosta lennot
    [3] Tulosta lentokoneen tiedot
    [x] Lopeta
    &gt; <font color="red">2</font>
    HA-LOL (42 henkilöä) (HEL-BAL)
    HA-LOL (42 henkilöä) (BAL-HEL)
    G-OWAC (101 henkilöä) (JFK-BAL)

    Valitse toiminto:
    [1] Tulosta lentokoneet
    [2] Tulosta lennot
    [3] Tulosta lentokoneen tiedot
    [x] Lopeta
    &gt; <font color="red">3</font>
    Mikä kone: <font color="red">G-OWAC</font>
    G-OWAC (101 henkilöä)

    Valitse toiminto:
    [1] Tulosta lentokoneet
    [2] Tulosta lennot
    [3] Tulosta lentokoneen tiedot
    [x] Lopeta
    &gt; <font color="red">x</font>
  <% end %>

  <p>
    <strong>Huom1:</strong> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii <strong>täsmälleen</strong> kuten yllä kuvattu. Ohjelman tulostamat vaihtoehdot kannattanee copypasteta tästä ohjelmakoodiin. Testit eivät oleta, että ohjelmasi on varautunut epäkelpoihin syötteisiin.
  </p>

  <p>
    <strong>Huom2:</strong> älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!
  </p>

  <p>
    <em>
      <strong>Ohjelman tulee käynnistyä kun pakkauksessa lentokentta olevan luokan Main metodi main suoritetaan.</strong>
    </em>
  </p>

<% end %>




<%= partial 'partials/quiz', locals: { id: '59f5f23a271b380004a262e2' } %>
